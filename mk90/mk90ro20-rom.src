; Elektronika MK-90 main ROM disassembly, BASIC V2.0
; all numbers are hexadecimal unless stated otherwise

; The MK-92 ROM consists of 4 pages of 4000 bytes size and shares the address
; range 4000-7FFF with the MK-90 test ROM.
; Function of individual bits (bit numbers are decimal) of the register E880:
; Bit 13	- switches the ROM banks, enables the MK-92 ROM when set
; Bits 12,11	- select the MK-92 ROM page

0000:
0004:				;odd address when accessing word size data,
				;accessing nonexisting memory,
				;HALT in the user mode,
				;JMP/JSR with a register as the destination
0008:				;unimplemented instruction
000C:				;vector BPT
0010:				;vector IOT
0014:				;vector POK (power supply)
0018:				;vector EMT
001C:	.word	808A		;vector TRAP
0028:	.word	0000
0040:	.word	BED6, 0000	;EVNT interrupt vector (timer)
0078:				;INT0 interrupt vector
007C:				;INT1 interrupt vector
00B8:				;INT2 interrupt vector
00BC:				;INT3 interrupt vector
00C8:	.word	BD68, 0000	;keyboard controller interrupt vector
00FC:	.word	C5AE, 0000
0200:	.blkb	03C0		;display RAM
05C0:				;USRBUF
0C3C:	.word	0007		;height of a character in pixels
0C3E:	.word	0005		;width of a character in pixels
0C40:	.word	0023		;number of bits to store each character in
				;the font table
0D02:	.word	0200		;address of the display RAM
0D14:	.word	0040		;height of the screen in pixels
0D16:	.word	0078		;width of the screen in pixels
0D1C:	.word	0070
0D5C:	.blkw	1		;print mode
				;bit 6 set - output to the plotter
				;bit 0 set - inverted print mode
0D86:	.blkw	1		;key scan code
0E6E:	.blkw	1		;SU keyboard mode if not zero
0E9E:	.blkb	0050		;input line buffer (up to 80 characters)
0EF0:	.blkw	1		;current line number
0F14:	.blkw	1		;counter decremented at each EVNT interrupt
0F18:	.blkw	1		;flag of a pressed key
0F50:	.blkb	4		;address in a memory module (big endian order)
				;RAM module - used bytes 0F52..0F53
				;ROM module - used bytes 0F51..0F53
0F54:	.blkw	1		;memory module type: 0=read/write, 1=read only

; default system error handler routine
8000:	mov	(sp)+,r1	;get the PC
8002:	tst	(sp)+		;drop the PSW
8004:	mov	#C8B,r0		;buffer for the octal number 0C85-0C8A
8008:	mov	#6,r4		;number of digits
800C:	jsr	pc,801A		;convert the word in r1 to octal ASCII
8010:	mov	#C78,r0		;string 'SBOJ PO ADR'
8014:	trap	36		;print a string pointed to by r0
8016:	jmp	86AC		;restart the BASIC system

; convert the word in r1 to octal ASCII, number of digits in r4
801A:	mov	r1,r2
801C:	bic	#FFF8,r2
8020:	bis	#30,r2		;'0'
8024:	movb	r2,-(r0)
8026:	clc
8028:	ror	r1
802A:	asr	r1
802C:	asr	r1
802E:	sob	r4,801A		;next digit
8030:	rts	pc

; trap 6C
8032:	mov	0D02,r1		;address of the display RAM
8036:	mov	#01E0,r2	;size of the display RAM (03C0 bytes)
803A:	clr	(r1)+
803C:	sob	r2,803A
803E:	mov	0D02,@#E800	;address of the display RAM
8044:	mov	#88C6,@#E802
804A:	mov	#BD68,@#C8	;keyboard controller interrupt vector
8050:	clr	@#CA
8054:	mov	#0200,@#E812
805A:	mov	#E2,@#E814
8060:	jsr	pc,C236
8064:	clr	@#28
8068:	mov	#BED6,@#40	;EVNT (timer) interrupt vector
806E:	clr	@#42
8072:	mov	#C5AE,@#FC
8078:	clr	@#FE
807C:	tst	@#E81E
8080:	bmi	8088
8082:	bis	#4020,@#E880
8088:	rts	pc

; TRAP handler routine
808A:	mov	(sp),0002(sp)
808E:	sub	#2,(sp)
8092:	mov	@(sp)+,-(sp)
8094:	asr	(sp)
8096:	blo	80A0
; even traps = system function calls
8098:	asl	(sp)
809A:	add	#F812,(sp)	;F812 + TRAP_0_opcode = 8112
809E:	mov	@(sp)+,pc
; odd traps = error_codes * 2 + 1
80A0:	bic	#FF80,(sp)
80A4:	mov	(sp)+,r2
80A6:	cmp	r2,#40
80AA:	bgt	80BE		;recoverable errors (error code > 64)
; unrecoverable errors (error code <= 64)
80AC:	clr	0EFC
80B0:	mov	#1,0CFC
80B6:	mov	0D00,sp
80BA:	mov	#8A56,-(sp)
80BE:	tst	0F0E
80C2:	ble	80D6
80C4:	mov	0F0E,r0
80C8:	mov	0EF0,0F0A
80CE:	neg	0F0E
80D2:	jmp	8B6E
;
80D6:	mov	r1,-(sp)
80D8:	mov	0C48,-(sp)
80DC:	jsr	pc,AA96
80E0:	clr	0F20
80E4:	mov	r2,r1
80E6:	mov	r2,0F0C
80EA:	mov	0EF0,0F0A
80F0:	mov	#C90,r0		;address of the error code as an ASCII string
80F4:	mov	r1,-(sp)	;error code
80F6:	trap	0A		;ITOA
80F8:	trap	02		;print CR, LF
80FA:	mov	#C8D,r0		;string 'OSH        STR ' - error X in line X
80FE:	trap	36		;print a string pointed to by r0
8100:	trap	04		;display the line number 0EF0
8102:	trap	02		;print CR, LF
8104:	tst	(sp)+
8106:	bne	810A
8108:	trap	4E
810A:	mov	(sp)+,0C48
810E:	mov	(sp)+,r1
8110:	rts	pc

; TRAP vectors
8112:	.word	81A6, 81D2, 84CA, 937E		;trap 00, 02, 04, 06
811A:	.word	9662, 9688, 96B8, 972C		;trap 08, 0A, 0C, 0E
8122:	.word	97D0, 9864, 9882, 98AA		;trap 10, 12, 14, 16
812A:	.word	9940, 9A0A, 9A16, 99B8		;trap 18, 1A, 1C, 1E
8132:	.word	9A80, 9A7A, 9D2A, 9D68		;trap 20, 22, 24, 26
813A:	.word	9D3A, 9CE2, 9A2E, 9D36		;trap 28, 2A, 2C, 2E
8142:	.word	9F98, 9740, 9760, 81DC		;trap 30, 32, 34, 36
814A:	.word	8180, 82BC, 83D6, 83B8		;trap 38, 3A, 3C, 3E
8152:	.word	81F8, 83CE, 845C, 8430		;trap 40, 42, 44, 46
815A:	.word	82C6, 8308, 8346, 82D6		;trap 48, 4A, 4C, 4E
8162:	.word	83B0, 8386, 8422, 83FC		;trap 50, 52, 54, 56
816A:	.word	84E6, 846A, 84F2, 8C5E		;trap 58, 5A, 5C, 5E
8172:	.word	8500, 850C, 8F42, 82EA		;trap 60, 62, 64, 66
817A:	.word	82FA, 0000, 8032		;trap 68, 6A, 6C

; trap 38 - test if r2 is a digit
; returns V set if r2 is not a digit
; returns Z set if r2 is a decimal digit '0'..'9'
; returns V cleared if r2 is a hex digit 'A'..'F'
8180:	cmp	r2,#30		;'0'
8184:	blt	81A0
8186:	cmp	r2,#39		;'9'
818A:	bgt	8190
818C:	set	z		;decimal digit: Z=1, V=0
818E:	rts	pc
8190:	cmp	r2,#41		;'A'
8194:	blt	81A0
8196:	cmp	r2,#5A		;'Z'
819A:	bgt	81A0
819C:	clear	cvzn		;hexadecimal digit: Z=0, V=0
819E:	rts	pc
81A0:	clear	cvzn
81A2:	set	v		;not a digit: Z=0, V=1
81A4:	rts	pc

; trap 00 - print character r2
81A6:	mov	r1,-(sp)
81A8:	tst	0EFE
81AC:	beq	81B4
81AE:	jsr	pc,DB74
81B2:	br	81CE
81B4:	tst	0F20
81B8:	beq	81C0
81BA:	jsr	pc,5024
81BE:	br	81CE
81C0:	tst	0CFC
81C4:	beq	81CE
81C6:	inc	0CFE
81CA:	jsr	pc,A01C		;display character r2
81CE:	mov	(sp)+,r1
81D0:	rts	pc

; trap 02 - print CR, LF
81D2:	mov	#FFFE,0EFA
81D8:	mov	#8A25,r0	;string CR, LF

; trap 36 - print a zero terminated string pointed to by r0
81DC:	movb	(r0)+,r2
81DE:	beq	81D0
81E0:	trap	00		;print character r2
81E2:	br	81DC

81E4:	jsr	pc,A532
81E8:	tst	0EFC
81EC:	bne	81FC
81EE:	cmp	#E9E,r3
81F2:	bhis	81F8
81F4:	dec	r3
81F6:	br	81FC

; trap 40 - input a line from the keyboard
; returns a pointer to the input buffer in R1
81F8:	mov	#E9E,r3		;input line buffer
81FC:	tst	0EFC
8200:	beq	820C
8202:	clr	0CFC
8206:	jsr	pc,DA0A
820A:	br	8216
820C:	inc	0CFE
8210:	jsr	pc,BF3A		;wait for a key
8214:	beq	81FC
8216:	bic	#FF80,r2
821A:	cmpb	r2,#10
821E:	beq	8284
8220:	cmpb	#D,r2
8224:	bne	822E
8226:	trap	02		;print CR, LF
8228:	mov	#A,r2
822C:	br	8258
822E:	cmpb	#7F,r2
8232:	beq	81E4
8234:	cmpb	#15,r2
8238:	beq	8274
823A:	cmpb	#A,r2
823E:	beq	8256
8240:	cmpb	#E,r2
8244:	beq	8256
8246:	cmpb	#F,r2
824A:	beq	8256
824C:	cmpb	#20,r2
8250:	ble	8256
8252:	movb	#3F,r2
8256:	trap	00		;print character r2
8258:	movb	r2,(r3)+
825A:	cmpb	r2,#A
825E:	beq	8268
8260:	cmp	r3,#EEF
8264:	blo	81FC		;branch if less than or equal 80 characters
8266:	trap	19		;error 12 - input line too long
8268:	mov	#E9E,r1		;input line buffer
826C:	mov	#1,0CFC
8272:	rts	pc
8274:	movb	#5E,r2
8278:	trap	00		;print character r2
827A:	movb	#55,r2
827E:	trap	00		;print character r2
8280:	trap	02		;print CR, LF
8282:	br	81F8
8284:	clr	-(sp)
8286:	mov	#86BE,-(sp)
828A:	mov	r2,-(sp)
828C:	br	82A4
828E:	trap	07		;error 3 - illegal character
8290:	mov	r2,-(sp)
8292:	jsr	pc,BF3A		;wait for a key
8296:	bic	#FF80,r2
829A:	cmpb	r2,#10
829E:	beq	82A4
82A0:	mov	(sp)+,r2
82A2:	rti
82A4:	mov	0CFC,-(sp)
82A8:	jsr	pc,AA96
82AC:	clr	0F20
82B0:	mov	(sp)+,0CFC
82B4:	mov	#1,0F00
82BA:	br	82A0

; trap 3A - GETNSC, get a character other than space
82BC:	movb	(r1)+,r2
82BE:	cmp	#20,r2
82C2:	beq	82BC
82C4:	rts	pc

; trap 48
82C6:	cmpb	(r1),#3A
82CA:	beq	82D4
82CC:	cmpb	(r1)+,#A
82D0:	bne	82C6
82D2:	dec	r1
82D4:	rts	pc

; trap 4E
82D6:	clr	0EF8
82DA:	tst	0EF6
82DE:	beq	82E8
82E0:	mov	0EF6,r5
82E4:	clr	0EF6
82E8:	rts	pc

; trap 66
82EA:	trap	4A
82EC:	clr	r0
82EE:	trap	4A
82F0:	mov	r5,r0
82F2:	trap	4A
82F4:	trap	4A
82F6:	trap	4A
82F8:	rts	pc

; trap 68
82FA:	mov	r2,r0
82FC:	trap	4A
82FE:	mov	r3,r0
8300:	trap	4A
8302:	mov	r4,r0
8304:	trap	4A
8306:	rts	pc

; trap 4A
8308:	mov	r4,-(sp)
830A:	mov	r5,r4
830C:	add	#14,r4
8310:	cmp	r4,sp
8312:	bhis	832C
8314:	tst	0EF6
8318:	bne	8326
831A:	mov	r5,0EF6
831E:	inc	r5
8320:	asr	r5
8322:	clc
8324:	asl	r5
8326:	mov	r0,(r5)+
8328:	mov	(sp)+,r4
832A:	rts	pc
832C:	trap	01		;error 0 - out of memory
832E:	mov	(r3),r0
8330:	bic	(sp),r0
8332:	cmp	r0,r4
8334:	beq	835C
8336:	bic	#1FFF,r0
833A:	cmp	#4000,r0
833E:	bne	8364
8340:	add	#10,r3
8344:	br	8352

; trap 4C
8346:	tst	r3
8348:	beq	8362
834A:	cmp	r5,sp
834C:	bhis	832C
834E:	mov	r1,-(sp)
8350:	mov	r0,-(sp)
8352:	cmp	r3,sp
8354:	bhis	832C
8356:	cmp	r3,r5
8358:	blo	832E
835A:	clr	r3
835C:	mov	(sp)+,r0
835E:	mov	(sp)+,r1
8360:	tst	r3
8362:	rts	pc
8364:	bgt	8370
8366:	add	#2,r3
836A:	add	#4,r3
836E:	br	8352
8370:	tst	r0
8372:	beq	8378
8374:	tst	(r3)+
8376:	br	8352
8378:	movb	0002(r3),r0
837C:	movb	0003(r3),r1
8380:	trap	52
8382:	add	r0,r3
8384:	br	836A

; trap 52
8386:	bic	#FF00,r0
838A:	bic	#FF00,r1
838E:	inc	r0
8390:	inc	r1
8392:	mov	r4,-(sp)
8394:	mov	r3,-(sp)
8396:	trap	0E		;IMUL
8398:	mov	(sp)+,r3
839A:	mov	(sp)+,r4
839C:	tst	r1
839E:	bne	83AC
83A0:	cmp	r0,#2400
83A4:	bhis	83AC
83A6:	trap	58		;multiply r0 by 6
83A8:	clear	cvzn
83AA:	rts	pc
83AC:	set	v
83AE:	rts	pc

; trap 50
83B0:	mov	r3,r1
83B2:	mov	r1,r2
83B4:	add	r4,r1
83B6:	br	83C0

; trap 3E
83B8:	trap	4E
83BA:	mov	r1,r3
83BC:	mov	r1,r2
83BE:	trap	42		;move the pointer r1 to the end of the line
83C0:	cmp	r1,r5
83C2:	bhis	83C8
83C4:	movb	(r1)+,(r3)+
83C6:	br	83C0
83C8:	mov	r3,r5
83CA:	mov	r2,r1
83CC:	rts	pc

; trap 42 - move the pointer r1 to the end of the line
83CE:	cmpb	(r1)+,#A
83D2:	bne	83CE
83D4:	rts	pc

; trap 3C
83D6:	mov	0EF2,r1
83DA:	trap	42		;move the pointer r1 to the end of the line
83DC:	cmp	r1,r5
83DE:	bhis	83F6
83E0:	mov	r0,-(sp)
83E2:	mov	r1,-(sp)
83E4:	trap	08		;ATOI
83E6:	mov	(sp)+,r1
83E8:	mov	r0,r2
83EA:	mov	(sp)+,r0
83EC:	cmp	r0,r2
83EE:	bgt	83DA
83F0:	beq	83F4
83F2:	clear	cvzn
83F4:	rts	pc
83F6:	clear	cvzn
83F8:	set	v
83FA:	rts	pc

; trap 56 - get a variable name (single letter or a letter followed by
; a single digit)
; returned values:
; r1 - pointer to the parsed string
; r2 - first unprocessed character other than space
; r4 - letter code in bits 11-6, digit in ASCII format in bits 5-0
; V flag cleared if name found
83FC:	trap	3A		;get a character other than space to r2
83FE:	trap	38		;is r2 a digit?
8400:	beq	841E		;branch if yes
8402:	bvs	841E
8404:	bic	#FFC0,r2
8408:	mov	r2,r4
840A:	swab	r4
840C:	asr	r4
840E:	asr	r4
8410:	trap	3A		;get a character other than space to r2
8412:	trap	38		;is r2 a digit?
8414:	bne	841A		;branch if not
8416:	bis	r2,r4
8418:	trap	3A		;get a character other than space to r2
841A:	clear	cvzn
841C:	rts	pc
841E:	set	v
8420:	rts	pc

; trap 54
8422:	tst	r0
8424:	blt	83F2
8426:	cmp	r0,#FF
842A:	bgt	83F2
842C:	set	z
842E:	rts	pc

; trap 46 - get a pair of integer numbers separated by a comma
; on entry r1 points to the parsed string
; returned values:
; r3 <- first number
; r4 <- second number
; r2 <- separator between numbers
8430:	trap	3A		;get a character other than space to r2
8432:	trap	38		;is r2 a digit?
8434:	bne	8454		;branch if r2 is not a decimal digit
8436:	dec	r1
8438:	trap	08		;ATOI
843A:	mov	r0,-(sp)
843C:	trap	3A		;get a character other than space to r2
843E:	cmp	#2C,r2		;comma?
8442:	bne	8458
8444:	mov	r2,-(sp)
8446:	trap	08		;ATOI
8448:	mov	(sp)+,r2
844A:	tst	r0
844C:	beq	8458
844E:	mov	r0,r4
8450:	mov	(sp)+,r3
8452:	rts	pc
8454:	clr	-(sp)
8456:	br	843E
8458:	clr	r4
845A:	br	8450

; trap 44 - check the available stack space
845C:	mov	r5,r4
845E:	add	r0,r4
8460:	mov	sp,r3
8462:	sub	#38,r3
8466:	cmp	r3,r4
8468:	rts	pc

; trap 5A
846A:	mov	r3,-(sp)
846C:	trap	5E		;evaluate an arithmetical expression
846E:	bvs	84AE
8470:	cmpb	(r1),#2C
8474:	bne	84B4
8476:	jsr	pc,84B8
847A:	trap	3A		;get a character other than space to r2
847C:	mov	r0,-(sp)
847E:	trap	5E		;evaluate an arithmetical expression
8480:	bvc	84B4
8482:	trap	20		;FIX
8484:	bmi	84B6
8486:	mov	(sp)+,r2
8488:	mov	@0000(sp),r4
848C:	bic	#FF00,r4
8490:	cmp	r0,r4
8492:	bgt	84B6
8494:	mov	r1,-(sp)
8496:	mov	r2,r1
8498:	mov	r0,-(sp)
849A:	mov	r4,r0
849C:	inc	r0
849E:	trap	0E		;IMUL
84A0:	add	(sp)+,r0
84A2:	mov	(sp)+,r1
84A4:	trap	58		;multiply r0 by 6
84A6:	mov	(sp)+,r3
84A8:	add	r3,r0
84AA:	tst	(r0)+
84AC:	rts	pc
84AE:	jsr	pc,84B8
84B2:	br	84A4
84B4:	trap	0B		;error 5 - incorrect index
84B6:	trap	0D		;error 6 - index out of range
84B8:	trap	20		;FIX
84BA:	bmi	84B6
84BC:	mov	@0002(sp),r4
84C0:	clrb	r4
84C2:	swab	r4
84C4:	cmp	r0,r4
84C6:	bgt	84B6
84C8:	rts	pc

; trap 04 - display the line number 0EF0
84CA:	sub	#8,sp
84CE:	mov	sp,r0		;buffer for the string on the stack
84D0:	mov	0EF0,r1
84D4:	trap	0A		;ITOA
84D6:	mov	sp,r0
84D8:	tst	(r0)+
84DA:	clrb	0007(sp)
84DE:	trap	36		;print a string pointed to by r0
84E0:	add	#8,sp
84E4:	rts	pc

; trap 58 - multiply r0 by 6
84E6:	clc
84E8:	asl	r0		;* 2
84EA:	mov	r0,-(sp)
84EC:	asl	r0		;* 4
84EE:	add	(sp)+,r0	;* 6
84F0:	rts	pc

; trap 5C - pointer to the beginning of the variable table
84F2:	mov	0EF6,r3
; align r3 to a word boundary
84F6:	inc	r3
84F8:	asr	r3
84FA:	clc
84FC:	asl	r3
84FE:	rts	pc

; trap 60 - get a pair of characters other than space to r4
8500:	trap	3A		;get a character other than space to r2
8502:	mov	r2,r4
8504:	swab	r4
8506:	trap	3A		;get a character other than space to r2
8508:	bis	r2,r4
850A:	rts	pc

; trap 62 - MOVSTK, push r4,r3,r2 on the stack
850C:	mov	r3,-(sp)
850E:	mov	r2,-(sp)
8510:	mov	0004(sp),-(sp)	;push the return address on the stack
8514:	mov	r4,0006(sp)
8518:	cmp	r5,sp
851A:	bhis	851E
851C:	rts	pc
851E:	trap	01		;error 0 - out of memory

; command LIST
8520:	inc	0D8E
8524:	clr	0D92
8528:	clr	0F40
852C:	trap	3A		;get a character other than space to r2
852E:	cmpb	r2,#2A
8532:	bne	853A
8534:	inc	0F40
8538:	br	8546
853A:	dec	r1
853C:	jsr	pc,EC00
8540:	tst	0D90
8544:	bne	8626
8546:	trap	4E
8548:	trap	46		;get a pair of integer numbers
854A:	mov	r3,r0		;first number
854C:	bne	85E4
854E:	mov	0EF2,r3
8552:	tst	r4		;second number
8554:	bne	85FC
8556:	mov	r5,r4
8558:	tst	0F00
855C:	bne	8626
855E:	movb	(r3)+,r2
8560:	nop
8562:	nop
8564:	bpl	8594
8566:	bic	#FF80,r2
856A:	mov	#8878,r0
856E:	mov	r2,r1
8570:	dec	r1
8572:	blt	857C
8574:	cmpb	(r0)+,#24
8578:	bne	8574
857A:	br	8570
857C:	movb	(r0)+,r2
857E:	cmpb	r2,#24
8582:	beq	8558
8584:	tst	0F40
8588:	beq	8590
858A:	cmpb	r2,#27
858E:	beq	857C
8590:	trap	00		;print character r2
8592:	br	857C
8594:	cmpb	r2,#A
8598:	beq	859E
859A:	trap	00		;print character r2
859C:	br	8558
859E:	trap	02		;print CR, LF
85A0:	tst	0EFE
85A4:	bne	85C0
85A6:	tst	0F20
85AA:	bne	85C0
85AC:	tst	0D92
85B0:	beq	85BC
85B2:	jsr	pc,BF3A		;wait for a key
85B6:	cmp	r2,#D
85BA:	bne	85B2
85BC:	inc	0D92
85C0:	cmp	r3,r4
85C2:	bhis	85D2
85C4:	tst	0F40
85C8:	beq	8558
85CA:	mov	r3,r1
85CC:	trap	08		;ATOI
85CE:	mov	r1,r3
85D0:	br	8558
85D2:	clr	0F20
85D6:	tst	0EFE
85DA:	beq	85E0
85DC:	jsr	pc,DBA4
85E0:	jmp	86D6
85E4:	mov	r4,-(sp)
85E6:	mov	r2,-(sp)
85E8:	trap	3C
85EA:	mov	(sp)+,r2
85EC:	mov	(sp)+,r4
85EE:	cmp	r1,r5
85F0:	bhi	854E
85F2:	tst	0F40
85F6:	beq	85FA
85F8:	dec	r1
85FA:	mov	r1,r3
85FC:	tst	r4
85FE:	bne	8606
8600:	cmp	#2C,r2
8604:	beq	8556
8606:	cmp	r4,r0
8608:	ble	8618
860A:	mov	r4,r0
860C:	mov	r3,-(sp)
860E:	trap	3C
8610:	bne	861E
8612:	mov	(sp)+,r3
8614:	cmp	r1,r5
8616:	bhi	8556
8618:	trap	42		;move the pointer r1 to the end of the line
861A:	mov	r1,r4
861C:	br	8558
861E:	mov	(sp)+,r3
8620:	cmp	r1,r5
8622:	bhi	8556
8624:	br	861A
8626:	jmp	86BE

; command DELETE
862A:	trap	4E
862C:	trap	46		;get a pair of integer numbers
862E:	mov	0EF2,r1
8632:	tst	r4
8634:	bne	8638
8636:	mov	r3,r4
8638:	mov	r4,-(sp)	;second number
863A:	mov	r3,-(sp)	;first number
863C:	trap	42		;move the pointer r1 to the end of the line
863E:	cmp	r1,r5
8640:	bhis	8656
8642:	mov	r1,-(sp)
8644:	trap	08		;ATOI
8646:	mov	(sp)+,r1
8648:	cmp	r0,(sp)
864A:	blt	863C
864C:	cmp	r0,0002(sp)
8650:	bgt	8656
8652:	trap	3E
8654:	br	863E
8656:	cmp	(sp)+,(sp)+
8658:	br	86DA
865A:	trap	4E
865C:	trap	3C
865E:	bne	8676
8660:	trap	3E
8662:	br	8676
8664:	jsr	pc,82BC		;get a character other than space
8668:	cmpb	#3A,r2
866C:	beq	8766
866E:	cmpb	#A,r2
8672:	beq	8676
8674:	trap	07		;error 3 - illegal character
8676:	bit	#10,0D5C
867C:	beq	8682
867E:	mov	(sp)+,r2
8680:	jmp	(r2)
8682:	tst	0EF4
8686:	beq	8706
8688:	tst	0EF6
868C:	beq	8694
868E:	cmp	r1,0EF6
8692:	br	8696
8694:	cmp	r1,r5
8696:	bhis	8788
8698:	tst	0F08
869C:	beq	86A2
869E:	jsr	pc,D23A
86A2:	jsr	pc,9662
86A6:	mov	r0,0EF0
86AA:	br	8766

; start the BASIC system
86AC:	jmp	9FCE

; command SYSTEM
86B0:	jmp	F600		;system restart

; command NEW
86B4:	mov	0EF2,r5
86B8:	inc	r5
86BA:	clr	0EF6
86BE:	mov	0D00,sp
86C2:	clr	0EFC
86C6:	clr	0F00
86CA:	clr	0EF0
86CE:	mov	#1,0CFC
86D4:	trap	02		;print CR, LF
86D6:	clr	0EFE
86DA:	clr	0EF4
86DE:	clr	0F20
86E2:	jsr	pc,AA96
86E6:	clr	0F38
86EA:	clr	0F1A
86EE:	clr	0D8E
86F2:	clr	0F0E
86F6:	mov	0C48,-(sp)
86FA:	mov	#8A1C,r0	;string 'Gotov' (Ready)
86FE:	trap	36		;print a string pointed to by r0
8700:	mov	(sp)+,0C48
8704:	trap	02		;print CR, LF
8706:	clr	0F00
870A:	tst	0D70
870E:	beq	871A
8710:	jsr	pc,A5F6
8714:	jsr	pc,81FC
8718:	br	871C
871A:	trap	40		;input a line from the keyboard
871C:	trap	3A		;get a character other than space to r2
871E:	cmp	r2,#A
8722:	beq	8706
8724:	mov	#E9E,r1		;input line buffer
8728:	trap	08		;ATOI
872A:	cmpb	(r1),#A
872E:	beq	865A
8730:	mov	r1,r3
8732:	jsr	pc,8A5E
8736:	blo	873A
8738:	br	879A
873A:	mov	#8878,r0
873E:	clr	r2
8740:	cmpb	(r3)+,#20
8744:	beq	8740
8746:	cmpb	-(r3),(r0)+
8748:	bne	8754
874A:	inc	r3
874C:	cmpb	(r0),#24
8750:	beq	8794
8752:	br	8740
8754:	cmpb	(r0)+,#24
8758:	bne	8754
875A:	cmpb	(r0),#24
875E:	beq	878C
8760:	mov	r1,r3
8762:	inc	r2
8764:	br	8740
8766:	tst	0F00
876A:	bne	86BE
876C:	jsr	pc,82BC		;get a character other than space
8770:	bpl	877E
8772:	dec	r1
8774:	jsr	pc,8A5E
8778:	blo	8792
877A:	jmp	8F72
877E:	bic	#FF80,r2
8782:	asl	r2
8784:	jmp	@89A6(r2)
8788:	jmp	8A3C
878C:	tst	0EFC
8790:	bne	879A
8792:	trap	03		;error 1 - unknown operator
8794:	add	#80,r2
8798:	movb	r2,(r1)+
879A:	mov	r1,r4
879C:	movb	(r3),(r1)+
879E:	cmpb	(r3)+,#A
87A2:	bne	879C
87A4:	cmpb	r2,#83
87A8:	beq	881A
87AA:	cmpb	r2,#A3
87AE:	beq	881A
87B0:	cmp	r2,#8D
87B4:	bne	87F0
87B6:	mov	r4,r1
87B8:	trap	3A		;get a character other than space to r2
87BA:	cmpb	r2,#54		;'T'
87BE:	bne	87E4
87C0:	trap	3A		;get a character other than space to r2
87C2:	cmpb	r2,#48		;'H'
87C6:	bne	87BA
87C8:	trap	3A		;get a character other than space to r2
87CA:	cmpb	r2,#45		;'E'
87CE:	bne	87BA
87D0:	trap	3A		;get a character other than space to r2
87D2:	cmpb	r2,#4E		;'N'
87D6:	bne	87BA
87D8:	trap	3A		;get a character other than space to r2
87DA:	dec	r1
87DC:	mov	r1,r4
87DE:	trap	38		;is r2 a digit?
87E0:	beq	87F0		;branch if r2 is a decimal digit
87E2:	br	8730
87E4:	cmpb	r2,#A
87E8:	beq	881A
87EA:	cmpb	r2,#3A
87EE:	bne	87B8
87F0:	mov	r4,r1
87F2:	cmpb	(r1),#22
87F6:	beq	8808
87F8:	cmpb	(r1)+,#3A
87FC:	beq	87D8
87FE:	cmpb	-(r1),#A
8802:	beq	8818
8804:	inc	r1
8806:	br	87F2
8808:	inc	r1
880A:	cmpb	(r1),#22
880E:	beq	8804
8810:	cmpb	(r1),#A
8814:	bne	8808
8816:	trap	33		;error 25 - mismatched quotation marks
8818:	inc	r1
881A:	mov	r1,r3
881C:	mov	#E9E,r1		;input line buffer
8820:	trap	3A		;get a character other than space to r2
8822:	trap	38		;is r2 a digit?
8824:	beq	882A		;branch if r2 is a decimal digit
8826:	dec	r1
8828:	br	8766
882A:	trap	4E
882C:	mov	#E9E,r1		;input line buffer
8830:	sub	r1,r3
8832:	mov	r3,-(sp)
8834:	trap	08		;ATOI
8836:	tst	r0
8838:	beq	8876
883A:	cmp	r0,#1FFF
883E:	bgt	8876
8840:	trap	3C
8842:	bne	8846
8844:	trap	3E
8846:	mov	(sp)+,r3
8848:	trap	4E
884A:	mov	r3,r0
884C:	trap	44		;check the available stack space
884E:	bhis	8856
8850:	trap	01		;error 0 - out of memory
8852:	add	r0,r5
8854:	br	8866
8856:	cmp	r1,r5
8858:	bhis	8852
885A:	mov	r5,r2
885C:	add	r0,r5
885E:	mov	r5,r4
8860:	movb	-(r2),-(r4)
8862:	cmp	r1,r2
8864:	blos	8860
8866:	mov	#E9E,r2		;input line buffer
886A:	movb	(r2),(r1)+
886C:	cmpb	(r2)+,#A
8870:	bne	886A
8872:	jmp	8676
8876:	trap	21		;error 16 - wrong line number or dimension

; keyword codes 80..BA
8878:	.ascii	'LIST$', 'LET$', 'READ$', 'REM$'
888A:	.ascii	'RUN$', 'RESTORE$', 'RETURN$', 'DATA$'
88A2:	.ascii	'DIM$', 'DELETE$', 'PRINT$', 'GOSUB$'
88B9:	.ascii	'GOTO$', 'IF$', 'FOR$', 'NEXT$'
88CA:	.ascii	'INPUT$', 'SAVE$', 'STOP$', 'END$'
88DE:	.ascii	'DEF$', 'LOAD$', 'RANDOMIZE$', 'INIT$'
88F6:	.ascii	'KILL$', 'DRAW$', 'DIS$', 'CLS$'
8908:	.ascii	'LOCATE$', 'WAIT$', 'PLAY$', 'AUTO$'
891E:	.ascii	'NAME$', 'FILES$', 27,'$', 'DEV$'
892F:	.ascii	'EDIT$', 'MEM$', 'BSAVE$', 'BLOAD$'
8944:	.ascii	'TRON$', 'TROFF$', 'CONT$', 'PATCH$'
895A:	.ascii	'RESUME$', 'ON$', 'RENUM$', 'NEW$'
896E:	.ascii	'SYSTEM$', 'CALL$', 'TIME$', 'DATE$'
8984:	.ascii	'OPEN$', 'PUT$', 'GET$', 'CLOSE$'
8996:	.ascii	'PAINT$', 'USR$', '@$'
89A4:	.byte	00
89A5:	.even

; addresses of corresponding procedures
89A6:	.word	8520, 8F72, 91B6, 900E
89AE:	.word	8AAA, 8B7E, 8B84, 900E
89B6:	.word	8BBC, 862A, 9052, 8B48
89BE:	.word	8B52, 8F9A, 9210, 92DC
89C6:	.word	90FE, DAC8, 8A32, 8A3C
89CE:	.word	8C1E, D952, 936E, DBB4
89D6:	.word	D924, AC00, A736, A798
89DE:	.word	A7A2, A62E, A668, A5C0
89E6:	.word	DA8A, DC56, 900E, DEFC
89EE:	.word	B09A, C3D4, F1D8, F27C
89F6:	.word	D224, D230, 8A7A, CA8A
89FE:	.word	8AC6, 8B1A, CC1E, 86B4
8A06:	.word	86B0, C922, C61C, C6F2
8A0E:	.word	ED10, F032, F02A, EF4A
8A16:	.word	CF28, C4A4, C546

8A1C:	0E 67 4F 54 4F 57 0F 00				  .gOTOW..
8A24:	00 0D 0A 00 FF FF FF FF FF FF FF 0A

; command STOP
8A32:	mov	0EF0,0F10
8A38:	mov	r1,0F12
; command END
8A3C:	tst	0F0E
8A40:	beq	8A4A
8A42:	tst	0F1A
8A46:	bne	8A4A
8A48:	trap	3F		;error 31 - wrong note in the PLAY operator
8A4A:	trap	02		;print CR, LF
8A4C:	mov	#8A9C,r0	;string 'ost v stroke' (stop in a line)
8A50:	trap	36		;print a string pointed to by r0
8A52:	trap	04		;display the line number 0EF0
8A54:	trap	02		;print CR, LF
8A56:	clr	0EF0
8A5A:	jmp	86DA
8A5E:	mov	r1,-(sp)
8A60:	trap	56		;get a variable name to r4
8A62:	bvs	8A76		;branch if name not found
8A64:	cmpb	r2,#28		;'('
8A68:	beq	8A70
8A6A:	cmpb	r2,#3D
8A6E:	bne	8A76
8A70:	clc
8A72:	mov	(sp)+,r1
8A74:	rts	pc
8A76:	sec
8A78:	br	8A72

; command CONT
8A7A:	mov	0F10,0EF0
8A80:	bne	8A86
8A82:	jmp	86DA
8A86:	mov	0EF0,r0
8A8A:	mov	0F12,r1
8A8E:	mov	#1,0EF4
8A94:	clr	0F10
8A98:	jmp	8664

8A90:	01 00 60 84  37 0A 78 84  77 00 C8 FB  4F 43 54 20  ..`.7.x.w.H{OCT 
8AA0:	42 20 43 54  50 4F 4B 45  20 00 4E 89  37 0A 40 84  B CTPOKE .N.7.@.

; command RUN
8AAA:	trap	4E
8AAC:	clr	0EF0
8AB0:	mov	0EF2,r1
8AB4:	inc	r1
8AB6:	mov	#1747,0CF8
8ABC:	mov	#1,0EF4
8AC2:	jmp	8676

; command RESUME
8AC6:	tst	0F0E
8ACA:	bne	8ACE
8ACC:	trap	41		;error 32 - wrong PLOT function
8ACE:	trap	3A		;get a character other than space to r2
8AD0:	inc	0F1A
8AD4:	dec	r1
8AD6:	trap	38		;is r2 a digit?
8AD8:	beq	8AF6		;branch if r2 is a decimal digit
8ADA:	trap	60		;get a pair of characters to r4
8ADC:	cmp	r4,#4E45	;"NE"
8AE0:	bne	8B18
8AE2:	trap	60		;get a pair of characters to r4
8AE4:	cmp	r4,#5854	;"XT"
8AE8:	bne	8B18
8AEA:	mov	0F0A,r0
8AEE:	trap	3C
8AF0:	bne	8B16
8AF2:	trap	42		;move the pointer r1 to the end of the line
8AF4:	br	8B04
8AF6:	trap	08		;ATOI
8AF8:	tst	r0
8AFA:	bne	8B00
8AFC:	mov	0F0A,r0
8B00:	trap	3C
8B02:	bne	8B16
8B04:	neg	0F0E
8B08:	tst	0D62
8B0C:	beq	8B12
8B0E:	jsr	pc,AA96
8B12:	jmp	8698
8B16:	trap	3D		;error 30 - wrong parameters
8B18:	trap	43		;error 33 - illegal use of the RENUM operator

; command ON
8B1A:	inc	0E80
8B1E:	trap	60		;get a pair of characters to r4
8B20:	cmp	r4,#4552	;"ER"
8B24:	bne	8B46
8B26:	trap	60		;get a pair of characters to r4
8B28:	cmp	r4,#524F	;"RO"
8B2C:	bne	8B46
8B2E:	trap	3A		;get a character other than space to r2
8B30:	cmp	r2,#52		;'R'
8B34:	bne	8B46
8B36:	trap	60		;get a pair of characters to r4
8B38:	cmp	r4,#474F	;"GO"
8B3C:	bne	8B46
8B3E:	trap	60		;get a pair of characters to r4
8B40:	cmp	r4,#544F	;"TO"
8B44:	beq	8B52
8B46:	trap	03		;error 1 - unknown operator

; command GOSUB
8B48:	mov	0EF0,r0
8B4C:	bis	#2000,r0
8B50:	trap	4A
; command GOTO
8B52:	trap	3A		;get a character other than space to r2
8B54:	dec	r1
8B56:	trap	5E		;evaluate an arithmetical expression
8B58:	trap	20		;FIX
8B5A:	tst	0E80
8B5E:	beq	8B6E
8B60:	clr	0E80
8B64:	mov	r0,0F0E
8B68:	trap	42		;move the pointer r1 to the end of the line
8B6A:	jmp	8698
8B6E:	trap	3C
8B70:	bne	8B7C
8B72:	mov	#1,0EF4
8B78:	jmp	8698
8B7C:	trap	05		;error 2 - illegal GOTO or GOSUB operator

; command RESTORE
8B7E:	clr	0EF8
8B82:	br	8C16

; command RETURN
8B84:	clr	-(sp)
8B86:	mov	#2000,r4
8B8A:	trap	5C		;r3 = pointer to the variable table
8B8C:	beq	8BBA
8B8E:	mov	#1FFF,r0
8B92:	trap	4C
8B94:	beq	8B9C
8B96:	mov	r3,(sp)
8B98:	tst	(r3)+
8B9A:	br	8B92
8B9C:	mov	(sp)+,r3
8B9E:	beq	8BBA
8BA0:	mov	(r3),r0
8BA2:	bic	r4,r0
8BA4:	inc	r0
8BA6:	mov	#2,r4
8BAA:	trap	50
8BAC:	cmp	r0,#1
8BB0:	bne	8BB6
8BB2:	jmp	8A56
8BB6:	trap	3C
8BB8:	br	8B72
8BBA:	trap	09		;error 4 - RETURN without GOSUB

; command DIM
8BBC:	trap	64		;search for a variable
8BBE:	bvs	8BEE		;error if invalid variable name
8BC0:	bne	8C1C		;error if the variable already exists
8BC2:	mov	r4,-(sp)	;encoded variable name
8BC4:	trap	3A		;get a character other than space to r2
8BC6:	cmp	r2,#28
8BCA:	bne	8BEE
8BCC:	trap	08		;ATOI
8BCE:	trap	54
8BD0:	bne	8BEE
8BD2:	mov	r0,-(sp)
8BD4:	swab	(sp)
8BD6:	trap	3A		;get a character other than space to r2
8BD8:	cmpb	r2,#2C
8BDC:	bne	8BE8
8BDE:	trap	08		;ATOI
8BE0:	trap	54
8BE2:	bne	8BEE
8BE4:	bis	r0,(sp)
8BE6:	trap	3A		;get a character other than space to r2
8BE8:	cmp	r2,#29
8BEC:	beq	8BF0
8BEE:	trap	1B		;error 13 - wrong size in the DIM operator
8BF0:	mov	(sp)+,r2
8BF2:	mov	(sp)+,r0
8BF4:	mov	r1,-(sp)
8BF6:	trap	4A
8BF8:	mov	r2,r0
8BFA:	trap	4A
8BFC:	mov	r2,r1
8BFE:	swab	r1
8C00:	trap	52
8C02:	bvs	8C1A
8C04:	trap	44		;check the available stack space
8C06:	blo	8C1A
8C08:	add	r0,r5
8C0A:	mov	(sp)+,r1
8C0C:	trap	3A		;get a character other than space to r2
8C0E:	cmp	r2,#2C
8C12:	beq	8BBC
8C14:	dec	r1
8C16:	jmp	8664
8C1A:	trap	1D		;error 14 - not enough memory for the array
8C1C:	trap	23		;error 17 - array of this name already defined

; command DEF
8C1E:	trap	60		;get a pair of characters to r4
8C20:	cmp	r4,#464E	;"FN"
8C24:	bne	8C5C
8C26:	trap	3A		;get a character other than space to r2
8C28:	trap	38		;is r2 a digit?
8C2A:	beq	8C5C		;branch if r2 is a decimal digit
8C2C:	bvs	8C5C
8C2E:	bis	#6000,r2
8C32:	mov	r2,r0
8C34:	trap	4A
8C36:	trap	3A		;get a character other than space to r2
8C38:	cmp	r2,#28
8C3C:	bne	8C5C
8C3E:	trap	56		;get a variable name to r4
8C40:	bvs	8C5C		;branch if name not found
8C42:	mov	r4,r0
8C44:	trap	4A
8C46:	cmp	r2,#29
8C4A:	bne	8C5C
8C4C:	trap	3A		;get a character other than space to r2
8C4E:	cmp	r2,#3D
8C52:	bne	8C5C
8C54:	mov	r1,r0
8C56:	trap	4A
8C58:	trap	48
8C5A:	br	8C16
8C5C:	trap	1F		;error 15 - wrong DEF syntax


; Original labels and comments copied from equivalent FOCAL-11 functions.

; trap 5E - EVAL, evaluate an arithmetical expression pointed to by r1.
; On exit r2,r3,r4 will contain the numeric value of the expression, r1 will
; contain the address where the scan failed. If the scan fails on any
; character other than a right parenthesis, r1 will point to the character
; where the failure occurred. If the scan ended on a right parenthesis, r1
; will point to the character following the prenthesis and the V bit will be
; set. If the V bit is set on any parameter other than the last or is cleared
; on the last parameter, a mismatching perenthesis error has occurred.
8C5E:	clr	r0
8C60:	trap	4A
8C62:	mov	#FFFF,-(sp)	;push null (-1) on the stack
; EVAL02:
8C66:	trap	44		;check the available stack space
8C68:	blo	8D4C
8C6A:	trap	3A		;get a character other than space to r2
8C6C:	cmp	r2,#2B		;is it a '+'?
8C70:	beq	8C82
8C72:	cmp	r2,#2D		;is it a '-'?
8C76:	bne	8C84
8C78:	mov	r2,r0		;set operand2 = 0
8C7A:	clr	r2
8C7C:	clr	r3
8C7E:	clr	r4
8C80:	br	8C92
; EVAL03:
8C82:	trap	3A		;get a character other than space to r2
; EVAL01
8C84:	cmp	r2,#28		;is it an opening parenthesis?
8C88:	bne	8C98		;no
8C8A:	clr	-(sp)		;push a zero on the stack
8C8C:	inc	FFFE(r5)	;increment the parentheses count
8C90:	br	8C66
; EVAL05:
8C92:	trap	62		;push operand r4,r3,r2 on the stack
8C94:	mov	r0,-(sp)	;push operator on the stack
8C96:	br	8C82
; EVAL04:
8C98:	dec	r1		;move the character pointer back one
8C9A:	mov	-(r5),-(sp)	;store the parentheses count
8C9C:	jsr	pc,8D62		;get an operand
8CA0:	mov	(sp)+,(r5)+	;restore the parentheses count
; EVAL12:
;
; GTOPR - get an operator to r0. Look for +,-,*,/,^, and ).
8CA2:	mov	r2,-(sp)	;save the character
8CA4:	trap	3A		;get a character other than space to r2
8CA6:	mov	#8D55,r0	;get address of list #EVAL07+7
; GTPR01:
8CAA:	cmpb	-(r0),r2	;is character a legal operator?
8CAC:	beq	8CBC		;yes
8CAE:	cmp	r0,#8D4F	;has search failed?
8CB2:	bhi	8CAA		;no
8CB4:	clr	r0		;yes, set r0=0 and backup
8CB6:	dec	r1		;pointer to point of failure
; GTPR03:
8CB8:	mov	(sp)+,r2	;restore the character
8CBA:	br	8CC0
; GTPR02:
8CBC:	mov	r2,r0		;put the character in r0
8CBE:	br	8CB8
; end of the GTOPR module
;
8CC0:	tst	(sp)		;is the stack null?
8CC2:	ble	8D22		;yes
; EVAL06:
8CC4:	mov	r1,-(sp)	;save the text pointer
8CC6:	mov	#8D55,r1	;get the table address #EVAL07+7
; EVAL08:
8CCA:	cmpb	-(r1),r0	;find the operator
8CCC:	bne	8CCA		;it must be found
8CCE:	asr	r1		;clear the low order bit
8CD0:	mov	r1,(r5)+
8CD2:	mov	#8D55,r1	;get the table address #EVAL07+7
; EVAL09:
8CD6:	cmpb	-(r1),0002(sp)	;find the operator
8CDA:	bne	8CD6		;it must be found
8CDC:	asr	r1		;clear the low order bit
8CDE:	mov	r1,(r5)+	;save it for now
8CE0:	mov	(sp)+,r1	;restore the text pointer
8CE2:	cmp	-(r5),-(r5)	;is priority of operator1 > operator2?
8CE4:	blt	8C92		;no
8CE6:	mov	r0,(r5)+	;yes, save operator2
8CE8:	mov	#8D55,r0	;get table address
; EVAL10:
8CEC:	cmpb	-(r0),(sp)	;find the operator
8CEE:	bne	8CEC		;it must be found
8CF0:	sub	#8D50,r0	;get the displacement, #EVAL07+2
8CF4:	asl	r0
8CF6:	add	#8D56,r0	;get routine address
8CFA:	mov	r0,(r5)+	;save it
8CFC:	tst	(sp)+		;discard old operator
8CFE:	mov	sp,r0		;get the destination address
8D00:	trap	62		;push the source r4,r3,r2 on the stack
8D02:	mov	r1,-(sp)	;save the text pointer
8D04:	mov	sp,r1
8D06:	tst	(r1)+		;get source address
8D08:	mov	-(r5),r2	;get routine address
8D0A:	mov	-(r5),-(sp)	;save operator2
8D0C:	jsr	pc,@0000(r2)	;go compute value
8D10:	mov	(sp)+,r0	;restore operator2
8D12:	mov	(sp)+,r1	;restore text pointer
8D14:	add	#6,sp		;discard source
8D18:	mov	(sp)+,r2	;place result in operand2
8D1A:	mov	(sp)+,r3
8D1C:	mov	(sp)+,r4
8D1E:	tst	(sp)		;is stack null?
8D20:	bgt	8CC4		;no, take care of the rest of the stack
; EVAL17:
8D22:	cmp	r0,#29		;is operator a closing parenthesis?
8D26:	beq	8D38		;yes
8D28:	tst	r0		;no, is it a null?
8D2A:	bgt	8C92		;no
8D2C:	tst	-(r5)		;yes, pop null
8D2E:	bne	8D36
8D30:	tst	(sp)+
8D32:	clear	cvzn
8D34:	rts	pc		;return with result in r2,r3,r4
; EVAL13:
8D36:	trap	0F		;error 7 - mismatched parentheses
; EVAL14:
8D38:	tst	-(r5)		;is parentheneses count zero?
8D3A:	bne	8D42		;no
; EVAL16:
8D3C:	tst	(sp)+		;pop null
8D3E:	set	v		;error
8D40:	rts	pc
; EVAL15:
8D42:	tst	(sp)
8D44:	blt	8D3C		;jump if stack = -1
8D46:	tst	(sp)+		;pop null off stack
8D48:	dec	(r5)+		;decrease the parenteneses count by one
8D4A:	br	8CA2

8D4C:	trap	01		;error 0 - out of memory

; EVAL07:
8D4E:	.byte	00, 29			;closing parenthesis
8D50:	.byte	2B, 2D, 2A, 2F, 5E	;arithmetical operators +-*/^
8D55:	.even
; EVAL11:
8D56:	.word	97D0, 9864, 9940, 98AA, 9AD0	;corresponding procedures

; GETOP - get an operand.
; Upon entry r1 points to the start of an operand.
; Upon exit r2,r3,r4 contain the value of the operand.
8D62:	mov	r1,-(sp)	;save the text pointer
8D64:	trap	3A		;get a character other than space to r2
8D66:	trap	38		;is r2 a digit?
8D68:	bvs	8D88		;the character is a terminator
8D6A:	bne	8D90		;branch if r2 is not a decimal digit
; GTP18:
; the character is a numeric
8D6C:	mov	(sp)+,r1	;restore the text pointer
8D6E:	sub	#6,sp		;reserve space for the number
8D72:	mov	sp,r0		;move address for the number to r0
8D74:	trap	06		;ATOF
8D76:	bvs	8D60
8D78:	mov	(sp)+,r2	;place the number in r2,r3,r4
8D7A:	mov	(sp)+,r3
8D7C:	mov	(sp)+,r4
8D7E:	rts	pc
;
8D80:	mov	(r0)+,r2
8D82:	mov	(r0)+,r3
8D84:	mov	(r0)+,r4
8D86:	rts	pc
;
; GTP15:
; the character is a terminator
8D88:	cmp	r2,#2E		;does the number begin with a decimal point?
8D8C:	beq	8D6C		;yes
8D8E:	br	8E62		;no
;
8D90:	cmp	r2,#46		;'F'
8D94:	beq	8E64
8D96:	mov	#FFC0,-(sp)
8D9A:	bic	(sp),r2
8D9C:	mov	r2,r0
8D9E:	trap	58		;multiply r0 by 6
8DA0:	trap	58		;multiply r0 by 6
8DA2:	trap	3A		;get a character other than space to r2
8DA4:	trap	38		;is r2 a digit?
8DA6:	bvs	8E60
8DA8:	beq	8E60
8DAA:	bic	(sp),r2
8DAC:	add	r2,r0
8DAE:	trap	58		;multiply r0 by 6
8DB0:	trap	58		;multiply r0 by 6
8DB2:	cmp	r0,#5244	;encoded keyword "PI"
8DB6:	bne	8DC8
; function PI
8DB8:	mov	#9E2E,r0	;PI/2
8DBC:	mov	(r0)+,r2
8DBE:	mov	(r0)+,r3
8DC0:	mov	(r0)+,r4
8DC2:	inc	r4		;r2-r4 <- PI
8DC4:	tst	(sp)+
8DC6:	br	8D3C
8DC8:	trap	3A		;get a character other than space to r2
8DCA:	trap	38		;is r2 a digit?
8DCC:	bvs	8E60
8DCE:	beq	8E60
8DD0:	bic	(sp)+,r2
8DD2:	add	r2,r0
8DD4:	cmp	r0,#2F8B	;encoded keyword "INC"
8DD8:	bne	8DDC
8DDA:	br	8E38		;function INC
8DDC:	cmp	r0,#1BEA	;encoded keyword "ERR"
8DE0:	bne	8DE8
; function ERR
8DE2:	mov	0F0C,r3
8DE6:	br	8DEE
8DE8:	cmp	r0,#1BE4	;encoded keyword "ERL"
8DEC:	bne	8DF6
; function ERL
8DEE:	clr	r2
8DF0:	mov	#800F,r4
8DF4:	br	8D3C

8DF6:	mov	#8F16,r3
8DFA:	cmp	(r3)+,r0
8DFC:	beq	8E06
8DFE:	cmp	r3,#8F2C
8E02:	blo	8DFA
8E04:	br	8EFA
8E06:	trap	3A		;get a character other than space to r2
8E08:	cmp	r2,#28
8E0C:	bne	8EFA
8E0E:	mov	0014(r3),-(sp)
8E12:	trap	5E		;evaluate an arithmetical expression
8E14:	bvc	8E9E
8E16:	mov	(sp)+,r0
8E18:	trap	62		;push r4,r3,r2 on the stack
8E1A:	mov	r0,r2
8E1C:	mov	sp,r0
8E1E:	mov	r1,-(sp)
8E20:	mov	r0,r1
8E22:	sub	#6,sp
8E26:	mov	sp,r0
8E28:	jsr	pc,(r2)
8E2A:	mov	(sp)+,r2
8E2C:	mov	(sp)+,r3
8E2E:	mov	(sp)+,r4
8E30:	mov	(sp)+,r1
8E32:	add	#8,sp
8E36:	rts	pc

; function INC
8E38:	cmpb	#DF,0D86	;key FK ?
8E3E:	bne	8E44
8E40:	clr	0D86
8E44:	mov	r1,-(sp)
8E46:	jsr	pc,BF50		;get the ASCII code of the pressed key in r2
8E4A:	sub	#6,sp
8E4E:	mov	sp,r0
8E50:	mov	r2,r1
8E52:	trap	1E		;FLT, convert integer R1 to float
8E54:	mov	(sp)+,r2
8E56:	mov	(sp)+,r3
8E58:	mov	(sp)+,r4
8E5A:	mov	(sp)+,r1
8E5C:	jmp	8D3C

8E60:	tst	(sp)+
8E62:	br	8EFA
8E64:	trap	3A		;get a character other than space to r2
8E66:	cmp	r2,#4E		;'N'
8E6A:	bne	8EFA
8E6C:	trap	3A		;get a character other than space to r2
8E6E:	trap	38		;is r2 a digit?
8E70:	bvs	8EFA
8E72:	beq	8EFA
8E74:	trap	5C		;r3 = pointer to the variable table
8E76:	beq	8F06
8E78:	clr	r0
8E7A:	bis	#6000,r2
8E7E:	mov	r2,r4
8E80:	trap	4C
8E82:	beq	8EFA
8E84:	tst	(r3)+
8E86:	mov	(r3)+,r4
8E88:	mov	(r3)+,-(sp)
8E8A:	trap	5C		;r3 = pointer to the variable table
8E8C:	trap	4C
8E8E:	bne	8EBE
8E90:	trap	3A		;get a character other than space to r2
8E92:	cmp	r2,#28
8E96:	bne	8E60
8E98:	mov	r4,-(sp)
8E9A:	trap	5E		;evaluate an arithmetical expression
8E9C:	bvs	8EA0
8E9E:	trap	0F		;error 7 - mismatched parentheses
8EA0:	mov	(sp)+,r0
8EA2:	mov	r5,-(sp)
8EA4:	trap	4A
8EA6:	clr	r0
8EA8:	trap	4A
8EAA:	trap	68
8EAC:	mov	r1,-(sp)
8EAE:	mov	0004(sp),r1
8EB2:	trap	5E		;evaluate an arithmetical expression
8EB4:	bvs	8E9E
8EB6:	mov	(sp)+,r1
8EB8:	mov	(sp)+,r5
8EBA:	cmp	(sp)+,(sp)+
8EBC:	rts	pc
8EBE:	cmp	(r3)+,(r3)+
8EC0:	mov	(sp)+,r0
8EC2:	mov	(r3)+,-(sp)
8EC4:	mov	(r3)+,-(sp)
8EC6:	mov	(r3)+,-(sp)
8EC8:	mov	r3,-(sp)
8ECA:	mov	r0,-(sp)
8ECC:	trap	3A		;get a character other than space to r2
8ECE:	cmp	r2,#28
8ED2:	bne	8F10
8ED4:	trap	5E		;evaluate an arithmetical expression
8ED6:	bvc	8E9E
8ED8:	mov	r1,r0
8EDA:	mov	0002(sp),r1
8EDE:	mov	r4,-(r1)
8EE0:	mov	r3,-(r1)
8EE2:	mov	r2,-(r1)
8EE4:	mov	(sp)+,r1
8EE6:	mov	r0,-(sp)
8EE8:	trap	5E		;evaluate an arithmetical expression
8EEA:	bvs	8E9E
8EEC:	mov	(sp)+,r1
8EEE:	mov	(sp)+,r0
8EF0:	mov	(sp)+,-(r0)
8EF2:	mov	(sp)+,-(r0)
8EF4:	mov	(sp)+,-(r0)
8EF6:	tst	(sp)+
8EF8:	rts	pc
8EFA:	mov	(sp)+,r1
8EFC:	trap	64
8EFE:	bvs	8F06
8F00:	beq	8F06
8F02:	jmp	8D80
8F06:	trap	F7		;error 123 - variable doesn't exist
8F08:	clr	r2
8F0A:	clr	r3
8F0C:	clr	r4
8F0E:	rts	pc
8F10:	add	#A,sp
8F14:	br	8EFA

; keywords stored in a format similar to Radix-50, but with a subset of 36
; characters instead of 40
8F16:	.word	6182, 115F, 07EE, 1CC0	;SIN, COS, ATN, EXP
8F1E:	.word	3EE3, 056B, 62A6, 2F9C	;LOG, ABS, SQR, INT
8F26:	.word	5D1C, 613A, 0000	;RND, SGN

; addresses of corresponding procedures
8F2C:	.word	9D94, 9DF6, 9E3A, 9C34
8F34:	.word	9B78, 987A, 9F2C, 9A3C
8F3C:	.word	934A, 9894, 0000

; trap 64 - search for a variable of a name pointed to by r1
; returned values:
; r0 - pointer to the value
; r1 - pointer to the parsed string
; r2 - first unprocessed character other than space
; r4 - encoded variable name: letter in bits 11-6, digit in bits 5-0
; V flag set if invalid variable name
; Z flag set if the variable doesn't exist
8F42:	trap	56		;get a variable name to r4
8F44:	bvs	8F6A		;return with V set if name not found
8F46:	dec	r1
8F48:	clr	r0
8F4A:	trap	5C		;r3 = pointer to the variable table
8F4C:	beq	8F68
8F4E:	trap	4C
8F50:	beq	8F68
8F52:	cmp	(sp),#8BBE
8F56:	beq	8F6E
8F58:	tst	(r3)+
8F5A:	cmpb	(r1),#28	;'('
8F5E:	bne	8F6C
8F60:	inc	r1
8F62:	mov	r4,-(sp)
8F64:	trap	5A
8F66:	mov	(sp)+,r4
8F68:	tst	r0
8F6A:	rts	pc
8F6C:	tst	(r3)+
8F6E:	mov	r3,r0
8F70:	rts	pc

; command LET
8F72:	trap	64		;search for a variable
8F74:	bvs	8F96		;invalid variable name
8F76:	bne	8F7C		;skip if variable already exists
8F78:	mov	r4,r0		;encoded variable name
8F7A:	trap	66		;create the variable
8F7C:	mov	r0,-(sp)
8F7E:	trap	3A		;get a character other than space to r2
8F80:	cmp	r2,#3D		;'='
8F84:	bne	8F96
8F86:	trap	5E		;evaluate an arithmetical expression
8F88:	bvs	8F98
8F8A:	mov	(sp)+,r0
8F8C:	mov	r2,(r0)+
8F8E:	mov	r3,(r0)+
8F90:	mov	r4,(r0)+
8F92:	jmp	8664
8F96:	trap	11		;error 8 - illegal LET operator
8F98:	trap	0F		;error 7 - mismatched quotation marks

; command IF
8F9A:	trap	5E		;evaluate an arithmetical expression
8F9C:	bvs	8F98
8F9E:	trap	62		;push r4,r3,r2 on the stack
8FA0:	trap	60		;get a pair of characters to r4
8FA2:	cmp	r2,#3E
8FA6:	beq	8FB2
8FA8:	cmp	r2,#3D
8FAC:	beq	8FB2
8FAE:	dec	r1
8FB0:	clrb	r4
8FB2:	mov	#8FE2,r2
8FB6:	cmp	r4,(r2)+
8FB8:	beq	8FC2
8FBA:	cmp	r2,#8FEE
8FBE:	blo	8FB6
8FC0:	trap	13		;error 9 - illegal relation operator
8FC2:	sub	#8FE4,r2
8FC6:	asl	r2
8FC8:	add	#8FEE,r2
8FCC:	mov	r2,-(sp)
8FCE:	trap	5E		;evaluate an arithmetical expression
8FD0:	bvs	8F98
8FD2:	mov	r1,-(sp)
8FD4:	mov	sp,r1
8FD6:	cmp	(r1)+,(r1)+
8FD8:	trap	62		;push r4,r3,r2 on the stack
8FDA:	mov	sp,r0
8FDC:	trap	1C		;CMPF
8FDE:	jmp	@0008(sp)

8FE2:	3E 3C 3D 3C  00 3C 3D 3E  00 3E 00 3D	><=<.<=>.>.=

8FEE:	bne	9016
8FF0:	br	9004
8FF2:	ble	9016
8FF4:	br	9004
8FF6:	blt	9016
8FF8:	br	9004
8FFA:	bge	9016
8FFC:	br	9004
8FFE:	bgt	9016
9000:	br	9004
9002:	beq	9016
9004:	add	#6,sp
9008:	mov	(sp)+,r1
900A:	add	#8,sp
;
; commands REM, DATA
900E:	trap	42		;move the pointer r1 to the end of the line
9010:	dec	r1
9012:	jmp	8664
9016:	add	#6,sp
901A:	mov	(sp)+,r1
901C:	add	#8,sp
9020:	trap	60		;get a pair of characters to r4
9022:	cmp	r4,#5448	;"TH"
9026:	bne	9042
9028:	trap	60		;get a pair of characters to r4
902A:	cmp	r4,#454E	;"EN"
902E:	bne	9050
9030:	trap	3A		;get a character other than space to r2
9032:	dec	r1
9034:	trap	38		;is r2 a digit?
9036:	bvs	903E
9038:	bne	9050
903A:	jmp	8B52
903E:	jmp	8766
9042:	cmp	r4,#474F	;"GO"
9046:	bne	9050
9048:	trap	60		;get a pair of characters to r4
904A:	cmp	r4,#544F	;"TO"
904E:	beq	903A
9050:	trap	15		;error 10 - illegal IF operator

; command PRINT
9052:	clr	-(sp)
9054:	mov	#1C,r0
9058:	trap	44		;check the available stack space
905A:	blo	90FC
905C:	trap	3A		;get a character other than space to r2
905E:	cmpb	r2,#3C
9062:	bne	906A
9064:	jsr	pc,A908
9068:	br	905C
906A:	cmpb	r2,#2C
906E:	beq	90A8
9070:	cmpb	r2,#3B
9074:	beq	90CA
9076:	cmpb	r2,#22
907A:	beq	90D2
907C:	cmpb	r2,#3A
9080:	beq	90E8
9082:	cmpb	r2,#A
9086:	beq	90E8
9088:	tst	(sp)
908A:	blt	90D0
908C:	dec	r1
908E:	trap	5E		;evaluate an arithmetical expression
9090:	bvs	90D0
9092:	mov	r1,-(sp)
9094:	jsr	pc,9510		;floating point to ASCII conversion
9098:	mov	sp,r0		;pointer to the output string
909A:	trap	36		;print a string pointed to by r0
909C:	add	#14,sp
90A0:	mov	(sp)+,r1
90A2:	mov	#FFFF,(sp)
90A6:	br	9054
90A8:	mov	0EFA,r0
90AC:	cmp	r0,#38
90B0:	blt	90B6
90B2:	trap	02		;print CR, LF
90B4:	br	90CA
90B6:	neg	r0
90B8:	bgt	90C0
90BA:	add	#E,r0
90BE:	br	90B8
90C0:	movb	#20,r2
90C4:	trap	00		;print character r2
90C6:	dec	r0
90C8:	bgt	90C4
90CA:	mov	#1,(sp)
90CE:	br	9054
90D0:	trap	17		;error 11 - illegal PRINT operator
90D2:	movb	(r1)+,r2
90D4:	trap	00		;print character r2
90D6:	cmpb	(r1),#A
90DA:	beq	90D0
90DC:	cmpb	(r1),#22
90E0:	bne	90D2
90E2:	inc	r1
90E4:	clr	(sp)
90E6:	br	9054
90E8:	tst	(sp)+
90EA:	bgt	90EE
90EC:	trap	02		;print CR, LF
90EE:	jsr	pc,AA96
90F2:	dec	r1
90F4:	clr	0F20
90F8:	jmp	8664
90FC:	trap	01		;error 0 - out of memory

; command INPUT
90FE:	clr	-(sp)
9100:	jsr	pc,9184
9104:	bvc	9108
9106:	trap	25		;error 12 - input line too long (more than 80
				;characters)
9108:	clr	-(sp)
910A:	mov	r1,-(sp)
910C:	mov	#3F,r2
9110:	trap	00		;print character r2
9112:	trap	40		;input a line from the keyboard
9114:	jsr	pc,9142
9118:	bvs	913E
911A:	bgt	9136
911C:	blt	913A
911E:	mov	(sp)+,r1
9120:	tst	(sp)+
9122:	tst	(sp)+
9124:	bne	9122
9126:	dec	r1
9128:	tst	0EF4
912C:	bne	9132
912E:	movb	#A,(r1)
9132:	jmp	8664
9136:	trap	F5		;error 122 - too much data entered
9138:	br	910C
913A:	trap	F3		;error 121 - not enough data entered
913C:	br	910C
913E:	trap	F1		;error 120 - illegal characters entered
9140:	br	910C
9142:	mov	sp,r4
9144:	cmp	(r4)+,(r4)+
9146:	tst	(r4)+
9148:	tst	(r4)+
914A:	bne	9148
914C:	tst	-(r4)
914E:	mov	-(r4),r0
9150:	beq	917C
9152:	mov	r4,-(sp)
9154:	trap	06		;ATOF
9156:	bvs	9180
9158:	mov	(sp)+,r4
915A:	cmpb	(r1),#2C
915E:	beq	9170
9160:	cmpb	(r1),#3A
9164:	beq	9174
9166:	cmpb	(r1),#A
916A:	beq	9174
916C:	set	v
916E:	rts	pc
9170:	inc	r1
9172:	br	914E
9174:	mov	-(r4),r0
9176:	beq	916E
9178:	set	n
917A:	rts	pc
917C:	clear	cvzn
917E:	rts	pc
9180:	tst	(sp)+
9182:	br	916C
9184:	trap	64
9186:	bvs	91B0
9188:	bne	918E
918A:	mov	r4,r0
918C:	trap	66
918E:	mov	(sp)+,r2
9190:	mov	r0,-(sp)
9192:	mov	#4,r0
9196:	trap	44		;check the available stack space
9198:	blo	91B4
919A:	mov	r2,-(sp)
919C:	trap	3A		;get a character other than space to r2
919E:	cmpb	r2,#2C
91A2:	beq	9184
91A4:	cmpb	r2,#3A
91A8:	beq	91B2
91AA:	cmpb	r2,#A
91AE:	beq	91B2
91B0:	set	v
91B2:	rts	pc
91B4:	trap	01		;error 0 - out of memory

; command READ
91B6:	mov	#1,-(sp)
91BA:	clr	-(sp)
91BC:	jsr	pc,9184
91C0:	bvc	91C4
91C2:	trap	27		;error 19 - wrong variable in the READ operator
91C4:	clr	-(sp)
91C6:	mov	r1,-(sp)
91C8:	mov	0EF8,r1
91CC:	bne	91D4
91CE:	mov	0EF2,r1
91D2:	br	9200
91D4:	cmpb	(r1),#A
91D8:	beq	9200
91DA:	jsr	pc,9142
91DE:	bvs	920E
91E0:	blt	91F8
91E2:	mov	r1,0EF8
91E6:	mov	(sp)+,r1
91E8:	tst	(sp)+
91EA:	tst	(sp)+
91EC:	bne	91EA
91EE:	tst	(sp)+
91F0:	beq	91EE
91F2:	dec	r1
91F4:	jmp	8664
91F8:	tst	(r4)+
91FA:	clr	(r4)+
91FC:	tst	(r4)
91FE:	bne	91FA
9200:	trap	5C		;r3 = pointer to the variable table
9202:	cmpb	#87,(r1)+
9206:	beq	91D4
9208:	cmp	r1,r3
920A:	blo	9202
920C:	trap	29		;error 20 - not enough DATA to READ
920E:	trap	2B		;error 21 - wrong DATA format

; command FOR
9210:	trap	56		;get a variable name to r4
; missing test whether a variable name was found ???
9212:	cmp	r2,#3D		;'='
9216:	bne	92B4
9218:	clr	r0
921A:	mov	r4,-(sp)
921C:	trap	5C		;r3 = pointer to the variable table
921E:	trap	4C
9220:	bne	9228
9222:	mov	r4,r0
9224:	trap	66
9226:	br	922C
9228:	mov	r3,r0
922A:	cmp	(r0)+,(r0)+
922C:	mov	r0,-(sp)
922E:	clr	r0
9230:	trap	5C		;r3 = pointer to the variable table
9232:	bis	#4000,r4
9236:	trap	4C
9238:	beq	9248
923A:	mov	r4,-(sp)
923C:	mov	r1,-(sp)
923E:	mov	#10,r4
9242:	trap	50
9244:	mov	(sp)+,r1
9246:	mov	(sp)+,r4
9248:	mov	r4,r0
924A:	trap	4A
924C:	mov	r1,r0
924E:	trap	4A
9250:	trap	5E		;evaluate an arithmetical expression
9252:	mov	(sp),r0
9254:	mov	r2,(r0)+
9256:	mov	r3,(r0)+
9258:	mov	r4,(r0)+
925A:	trap	60		;get a pair of characters to r4
925C:	cmp	r4,#544F	;"TO"
9260:	bne	92B4
9262:	trap	5E		;evaluate an arithmetical expression
9264:	trap	68
9266:	cmpb	(r1),#53
926A:	bne	9282
926C:	trap	60		;get a pair of characters to r4
926E:	cmp	r4,#5354	;"ST"
9272:	bne	92B4
9274:	trap	60		;get a pair of characters to r4
9276:	cmp	r4,#4550	;"EP"
927A:	bne	92B4
927C:	trap	5E		;evaluate an arithmetical expression
927E:	trap	68
9280:	br	928E
9282:	clr	r2
9284:	mov	#4000,r3
9288:	mov	#8001,r4
928C:	br	927E
928E:	mov	(sp),r0
9290:	mov	r1,-(sp)
9292:	mov	r5,r1
9294:	sub	#C,r1
9298:	mov	r1,-(sp)
929A:	trap	1C		;CMPF
929C:	beq	92AA
929E:	blt	92B6
92A0:	mov	(sp)+,r1
92A2:	tst	0008(r1)
92A6:	blt	92BE
92A8:	br	92AC
92AA:	tst	(sp)+
92AC:	mov	(sp)+,r1
92AE:	cmp	(sp)+,(sp)+
92B0:	jmp	8664
92B4:	trap	2D		;error 22 - illegal FOR operator
92B6:	mov	(sp)+,r1
92B8:	tst	0008(r1)
92BC:	blt	92AC
92BE:	mov	(sp)+,r1
92C0:	tst	(sp)+
92C2:	trap	5C		;r3 = pointer to the variable table
92C4:	cmpb	(r1)+,#8F
92C8:	beq	92D0
92CA:	cmp	r1,r3
92CC:	blo	92C4
92CE:	trap	2F		;error 23 - FOR without NEXT
92D0:	trap	56		;get a variable name to r4
92D2:	cmp	r4,(sp)
92D4:	bne	92C4
92D6:	tst	(sp)+
92D8:	dec	r1
92DA:	br	92B0

; command NEXT
92DC:	clr	r0
92DE:	trap	56		;get a variable name to r4
92E0:	mov	r4,-(sp)
92E2:	trap	5C		;r3 = pointer to the variable table
92E4:	trap	4C
92E6:	beq	9334
92E8:	mov	r3,-(sp)
92EA:	bis	#4000,r4
92EE:	trap	5C		;r3 = pointer to the variable table
92F0:	trap	4C
92F2:	beq	9334
92F4:	mov	r1,-(sp)
92F6:	cmp	(r3)+,(r3)+
92F8:	mov	r3,r1
92FA:	add	#6,r1
92FE:	mov	0002(sp),r0
9302:	mov	r3,-(sp)
9304:	cmp	(r0)+,(r0)+
9306:	mov	r0,-(sp)
9308:	trap	10		;ADDF
930A:	mov	(sp)+,r0
930C:	mov	(sp),r3
930E:	mov	r3,r1
9310:	tst	0008(r3)
9314:	bpl	931C
9316:	trap	1C		;CMPF
9318:	bgt	9336
931A:	br	9320
931C:	trap	1C		;CMPF
931E:	blt	9336
9320:	mov	(sp),r0
9322:	mov	-(r0),r1
9324:	trap	48
9326:	mov	r1,r4
9328:	mov	(sp)+,r1
932A:	tst	(sp)+
932C:	mov	(sp),r0
932E:	mov	r4,-(sp)
9330:	cmp	(r0)+,(r0)+
9332:	br	9298
9334:	trap	31		;error 24 - NEXT without FOR
9336:	mov	(sp)+,r1
9338:	add	#6,r1
933C:	mov	0002(sp),r0
9340:	cmp	(r0)+,(r0)+
9342:	trap	12		;SUBF
9344:	mov	(sp)+,r1
9346:	cmp	(sp)+,(sp)+
9348:	br	92D8

; function RND
934A:	mov	r0,-(sp)
934C:	mov	0CF8,r0
9350:	mov	0CFA,r1
9354:	trap	0E		;IMUL
9356:	bic	#8000,r0
935A:	mov	r0,0CF8
935E:	mov	r0,r1
9360:	mov	(sp),r0
9362:	trap	1E		;FLT, convert integer R1 to float
9364:	mov	(sp)+,r0
9366:	sub	#F,0004(r0)
936C:	rts	pc

; command RANDOMIZE
936E:	mov	0CFE,0CF8
9374:	bis	#1,0CF8
937A:	jmp	8664


; The binary <-> ASCII number conversion routines are apparently based on the
; floating point library of the RT-11 operating system. The original labels
; and comments are preserved.

; trap 06 - ATOF (documented), conversion of an ASCII string to a FP number
; on entry r1 points to the string
; on exit r1 points to the first invalid character,
; result (3 words) stored at memory location pointed to by r0
;
; bit 0 - switch S
; bit 1 - switch V, set if an overflow occurred
; bit 2 - switch E, set if character 'E' encountered
; bit 3 - switch D, set if a decimal point encountered
; bit 4 - switch A
; bit 5 - switch B
; bit 6 - set if negative number
; bit 7 - set if negative exponent
; bit 8 - switch M
937E:	mov	r5,-(sp)
9380:	mov	r0,-(sp)
9382:	clr	(r0)+
9384:	clr	(r0)+
9386:	clr	(r0)
9388:	clr	-(sp)
938A:	clr	-(sp)
938C:	clr	-(sp)		;clear the switches
; M.AFXN:
938E:	trap	3A		;get a character other than space to r2
9390:	cmpb	#45,r2		;'E'
9394:	beq	940E
9396:	cmpb	#2D,r2		;'-'
939A:	beq	9430
939C:	cmpb	#2B,r2		;'+'
93A0:	beq	942A
93A2:	cmpb	#2E,r2		;decimal point
93A6:	beq	941E
93A8:	trap	38		;is r2 a digit?
93AA:	bne	9456		;branch if r2 is not a decimal digit
93AC:	sub	#30,r2		;convert the digit to binary
93B0:	mov	r1,-(sp)
93B2:	bit	#0004,0002(sp)	;test the E switch
93B8:	bne	93F0		;branch if collecting exponent
93BA:	sub	#6,sp
93BE:	mov	sp,r0
93C0:	mov	r2,r1
93C2:	trap	1E		;FLT, convert integer R1 to float
93C4:	mov	000E(sp),r0
93C8:	mov	#94F2,r1	;floating point constant 10
93CC:	trap	18		;MULF, multiply by 10
93CE:	bvs	947C
93D0:	mov	000E(sp),r0
93D4:	mov	sp,r1
93D6:	trap	10		;ADDF, add current digit
93D8:	bit	#0008,0008(sp)	;test the D switch
93DE:	beq	93E4		;if 0, don't touch EXP2
93E0:	dec	000A(sp)	;decrement EXP2
93E4:	add	#6,sp
; M.AFSS:
93E8:	mov	(sp)+,r1	;get digit SEFA
93EA:	bis	#0001,(sp)	;set the S switch
93EE:	br	9458		;go get another digit
; M.AFXP
93F0:	mov	r2,-(sp)
93F2:	mov	0008(sp),r3
93F6:	mov	#A,r5
93FA:	clr	r2
93FC:	clr	r4
93FE:	cmp	r3,#03D4	;check for large exponent
9402:	bgt	9484
9404:	trap	32		;unsigned 32-bit integer multiplication
9406:	add	(sp)+,r3
9408:	mov	r3,0006(sp)	;save EXP1 back on stack
940C:	br	93E8		;set the S switch
; M.AFE:
940E:	bit	#0004,(sp)	;first E?
9412:	bne	9476		;no error
9414:	bis	#0004,(sp)	;set the E switch
9418:	bic	#0001,(sp)	;have a fraction?
941C:	br	9458		;get next character
; M.AFD:
941E:	bit	#000C,(sp)	;test the E and D switches
9422:	bne	9476		;either one is an error
9424:	bis	#0008,(sp)	;set the D switch
9428:	br	9458		;get next character
; M.AFPL:
942A:	bic	#0100,(sp)	;clear the M switch
942E:	br	9432
; M.AFMI:
9430:	bis	#0100,(sp)	;set the M switch
9434:	bit	#0004,(sp)	;test the E switch
9438:	bne	945A		;branch if sign of exponent
943A:	bit	#0001,(sp)	;test the S switch
943E:	bne	9456
9440:	bit	#0018,(sp)	;test the A and D switches
9444:	bne	9476		;error if any set
9446:	bis	#0010,(sp)	;set the A switch
944A:	bit	#0100,(sp)	;test the M switch
944E:	beq	9458		;exit if plus
9450:	bis	#0040,(sp)	;set minus sign
9454:	br	9458		;PDP-11 branches don't reach more than 128...
9456:	br	9488
; M.AFXN:
9458:	br	938E
; M.AFSE:
945A:	bit	#0001,(sp)	;test the S switch
945E:	bne	9456
9460:	bit	(sp),#0020	;test the B switch
9464:	bne	9476
9466:	bis	#0020,(sp)	;set the B switch
946A:	bit	#0100,(sp)	;test the M switch
946E:	beq	9458		;exit if plus
9470:	bis	#0080,(sp)	;negative exponent
9474:	br	9458
; M.AFVS:
9476:	bis	#0002,(sp)	;set the V switch
947A:	br	9456
947C:	add	#8,sp
9480:	mov	(sp)+,r1
9482:	br	9476
; M.AFVU:
9484:	cmp	(sp)+,(sp)+
9486:	br	9476
; M.AFX6:
9488:	mov	r1,-(sp)
948A:	bit	#0040,0002(sp)
9490:	beq	949A		;number not negative
9492:	mov	0008(sp),r0
9496:	mov	r0,r1
9498:	trap	14		;NEGF
; M.AFX2:
949A:	bit	#0080,0002(sp)	;negative exponent?
94A0:	beq	94B0		;branch if not
94A2:	neg	0006(sp)
94A6:	bvc	94B0		;branch if exponent valid
94A8:	bis	#0002,0002(sp)	;invalid exponent, set the V switch
94AE:	br	94DC
; M.AFX3:
94B0:	add	0004(sp),0006(sp)
94B6:	beq	94DC		;branch if EXP1+EXP2=0
94B8:	blt	94CC		;if less than 0 divide
94BA:	mov	0008(sp),r0
94BE:	mov	#94F2,r1	;floating point constant 10
94C2:	trap	18		;MULF
94C4:	dec	0006(sp)	;decrement and test
94C8:	bgt	94BA		;loop
94CA:	br	94DC
; M.AFDV:
94CC:	mov	0008(sp),r0
94D0:	mov	#94F2,r1	;floating point constant 10
94D4:	trap	16		;DIVF
94D6:	inc	0006(sp)	;increment and test
94DA:	blt	94CC		;loop
; M.AFX5:
94DC:	mov	(sp)+,r1	;restore the character pointer
94DE:	dec	r1
94E0:	mov	(sp)+,r4	;save switches
94E2:	add	#6,sp
94E6:	mov	(sp)+,r5
94E8:	bit	#0002,r4	;test the V switch
94EC:	beq	94F0		;normal return
; error return
94EE:	set	v
94F0:	rts	pc

94F2:	.word	0000, 5000, 8004	;10
94F8:	.word	0000, 4000, 8001	;1
94FE:	.word	0000, 7A12, 8014	;1000000
9504:	.word	4000, 4C4B, 8018	;10000000
950A:	.word	0000, 4000, 8000	;0.5

; FTOA - floating point to ASCII conversion
; expects the floating point number in r2,r3,r4
; r2 - lower word of the mantissa, r3 - upper word of the mantissa
; r4 - biased exponent EXP1
; returns the output string on the stack
; typical calling sequence:
; jsr	pc,9510		;FTOA
; mov	sp,r0		;pointer to the output string
; trap	36		;print a string pointed to by r0
; add	#14,sp		;reclaim the stack space
9510:	mov	#A,r0
9514:	clr	-(sp)
9516:	dec	r0
9518:	bgt	9514
951A:	trap	62		;push r4,r3,r2 on the stack
951C:	mov	#3020,0008(sp)
9522:	movb	#20,000A(sp)
9528:	tst	r3		;upper word of the mantissa
952A:	beq	95F8		;skip if the number is equal 0
952C:	bgt	953A		;skip if the number is positive
; negative number
952E:	mov	sp,r0
9530:	mov	r0,r1
9532:	trap	14		;NEGF
9534:	movb	#2D,0008(sp)	;'-'
;
; multiply or divide the number by 10 as many times as is needed to bring it
; in the range 1e6 <= x < 1e7
; compensate the multiplication or division by changing the exponent EXP2 with
; base 10 (decimal)
953A:	mov	#94FE,r1	;floating point constant 1000000
953E:	mov	sp,r0
9540:	trap	1C		;CMPF
9542:	bgt	955C
;
9544:	mov	#9504,r0	;floating point constant 10000000
9548:	mov	sp,r1
954A:	trap	1C		;CMPF
954C:	blt	956A		;branch if in range
954E:	mov	#94F2,r1	;floating point constant 10
9552:	mov	sp,r0
9554:	trap	16		;DIVF
9556:	inc	0006(sp)	;increment exponent EXP2
955A:	br	9544		;repeat range check
;
955C:	mov	#94F2,r1	;floating point constant 10
9560:	mov	sp,r0
9562:	trap	18		;MULF
9564:	dec	0006(sp)	;decrement exponent EXP2
9568:	br	953A		;repeat range check
;
; rounding
956A:	mov	#950A,r1	;floating point constant 0.5
956E:	mov	sp,r0
9570:	trap	10		;ADDF
;
; convert the number to unsigned 32-bit integer (get rid of the exponent EXP1)
9572:	sub	#801F,0004(sp)
9578:	asr	0002(sp)	;upper word of the mantissa
957C:	ror	(sp)		;lower word of the mantissa
957E:	inc	0004(sp)	;exponent EXP1 with base 2 (decimal)
9582:	bne	9578
;
9584:	mov	sp,r0
9586:	add	#E,r0
958A:	mov	sp,r1
958C:	mov	r0,-(sp)
958E:	trap	0C		;JTOA, 32-bit integer to ASCII conversion
9590:	mov	(sp)+,r0
9592:	add	#3,r0		;skip first three spaces
9596:	cmpb	#20,(r0)	;space?
959A:	beq	95A2		;branch if yes
959C:	inc	0006(sp)	;exponent EXP2, move the decimal point
95A0:	br	95A4
; M.XA7:
95A2:	inc	r0		;fourth position
95A4:	add	#7,0006(sp)
95AA:	mov	#8,r1
95AE:	mov	r0,r2
95B0:	add	#7,r2
95B4:	dec	r1
95B6:	cmpb	#30,-(r2)
95BA:	beq	95B4
95BC:	mov	sp,r4
95BE:	add	#9,r4
95C2:	cmp	#8,0006(sp)	;exponent EXP2
95C8:	ble	961A		;scientific notation if exponent too large
95CA:	cmp	#-8,0006(sp)
95D0:	bge	961A		;scientific notation if exponent too small
;
; standard decimal notation
95D2:	mov	r1,r3
95D4:	neg	r3
95D6:	add	0006(sp),r3
95DA:	add	#7,r3
95DE:	blt	961A
95E0:	mov	0006(sp),r3
95E4:	blt	9600
95E6:	bgt	960E
95E8:	movb	#2E,(r4)+	;decimal point
95EC:	movb	(r0)+,(r4)+	;shift one digit left
95EE:	cmp	r0,r2
95F0:	blos	95EC		;loop
95F2:	movb	#20,(r4)+
95F6:	clrb	(r4)
95F8:	add	#8,sp
95FC:	mov	0012(sp),pc
;
9600:	movb	#2E,(r4)+	;decimal point
9604:	movb	#30,(r4)+	;insert zeroes
9608:	inc	r3
960A:	blt	9604		;loop
960C:	br	95EC
;
960E:	movb	(r0)+,(r4)+
9610:	dec	r3
9612:	bgt	960E
9614:	cmp	r0,r2
9616:	blos	95E8
9618:	br	95F2
;
; normalized scientific notation
961A:	movb	#2E,(r4)+	;decimal point
961E:	movb	(r0)+,(r4)+	;shift one digit left
9620:	cmp	r0,r2
9622:	blos	961E		;loop
9624:	movb	#45,(r4)+	;'E'
9628:	add	#6,sp
962C:	mov	(sp),r1
962E:	mov	sp,r0
9630:	add	#C,r0
9634:	mov	r0,-(sp)
9636:	mov	r4,-(sp)
9638:	trap	0A		;ITOA
963A:	mov	(sp)+,r4
963C:	mov	(sp)+,r0
963E:	cmpb	(r0)+,#20
9642:	beq	963E
9644:	cmpb	-(r0),#2D	;'-'
9648:	beq	964E
964A:	movb	#20,(r4)+
964E:	movb	(r0)+,(r4)+
9650:	cmpb	(r0),#20
9654:	bne	964E
9656:	movb	#20,(r4)+
965A:	clrb	(r4)
965C:	tst	(sp)+
965E:	mov	0012(sp),pc

; trap 08 - ATOI (documented), conversion of an ASCII string to an unsigned
; integer
; on entry r1 points to the string
; on exit r1 points to the first invalid character,
; result (1 word) stored in r0
9662:	clr	r0
9664:	jsr	pc,82BC		;get a character other than space
9668:	jsr	pc,8180		;test if r2 is a digit
966C:	bne	9684		;branch if not
966E:	sub	#30,r2		;create binary number from ASCII
9672:	asl	r0		;multiply by 10 (decimal)
9674:	add	r0,r2
9676:	asl	r0
9678:	asl	r0
967A:	add	r2,r0
967C:	bit	#E000,r0
9680:	beq	9664
9682:	trap	21		;error 16 - wrong line number or dimension
9684:	dec	r1
9686:	rts	pc

; trap 0A - ITOA (documented), conversion of an 16-bit integer to ASCII string
; on entry r1 contains the number and r0 points to the memory location where
; the result should be stored
9688:	mov	r0,-(sp)	;save DEFA
968A:	clr	-(sp)		;clear high order of integer
968C:	mov	r1,-(sp)	;get integer
968E:	bge	9694		;skip if positive
9690:	com	0002(sp)	;propagate sign through high order
9694:	mov	sp,r1		;set SEFA
9696:	sub	#C,sp		;expand stack
969A:	mov	sp,r0
969C:	trap	0C		;JTOA, 32-bit integer to ASCII conversion
969E:	mov	sp,r1
96A0:	mov	0010(sp),r0	;users DEFA
96A4:	add	#5,r1		;first five are spaces
96A8:	mov	#7,r2		;seven digits
96AC:	movb	(r1)+,(r0)+
96AE:	dec	r2		;move ASCII string
96B0:	bgt	96AC		;loop
96B2:	add	#12,sp		;remove junk
96B6:	rts	pc

; trap 0C - JTOA, conversion of an 32-bit integer to ASCII string
; on entry r1 points the number and r0 points to the memory location where
; the result should be stored
96B8:	mov	r5,-(sp)
96BA:	mov	r0,-(sp)
96BC:	clr	-(sp)		;sign control word
96BE:	mov	(r1)+,r3	;low order
96C0:	mov	(r1),r2		;high order
96C2:	bge	96CC		;skip if positive
; negative
96C4:	neg	r2
96C6:	neg	r3		;complement but...
96C8:	sbc	r2
96CA:	inc	(sp)		;...remember sign
96CC:	mov	#A,r5		;lower word of the dividend = 10 decimal
96D0:	clr	r4		;upper word of the dividend = 0
96D2:	mov	#-1,-(sp)	;flag
; M.JA01:
96D6:	clr	r0
96D8:	clr	r1
96DA:	trap	34		;unsigned 32-bit integer division
96DC:	mov	r1,-(sp)	;push remainder
96DE:	bis	r2,r0		;test the quotient r2,r3 for 0
96E0:	bis	r3,r0
96E2:	tst	r0		;superfluous?
96E4:	bne	96D6		;loop
96E6:	mov	sp,r5		;count the number of digits
96E8:	inc	r4
96EA:	tst	(r5)+		;check for flag
96EC:	bge	96E8		;loop
96EE:	dec	r4
96F0:	mov	#B,r3
96F4:	sub	r4,r3		;r3 <- number of leading spaces + sign
96F6:	dec	r3
96F8:	mov	0002(r5),r0
; M.JA02:
96FC:	tst	r3		;count exhausted?
96FE:	ble	9708		;branch if yes
9700:	movb	#20,(r0)+	;insert leading spaces
9704:	dec	r3
9706:	br	96FC		;loop
; M.JA03:
9708:	tst	(r5)		;test for sign
970A:	beq	9712
970C:	movb	#2D,(r0)+	;'-'
9710:	br	9716
; M.JA04:
9712:	movb	#20,(r0)+	;space
; M.JA05:
9716:	add	#30,(sp)	;convert digits to ASCII
971A:	movb	(sp)+,(r0)+
971C:	tst	(sp)		;check flag
971E:	bge	9716		;loop
9720:	movb	#20,(r0)	;trailing space
9724:	add	#6,sp
9728:	mov	(sp)+,r5
972A:	rts	pc

; End of code borrowed from the RT-11 operating system.


; trap 0E - IMUL (documented), unsigned 16-bit integer multiplication
; r0 - multiplicand, r1 - multiplier, r0,r1 - product (the upper word in r0)
972C:	mov	r5,-(sp)
972E:	mov	r0,r3
9730:	mov	r1,r5
9732:	clr	r2
9734:	clr	r4
9736:	trap	32		;unsigned 32-bit integer multiplication
9738:	mov	r3,r0
973A:	mov	r2,r1
973C:	mov	(sp)+,r5
973E:	rts	pc

; trap 32 - unsigned 32-bit integer multiplication
; r2,r3 - multiplier (the upper word in r2)
; r4,r5 - multiplicand (the upper word in r4)
; r0,r1,r2,r3 - product (the upper word in r0)
9740:	clr	r0		;initial product = 0
9742:	clr	r1
9744:	mov	#21,-(sp)	;bit counter
; multiplication loop
9748:	ror	r0		;shift the product and multiplier one bit down
974A:	ror	r1
974C:	ror	r2
974E:	ror	r3
9750:	bhis	9758		;if least significant bit of multiplier is 1
9752:	add	r5,r1		;... then add the multiplicand to the product
9754:	adc	r0
9756:	add	r4,r0
9758:	dec	(sp)		;bit counter
975A:	bne	9748		;loop
975C:	tst	(sp)+
975E:	rts	pc

; trap 34 - unsigned 32-bit integer division
; r0,r2,r2,r3 - dividend (the upper word in r0)
; r4,r5 - divisor (the upper word in r4)
; r2,r3 - quotient (the upper word in r2)
; r0,r1 - remainder (the upper word in r0)
9760:	mov	#20,-(sp)	;bit counter
; negated divisor goes on the stack
9764:	mov	r4,-(sp)
9766:	mov	r5,-(sp)
9768:	neg	0002(sp)
976C:	neg	(sp)
976E:	sbc	0002(sp)
9772:	add	(sp),r1
9774:	adc	r0
9776:	add	0002(sp),r0
977A:	blo	97C6		;overflow
977C:	clr	-(sp)
; division loop
977E:	rol	r3		;shift the dividend/quotient one bit up
9780:	rol	r2
9782:	rol	r1
9784:	rol	r0
9786:	tst	(sp)
9788:	beq	979A
; subtract the divisor from the dividend
978A:	clr	(sp)
978C:	add	0002(sp),r1
9790:	adc	r0
9792:	adc	(sp)
9794:	add	0004(sp),r0
9798:	br	97A2
; the dividend was less than the divisor, take back the subtraction
979A:	add	r5,r1		;add the divisor to the dividend
979C:	adc	r0
979E:	adc	(sp)
97A0:	add	r4,r0
97A2:	adc	(sp)
97A4:	tst	(sp)
97A6:	beq	97AA
97A8:	inc	r3		;increment the quotient
97AA:	dec	0006(sp)	;bit counter
97AE:	bgt	977E		;loop
97B0:	ror	r3
97B2:	blo	97BC
97B4:	add	r5,r1
97B6:	adc	r0
97B8:	add	r4,r0
97BA:	clc
97BC:	rol	r3
97BE:	add	#8,sp
97C2:	clear	v
97C4:	rts	pc
; overflow
97C6:	add	#6,sp
97CA:	trap	FB		;error 125 - multiplication/division overflow
97CC:	set	v
97CE:	rts	pc

; trap 10 - ADDF (documented), floating point addition
; addends pointed to by r0 and r1, sum pointed to by r0
97D0:	mov	r5,-(sp)
97D2:	mov	r0,-(sp)	;save the pointer to the sum
; first addend
97D4:	mov	(r1)+,-(sp)	;lower word of the mantissa
97D6:	mov	(r1)+,-(sp)	;upper word of the mantissa
97D8:	mov	(r1),-(sp)	;exponent
; second addend
97DA:	mov	(r0)+,r2	;lower word of the mantissa
97DC:	mov	(r0)+,r1	;upper word of the mantissa
97DE:	mov	(r0),r0		;exponent
97E0:	cmp	r0,(sp)		;compare exponents
97E2:	blos	97F8
; swap addends
97E4:	mov	sp,r4
97E6:	mov	r0,r3
97E8:	mov	(r4),r0
97EA:	mov	r3,(r4)+
97EC:	mov	r1,r3
97EE:	mov	(r4),r1
97F0:	mov	r3,(r4)+
97F2:	mov	r2,r3
97F4:	mov	(r4),r2
97F6:	mov	r3,(r4)+
; larger addend is pointed to by SP
; smaller addend: exponent in r0, mantissa in r1,r2
97F8:	sub	(sp),r0		;difference between the exponents
97FA:	beq	982E		;no alignment required
97FC:	bpl	9804		;should never happen ???
97FE:	cmp	r0,#-1F
9802:	bge	980E
; smaller addend is insignificant, the answer is the larger addend
9804:	mov	0002(sp),r5
9808:	mov	0004(sp),r3
980C:	br	9846
; the mantissa of the smaller addend needs to be shifted until the exponents
; are equal
980E:	cmp	r0,#-10		;difference between exponents
9812:	bgt	9822
; we can spare on shifts
9814:	add	#10,r0
9818:	mov	r1,r2		;upper word -> lower word
981A:	clr	r1		;0 -> upper word
981C:	tst	r2		;negative number?
981E:	bpl	9822		;skip if not
9820:	com	r1		;FFFF -> upper word
9822:	tst	r0
9824:	beq	982E
; this loop shifts the mantissa of the smaller addend -r0 times
9826:	asr	r1		;upper word of the mantissa
9828:	ror	r2		;lower word of the mantissa
982A:	inc	r0
982C:	bne	9826		;loop
; perform the addition of both mantissas
982E:	mov	0002(sp),r5
9832:	mov	0004(sp),r3
9836:	add	r2,r3
9838:	adc	r5
983A:	bvs	985E
983C:	add	r1,r5
983E:	bvc	9846
; overflow
9840:	ror	r5		;shift the mantissa right
9842:	ror	r3
9844:	inc	(sp)		;increment the exponent
; save the result in the memory
9846:	mov	0006(sp),r0	;pointer where the sum is to be stored
984A:	mov	r0,r1		;save the pointer
984C:	mov	r3,(r0)+	;lower word of the mantissa
984E:	mov	r5,(r0)+	;upper word of the mantissa
9850:	mov	(sp),(r0)+	;exponent
9852:	mov	r1,r0		;restore the pointer
9854:	add	#8,sp
9858:	mov	(sp)+,r5
985A:	jmp	99C4		;normalisation
;
985E:	add	r1,r5
9860:	bcs	9846		;branch if negative
9862:	br	9840

; trap 12 - SUBF (documented), floating point subtraction
; minuend pointed to by r0, subtrahend pointed to by r1,
; remainder pointed to by r0
9864:	mov	r0,r4
9866:	sub	#6,sp
986A:	mov	sp,r0
986C:	trap	14		;NEGF
986E:	mov	r4,r0
9870:	mov	sp,r1
9872:	trap	10		;ADDF
9874:	add	#6,sp
9878:	rts	pc

; function ABS
987A:	trap	1A		;MOVF
987C:	tst	0002(r1)
9880:	bge	9892

; trap 14 - NEGF (documented), floating point negation
; argument pointed to by r1, result pointed to by r0
9882:	mov	(r1)+,r2
9884:	mov	(r1)+,r3
9886:	neg	r3
9888:	neg	r2
988A:	sbc	r3
988C:	mov	r2,(r0)+
988E:	mov	r3,(r0)+
9890:	mov	(r1)+,(r0)+
9892:	rts	pc

; function SGN
9894:	trap	1A		;MOVF
9896:	mov	#94F8,r1	;floating point constant 1
989A:	tst	0002(r0)
989E:	bgt	98A6
98A0:	beq	98A8
98A2:	trap	14		;NEGF
98A4:	rts	pc
98A6:	trap	1A		;MOVF
98A8:	rts	pc

; trap 16 - DIVF (documented), floating point division
; dividend pointed to by r0, divisor pointed to by r1,
; quotient pointed to by r0
98AA:	mov	r5,-(sp)
98AC:	mov	r0,-(sp)	;save the pointer to the quotient
98AE:	clr	-(sp)		;sign of the factor
; divisor
98B0:	mov	(r1)+,r5	;lower word of the mantissa
98B2:	mov	(r1)+,r4	;upper word of the mantissa
98B4:	tst	r4
98B6:	beq	9936		;branch if division by 0 attempted
98B8:	bge	98C2		;skip if positive
; negative
98BA:	neg	r4
98BC:	neg	r5		;complement but...
98BE:	sbc	r4
98C0:	inc	(sp)		;...remember sign
; dividend
98C2:	mov	(r0)+,r3	;lower word of the mantissa
98C4:	mov	(r0)+,r2	;upper word of the mantissa
98C6:	beq	99AE		;branch if the dividend is equal 0
98C8:	bgt	98D2		;skip if positive
; negative
98CA:	neg	r2
98CC:	neg	r3		;complement but...
98CE:	sbc	r2
98D0:	dec	(sp)		;...remember sign
; calculate the exponent of the quotient
98D2:	mov	(r1),r1		;exponent of the divisor
98D4:	neg	r1
98D6:	add	(r0),r1		;subtract it from the exponent of the dividend
98D8:	ror	r1
98DA:	rol	r1
98DC:	bvc	9936		;overflow
98DE:	add	#8000,r1	;bias
98E2:	mov	r1,-(sp)
; divide the mantissas
98E4:	mov	r3,r1
98E6:	mov	r2,r0
98E8:	clr	r2
98EA:	clr	r3
98EC:	ror	r0
98EE:	ror	r1
98F0:	ror	r2
98F2:	trap	34		;unsigned 32-bit integer division
98F4:	neg	r4
98F6:	neg	r5
98F8:	sbc	r4
98FA:	asl	r1
98FC:	rol	r0
98FE:	add	r5,r1
9900:	adc	r0
9902:	add	r4,r0
9904:	blt	990C
9906:	add	#1,r3
990A:	adc	r2
990C:	clc
990E:	ror	r2
9910:	ror	r3
9912:	inc	(sp)
9914:	tst	0002(sp)
9918:	beq	9920
991A:	neg	r2
991C:	neg	r3
991E:	sbc	r2
9920:	mov	0004(sp),r0
9924:	mov	r3,(r0)+
9926:	mov	r2,(r0)+
9928:	mov	(sp)+,(r0)
992A:	cmp	(sp)+,(sp)+
992C:	mov	(sp)+,r5
992E:	cmp	-(r0),-(r0)
9930:	mov	r0,r1
9932:	jmp	99C4		;normalisation
9936:	cmp	(sp)+,(sp)+
9938:	trap	FB		;error 125 - multiplication/division overflow
993A:	mov	(sp)+,r5
993C:	set	v
993E:	rts	pc

; trap 18 - MULF (documented), floating point multiplication
; factors pointed to by r0 and r1, product pointed to by r0
9940:	mov	r5,-(sp)
9942:	mov	r0,-(sp)	;save the pointer to the product
; second factor
9944:	mov	(r1)+,r5	;lower word of the mantissa
9946:	mov	(r1)+,r4	;upper word of the mantissa
9948:	mov	(r1),r1		;exponent
994A:	clr	-(sp)		;sign of the product
994C:	tst	r4
994E:	beq	99AE		;branch if the factor is equal 0
9950:	bpl	995A		;skip if positive
; negative
9952:	neg	r4
9954:	neg	r5		;complement but...
9956:	sbc	r4
9958:	dec	(sp)		;...remember sign
; first factor
995A:	mov	(r0)+,r3	;lower word of the mantissa
995C:	mov	(r0)+,r2	;upper word of the mantissa
995E:	beq	99AE		;branch if the factor is equal 0
9960:	bpl	996A		;skip if positive
; negative
9962:	neg	r2
9964:	neg	r3		;complement but...
9966:	sbc	r2
9968:	inc	(sp)		;...remember sign
; calculate the exponent of the product
996A:	add	(r0),r1		;sum of the exponents of the factors
996C:	ror	r1
996E:	rol	r1
9970:	bvc	9936		;overflow
9972:	add	#8000,r1	;bias
9976:	mov	r1,-(sp)
; multiply the mantissas
9978:	trap	32		;unsigned 32-bit integer multiplication
; normalisation
997A:	inc	(sp)
997C:	rol	r2
997E:	rol	r1
9980:	rol	r0		;shift the mantissa one bit left...
9982:	bvs	9988		;...until first bit is not zero
9984:	dec	(sp)		;exponent
9986:	br	997C		;loop
; rounding
9988:	ror	r0
998A:	ror	r1
998C:	adc	r1
998E:	adc	r0
9990:	bvc	9996
9992:	inc	(sp)
9994:	br	9988
9996:	mov	(sp)+,r2	;exponent
; apply the sign
9998:	tst	(sp)+
999A:	beq	99A2		;skip if positive
; complement the mantissa
999C:	neg	r0
999E:	neg	r1
99A0:	sbc	r0
; save the result in the memory
99A2:	mov	(sp)+,r3	;pointer where the result is to be stored
99A4:	mov	r1,(r3)+	;lower word of the mantissa
99A6:	mov	r0,(r3)+	;upper word of the mantissa
99A8:	mov	r2,(r3)		;exponent
99AA:	mov	(sp)+,r5
99AC:	rts	pc
; result = 0
99AE:	clr	r0
99B0:	clr	r1
99B2:	clr	r2
99B4:	tst	(sp)+
99B6:	br	99A2

; trap 1E - FLT (documented), convert an integer number to a floating point,
; expects the argument in r1 and the pointer to memory location where the
; result should be stored in r0
99B8:	clr	(r0)+
99BA:	mov	r1,(r0)+
99BC:	mov	#800F,(r0)
99C0:	cmp	-(r0),-(r0)
99C2:	mov	r0,r1
99C4:	mov	(r1)+,r4	;low word of mantissa
99C6:	mov	(r1)+,r2	;high word of mantissa
99C8:	mov	(r1)+,r3	;exponent
99CA:	mov	r3,r1
; test the floating point number for 0
99CC:	tst	r2
99CE:	bne	99D8
99D0:	tst	r4
99D2:	bne	99D8
99D4:	clr	r3
99D6:	br	99F8
; floating point normalisation
99D8:	inc	r3
99DA:	dec	r3		;reduce exponent by one
99DC:	asl	r4		;low word of mantissa
99DE:	rol	r2		;high word of mantissa
99E0:	bvc	99DA
99E2:	bhis	99F4
99E4:	bne	99F4
99E6:	tst	r4
99E8:	bne	99F2
99EA:	sec
99EC:	ror	r2
99EE:	inc	r3
99F0:	inc	r1
99F2:	sec
99F4:	ror	r2
99F6:	ror	r4
99F8:	mov	r4,(r0)+
99FA:	mov	r2,(r0)+
99FC:	mov	r3,(r0)+
99FE:	cmp	r3,r1
9A00:	bhi	9A06
9A02:	clear	v
9A04:	rts	pc
9A06:	set	v
9A08:	rts	pc

; trap 1A - MOVF
9A0A:	mov	r1,r2
9A0C:	mov	r0,r4
9A0E:	mov	(r2)+,(r4)+
9A10:	mov	(r2)+,(r4)+
9A12:	mov	(r2)+,(r4)+
9A14:	rts	pc

; trap 1C - CMPF (documented), floating point comparison
; compared numbers pointed to by r0 and r1, sets flags as CMP
9A16:	mov	r1,-(sp)
9A18:	trap	2C		;push a number pointed to by R0 on the stack
9A1A:	mov	sp,r0
9A1C:	mov	0006(sp),r1
9A20:	trap	12		;SUBF
9A22:	mov	0002(sp),r1
9A26:	add	#8,sp
9A2A:	neg	r1
9A2C:	rts	pc

; trap 2C - push the floating point number pointed to by R0 on the stack
9A2E:	mov	(sp)+,r2	;return address
9A30:	add	#6,r0
9A34:	mov	-(r0),-(sp)
9A36:	mov	-(r0),-(sp)
9A38:	mov	-(r0),-(sp)
9A3A:	mov	r2,pc

; function INT
9A3C:	mov	(r1)+,r3
9A3E:	mov	(r1)+,r2
9A40:	mov	(r1),r4
9A42:	bpl	9A66
9A44:	cmp	-(r1),-(r1)
9A46:	cmp	r4,#801F
9A4A:	bhis	9A0A
9A4C:	sub	#801F,r4
9A50:	asr	r2
9A52:	ror	r3
9A54:	inc	r4
9A56:	blt	9A50
9A58:	mov	r0,r1
9A5A:	mov	r3,(r0)+
9A5C:	mov	r2,(r0)+
9A5E:	mov	#801F,(r0)
9A62:	mov	r1,r0
9A64:	br	99C4		;normalisation
9A66:	tst	r2
9A68:	bpl	9A72
9A6A:	mov	#94F8,r1	;floating point constant 1
9A6E:	jmp	9882
9A72:	clr	(r0)+
9A74:	clr	(r0)+
9A76:	clr	(r0)
9A78:	rts	pc

; trap 22
9A7A:	mov	(r1)+,r2
9A7C:	mov	(r1)+,r3
9A7E:	mov	(r1),r4

; trap 20 - FIX (documented), convert a floating point number to an integer
; r2, r3, r4 -> r0
9A80:	cmp	r4,#800F
9A84:	bhi	9A9C
9A86:	beq	9A98
9A88:	cmp	r4,#8000
9A8C:	blo	9A9E
9A8E:	sub	#800F,r4
9A92:	asr	r3
9A94:	inc	r4
9A96:	bne	9A92
9A98:	mov	r3,r0
9A9A:	rts	pc
9A9C:	trap	F9		;error 124 - number out of FIX operator range
9A9E:	clr	r0
9AA0:	rts	pc

9AA2:	      0F 42  41 53 49 43  20 56 32 2E  30 20 28 63  ...BASIC V2.0 (c
9AB0:	29 20 31 39  38 37 0D 0A  00 0E 6D 49  4E 53 4B 2E  ) 1987....mINSK.
9AC0:	20 70 6F 20  69 4E 54 45  47 52 41 4C  0F 0D 0A 00   po iNTEGRAL....

; operator ^ (power)
9AD0:	mov	(r1),r3
9AD2:	mov	0002(r1),r2
9AD6:	mov	0004(r1),r4
9ADA:	bpl	9AEE
9ADC:	sub	#801F,r4
9AE0:	bpl	9AEC
9AE2:	asr	r2
9AE4:	ror	r3
9AE6:	blo	9AEE
9AE8:	inc	r4
9AEA:	blt	9AE2
9AEC:	br	9AF2
9AEE:	jmp	9B50
9AF2:	mov	r0,-(sp)
9AF4:	trap	2C		;push a number pointed to by R0 on the stack
9AF6:	mov	r1,r0
9AF8:	trap	2C		;push a number pointed to by R0 on the stack
9AFA:	mov	#94F8,r1	;floating point constant 1
9AFE:	mov	000C(sp),r0
9B02:	trap	1A		;MOVF
9B04:	mov	sp,r0
9B06:	mov	r0,-(sp)
9B08:	mov	r0,-(sp)
9B0A:	add	#6,(sp)
9B0E:	mov	0002(sp),r0
9B12:	mov	r0,r1
9B14:	jsr	pc,9A3C		;INT
9B18:	tst	0006(sp)
9B1C:	bgt	9B28
9B1E:	blt	9B3C
9B20:	add	#12,sp
9B24:	clear	v
9B26:	rts	pc
9B28:	mov	(sp),r1
9B2A:	mov	0010(sp),r0
9B2E:	trap	18		;MULF
9B30:	mov	#94F8,r1	;floating point constant 1
9B34:	mov	0002(sp),r0
9B38:	trap	12		;SUBF
9B3A:	br	9B18
9B3C:	mov	(sp),r1
9B3E:	mov	0010(sp),r0
9B42:	trap	16		;DIVF
9B44:	mov	#94F8,r1	;floating point constant 1
9B48:	mov	0002(sp),r0
9B4C:	trap	10		;ADDF
9B4E:	br	9B18
9B50:	mov	r1,-(sp)
9B52:	mov	r0,-(sp)
9B54:	sub	#6,sp
9B58:	mov	r0,r1
9B5A:	mov	sp,r0
9B5C:	jsr	pc,9B78		;LOG
9B60:	mov	0008(sp),r1
9B64:	mov	sp,r0
9B66:	trap	18		;MULF
9B68:	mov	0006(sp),r0
9B6C:	mov	sp,r1
9B6E:	jsr	pc,9C34		;EXP
9B72:	add	#A,sp
9B76:	rts	pc


; The routines for the trigonometric, exponential and square root functions
; are apparently based on the floating point library of the RT-11 operating
; system. The original labels and comments are preserved.

; function LOG
9B78:	trap	2E
9B7A:	tst	0002(r0)
9B7E:	bgt	9B88
9B80:	trap	FF		;error 127 - exponent/logarithm overflow
9B82:	add	#4,sp
9B86:	rts	pc
9B88:	mov	r0,r1
9B8A:	tst	(r1)+
9B8C:	bne	9BA6
9B8E:	cmp	(r1)+,#4000
9B92:	bne	9BA6
9B94:	cmp	(r1)+,#8001
9B98:	bne	9BA6
9B9A:	clr	(r0)+
9B9C:	clr	(r0)+
9B9E:	clr	(r0)+
9BA0:	add	#4,sp
9BA4:	rts	pc
9BA6:	mov	0004(r0),-(sp)
9BAA:	add	#8000,(sp)
9BAE:	mov	#8000,0004(r0)
9BB4:	mov	(sp),r1
9BB6:	sub	#6,sp
9BBA:	mov	sp,r0
9BBC:	trap	1E		;FLT, convert integer R1 to float
9BBE:	mov	0008(sp),r0
9BC2:	trap	2C		;push a number pointed to by R0 on the stack
9BC4:	mov	#9C10,r1
9BC8:	trap	12		;SUBF
9BCA:	mov	sp,r0
9BCC:	mov	#9C10,r1
9BD0:	trap	10		;ADDF
9BD2:	mov	000E(sp),r0
9BD6:	mov	sp,r1
9BD8:	trap	16		;DIVF
9BDA:	mov	#9C1C,r4
9BDE:	mov	000E(sp),r0
9BE2:	mov	#4,r3
9BE6:	trap	28		;M.SETU
9BE8:	trap	2A		;M.DOPO
9BEA:	mov	000E(sp),r0
9BEE:	mov	#9CCA,r1
9BF2:	trap	12		;SUBF
9BF4:	add	#6,sp
9BF8:	mov	sp,r0
9BFA:	mov	#9C16,r1
9BFE:	trap	18		;MULF
9C00:	mov	sp,r1
9C02:	mov	0008(sp),r0
9C06:	trap	10		;ADDF
9C08:	add	#C,sp
9C0C:	clear	v
9C0E:	rts	pc

9C10:	.word	7996, 5A82, 8000	;0.7071067794 = SQR (0.5)
9C16:	.word	0BFE, 58B9, 8000	;0.6931471815 = LN (2)
9C1C:	.word	AA4A, 4D0C, 7FFF	;0.3009745054
9C22:	.word	0F09, 6650, 7FFF	;0.3996590993
9C28:	.word	6CDB, 5555, 8000	;0.6666694707
9C2E:	.word	FFFA, 7FFF, 8001	;1.9999999944

; function EXP - operand pointed to by r1, result pointed to by r0
9C34:	trap	2E		;M.INI2, push the pointers on the stack
9C36:	cmp	0004(r0),#800E	;check the exponent
9C3C:	bhi	9B80		;overflow
9C3E:	mov	#9CC4,r1
9C42:	trap	26
9C44:	mov	0002(sp),r0
9C48:	mov	#9CCA,r1
9C4C:	trap	18		;MULF, Y=frac(Y*log(e) base 2)*ln(2)/2
9C4E:	mov	0002(sp),r0
9C52:	trap	2C		;push a number pointed to by R0 on the stack
9C54:	trap	2C		;push a number pointed to by R0 on the stack
9C56:	mov	sp,r0
9C58:	mov	#9CD0,r1
9C5C:	trap	10		;ADDF
9C5E:	mov	sp,r0
9C60:	mov	r0,r1
9C62:	trap	14		;NEGF
9C64:	inc	000A(sp)
9C68:	mov	000E(sp),r0
9C6C:	mov	r0,r1
9C6E:	trap	18		;MULF
9C70:	mov	000E(sp),r0
9C74:	mov	#9CDC,r1
9C78:	trap	10		;ADDF
9C7A:	mov	#9CD6,r0
9C7E:	trap	2C		;push a number pointed to by R0 on the stack
9C80:	mov	sp,r0
9C82:	mov	0014(sp),r1
9C86:	trap	16		;DIVF
9C88:	mov	sp,r0
9C8A:	mov	r0,r1
9C8C:	add	#6,r1
9C90:	trap	10		;ADDF
9C92:	mov	sp,r1
9C94:	mov	r1,r0
9C96:	add	#C,r0
9C9A:	trap	16		;DIVF
9C9C:	add	#C,sp
9CA0:	mov	sp,r0
9CA2:	mov	#94F8,r1	;floating point constant 1
9CA6:	trap	10		;ADDF
9CA8:	mov	sp,r0
9CAA:	mov	r0,r1
9CAC:	trap	18		;MULF
9CAE:	mov	sp,r1
9CB0:	mov	0008(sp),r0
9CB4:	trap	1A		;MOVF
9CB6:	mov	0008(sp),r0
9CBA:	add	0006(sp),0004(r0)
9CC0:	jmp	9C08

9CC4:	.word	1D94, 5C55, 8001	;1.4426950402 = log(e) base 2 = 1 / (ln 2)
9CCA:	.word	0BFE, 58B9, 7FFF	;0.3465735908 = (ln 2)/2
9CD0:	.word	3EE7, 9FE1, 8004	;-12.015016742
9CD6:	.word	4375, B4C6, 800A	;-601.804265499
9CDC:	.word	2D78, 782E, 8006	;60.090190649

; trap 2A - M.DOPO
; evaluates a polynomial according to the parameters on the stack (see M.SETU)
; 2(SP) = number of constants
; A(SP) = starting address of constants
9CE2:	sub	#2,0002(sp)	;subtract 2 from the counter
9CE8:	mov	0008(sp),r0
9CEC:	mov	000A(sp),r1	;address of the first constant
9CF0:	mov	r0,-(sp)
9CF2:	trap	18		;MULF
; M.LOOP:
9CF4:	add	#6,000C(sp)	;move to the next constant
9CFA:	mov	(sp),r0
9CFC:	mov	000C(sp),r1
9D00:	trap	10		;ADDF, DEST=DEST+constant
9D02:	tst	0004(sp)	;test the counter
9D06:	beq	9D16		;branch if done
9D08:	mov	(sp),r0
9D0A:	mov	0008(sp),r1
9D0E:	trap	18		;MULF, DEST=DEST*X^2
9D10:	dec	0004(sp)	;decrement the counter
9D14:	br	9CF4
; M.HANK:
9D16:	mov	(sp),r0
9D18:	mov	0006(sp),r1
9D1C:	trap	18		;MULF
9D1E:	tst	(sp)+
9D20:	mov	(sp)+,r3
9D22:	add	#16,sp
9D26:	mov	r3,-(sp)
9D28:	rts	pc

; trap 24 - M.INIT
9D2A:	mov	(sp)+,r3	;return address
9D2C:	clr	-(sp)		;clear a flag
9D2E:	mov	r1,-(sp)	;push SOURCE pointer
9D30:	mov	r0,-(sp)	;push DEST pointer
9D32:	trap	1A		;MOVF, move SOURCE to DEST
9D34:	mov	r3,pc

; trap 2E - M.INI2
9D36:	mov	(sp)+,r3
9D38:	br	9D2E

; trap 28 - M.SETU
9D3A:	mov	(sp)+,r1
9D3C:	trap	2C		;push a number pointed to by R0 on the stack
9D3E:	mov	r1,-(sp)
9D40:	mov	r4,-(sp)
9D42:	mov	r3,-(sp)
9D44:	mov	r0,-(sp)
9D46:	mov	r0,r1
9D48:	trap	18		;MULF
9D4A:	mov	(sp)+,r0
9D4C:	mov	(sp)+,r3
9D4E:	mov	(sp)+,r4
9D50:	mov	(sp)+,r1
9D52:	trap	2C		;push a number pointed to by R0 on the stack
9D54:	mov	r4,-(sp)
9D56:	mov	r0,-(sp)
9D58:	mov	#6,-(sp)
9D5C:	add	sp,(sp)
9D5E:	mov	#E,-(sp)
9D62:	add	sp,(sp)
9D64:	mov	r3,-(sp)
9D66:	mov	r1,pc

; trap 26 - M.FRAC, compute fractional part
9D68:	mov	0002(sp),r0
9D6C:	trap	18		;MULF
9D6E:	mov	(sp)+,0002(sp)	;pop return address
9D72:	mov	(sp),r1
9D74:	trap	22
9D76:	mov	r0,-(sp)
9D78:	mov	(sp),r1
9D7A:	sub	#6,sp
9D7E:	mov	sp,r0
9D80:	trap	1E		;FLT, convert integer R1 to float
9D82:	mov	sp,r1
9D84:	mov	0008(sp),r0
9D88:	trap	12		;SUBF
9D8A:	add	#6,sp
9D8E:	mov	0004(sp),-(sp)
9D92:	rts	pc

; function SIN
9D94:	trap	24		;M.INIT
9D96:	tst	0002(r0)
9D9A:	bge	9DA6		;skip if the operand not negative
; operand negative
9D9C:	mov	r0,r1
9D9E:	trap	14		;NEGF
9DA0:	inc	0004(sp)	;set neg_flag
9DA4:	br	9DAE
; M.NOTN:
9DA6:	bne	9DAE		;skip if the operand not equal 0
; M.EXIT:
9DA8:	add	#6,sp
9DAC:	rts	pc
; M.NOTE:
9DAE:	mov	#9E0A,r1	;2/PI
9DB2:	trap	26
9DB4:	mov	(sp)+,r2
9DB6:	bic	#FFFC,r2	;get two low order bits
9DBA:	asl	r2		;multiply by 2
9DBC:	add	#9E02,r2	;address of the branch table
9DC0:	mov	(r2),pc		;branch through the table

; M.Q2:
9DC2:	mov	#94F8,r1	;floating point constant 1
9DC6:	mov	(sp),r0
9DC8:	trap	12		;SUBF
; M.Q3:
9DCA:	mov	(sp),r0
9DCC:	mov	r0,r1
9DCE:	trap	14		;NEGF
9DD0:	br	9DDA
; M.Q4:
9DD2:	mov	#94F8,r1	;floating point constant 1
9DD6:	mov	(sp),r0
9DD8:	trap	12		;SUBF
; M.EVAL:
9DDA:	mov	(sp),r0
9DDC:	mov	#9E10,r4
9DE0:	mov	#6,r3
9DE4:	trap	28		;M.SETU
9DE6:	trap	2A		;M.DOPO
9DE8:	tst	0004(sp)	;neg_flag set?
9DEC:	beq	9DA8		;branch if not
; negate the result
9DEE:	mov	(sp),r0
9DF0:	mov	r0,r1
9DF2:	trap	14		;NEGF
9DF4:	br	9DA8

; function COS
9DF6:	trap	24		;M.INIT
9DF8:	mov	#9E2E,r1	;PI/2
9DFC:	trap	10		;ADDF
9DFE:	mov	(sp),r0
9E00:	br	9D96

9E02:	.word	9DDA, 9DC2, 9DCA, 9DD2	;M.EVAL, M.Q2, M.Q3, M.Q4

9E0A:	.word	C1B9, 517C, 8000	;0.6366197732 = 2/PI

9E10:	.word	1FBE, 8D4E, 7FEE	;-0.000003418172245
9E16:	.word	FACE, 53FF, 7FF4	;0.00016021713395
9E1C:	.word	DC8C, B34B, 7FF9	;-0.004681620238
9E22:	.word	EEFE, 519A, 7FFD	;0.07969258714
9E28:	.word	0C75, AD51, 8000	;-0.6459640912

9E2E:	.word	ED4E, 6487, 8001	;1.5707963239 = PI/2
9E34:	.word	1A87, 477D, 7FFB	;0.017453292487

; function ATN
9E3A:	clr	-(sp)
9E3C:	trap	24		;M.INIT
9E3E:	tst	0002(r0)	;is operand equal 0 ?
9E42:	beq	9EF4		;branch if yes
9E44:	bge	9E4E		;skip if the operand not negative
; operand negative
9E46:	inc	0006(sp)	;set neg_flag
9E4A:	mov	r0,r1
9E4C:	trap	14		;NEGF
; M.P2:
9E4E:	mov	#94F8,r1	;floating point constant 1
9E52:	mov	(sp),r0
9E54:	trap	1C		;CMPF
9E56:	bge	9E76
9E58:	inc	0004(sp)	;X is > 1, set a_flag
9E5C:	mov	#94F8,r0	;floating point constant 1
9E60:	trap	2C		;push a number pointed to by R0 on the stack
9E62:	mov	sp,r0
9E64:	mov	0006(sp),r1
9E68:	trap	16		;DIVF, let X = 1/X
9E6A:	mov	sp,r1
9E6C:	mov	0006(sp),r0
9E70:	trap	1A		;MOVF
9E72:	add	#6,sp
; M.P:
9E76:	mov	#9EFC,r1	;floating point constant 2 - SQR (3)
9E7A:	mov	(sp),r0
9E7C:	trap	1C		;CMPF, is X < 2 - SQR (3)
9E7E:	ble	9E88
9E80:	clr	-(sp)
9E82:	clr	-(sp)
9E84:	clr	-(sp)
9E86:	br	9EB8
; let X=(X*SQR(3)-1)/(X+SQR(3))
; let C=PI/6
; M.BR4:
9E88:	mov	#9F08,r0	;floating point constant PI/6
9E8C:	trap	2C		;push a number pointed to by R0 on the stack
9E8E:	mov	0006(sp),r0
9E92:	trap	2C		;push a number pointed to by R0 on the stack
9E94:	mov	#9F02,r1
9E98:	trap	18		;MULF
9E9A:	mov	000C(sp),r0
9E9E:	mov	#94F8,r1	;floating point constant 1
9EA2:	trap	12		;SUBF
9EA4:	mov	sp,r0
9EA6:	mov	#9F02,r1
9EAA:	trap	10		;ADDF
9EAC:	mov	000C(sp),r0
9EB0:	mov	sp,r1
9EB2:	trap	16		;DIVF
9EB4:	add	#6,sp
9EB8:	mov	0006(sp),r0
9EBC:	mov	#9F0E,r4
9EC0:	mov	#5,r3
9EC4:	trap	28		;M.SETU
9EC6:	trap	2A		;M.DOPO
9EC8:	mov	sp,r1
9ECA:	mov	0006(sp),r0
9ECE:	trap	10		;ADDF
9ED0:	add	#6,sp
9ED4:	tst	0004(sp)
9ED8:	beq	9EE8
9EDA:	mov	(sp),r0
9EDC:	mov	#9E2E,r1	;PI/2
9EE0:	trap	12		;SUBF
9EE2:	mov	(sp),r0
9EE4:	mov	r0,r1
9EE6:	trap	14		;NEGF
9EE8:	tst	0006(sp)
9EEC:	beq	9EF4
9EEE:	mov	(sp),r0
9EF0:	mov	r0,r1
9EF2:	trap	14		;NEGF
9EF4:	add	#8,sp
9EF8:	clear	v
9EFA:	rts	pc

9EFC:	.word	517C, 4498, 7FFF	;0.2679491928 = 2 - SQR (3)
9F02:	.word	EBA0, 6ED9, 8001	;1.7320508063 = SQR (3)
9F08:	.word	48DE, 4305, 8000	;0.5235987743 = PI/6
9F0E:	.word	9720, 6132, 7FFD	;0.09491954930
9F14:	.word	8FCF, B76E, 7FFE	;-0.1417346058
9F1A:	.word	DBA6, 6661, 7FFE	;0.1999653475
9F20:	.word	B20A, AAAA, 7FFF	;-0.3333328939
9F26:	.word	FFFE, 7FFF, 8000	;0.9999999991

; function SQR - radicand pointed to by r1, result pointed to by r0
; algorithm: rough estimation followed by Newton's iteration
9F2C:	trap	24		;M.INIT
9F2E:	tst	0002(r0)	;test the high word of mantissa
9F32:	beq	9F90		;if zero, we have the answer
9F34:	bge	9F3E		;negative?
9F36:	inc	0004(sp)	;yes, set neg_flag
9F3A:	mov	r0,r1
9F3C:	trap	14		;NEGF
9F3E:	clr	0002(sp)	;clear odd_flag (exponent odd or even)
9F42:	mov	(sp),r0		;pointer to the DEST
9F44:	cmp	(r0)+,(r0)+	;= add #4,r0
9F46:	add	#8000,(r0)	;get rid of the bias of the DEST exponent
9F4A:	asr	(r0)		;divide the DEST exponent by 2
9F4C:	adc	0002(sp)	;let odd_flag=Carry bit
9F50:	mov	(r0),-(sp)	;save DEST exponent on the stack
9F52:	mov	#8000,(r0)	;set DEST exponent=8000
9F56:	mov	0002(sp),r0	;pointer to the DEST
9F5A:	trap	2C		;push a number pointed to by R0 on the stack
; linear approximation SQR(X) = X*0.590+0.417 for X in range 0.5 to 1
9F5C:	mov	#9FC8,r1	;constant 0.5901620695
9F60:	trap	18		;MULF
9F62:	mov	0008(sp),r0
9F66:	mov	#9FC2,r1	;constant 0.4173075990
9F6A:	trap	10		;ADDF
; do three times the Newton's iteration
9F6C:	trap	30		;M.APPR
9F6E:	trap	30		;M.APPR
9F70:	trap	30		;M.APPR
9F72:	add	6(sp),4(r0)	;add saved exponent to the DEST exponent
9F78:	add	#8,sp
9F7C:	tst	0002(sp)	;was odd_flag set?
9F80:	beq	9F88		;skip if not
9F82:	mov	#9FBC,r1	;constant SQR(2)
9F86:	trap	18		;MULF, multiply DEST by SQR(2)
9F88:	tst	0004(sp)	;neg_flag set?
9F8C:	beq	9F90		;skip if not
9F8E:	trap	FD		;error 126 - negative radicand
9F90:	add	#6,sp
9F94:	clear	v
9F96:	rts	pc

; trap 30 - M.APPR, approximation of the form .5(Y0+X/Y0)
9F98:	mov	sp,r0
9F9A:	tst	(r0)+
9F9C:	trap	2C		;push a number pointed to by R0 on the stack
9F9E:	mov	sp,r0
9FA0:	mov	0010(sp),r1
9FA4:	trap	16		;DIVF
9FA6:	mov	sp,r1
9FA8:	mov	0010(sp),r0
9FAC:	trap	10		;ADDF, X=X0/X+X
9FAE:	mov	0010(sp),r0
9FB2:	dec	0004(r0)	;decrement exponent of X
9FB6:	add	#6,sp
9FBA:	rts	pc

9FBC:	.word	7996, 5A82, 8001	;1.4142135587 = SQR (2)
9FC2:	.word	ABBA, 6AD4, 7FFF	;0.4173075990
9FC8:	.word	6E42, 4B8A, 8000	;0.5901620695

; End of code borrowed from the RT-11 operating system.


; start the BASIC system
9FCE:	mov	#200,sp
9FD2:	mov	#100,r2
9FD6:	clr	-(r2)
9FD8:	mov	#8000,-(r2)
9FDC:	tst	r2
9FDE:	bne	9FD6
9FE0:	mov	#005F,(r2)+
9FE4:	mov	#9FCE,(r2)+	;vector of the BASIC system start
9FE8:	mov	#808A,@#1C	;vector TRAP
9FEE:	jsr	pc,CA6C		;RAM initialisation
9FF2:	trap	6C
9FF4:	trap	02		;print CR, LF
9FF6:	mov	#3F3E,r1
9FFA:	mov	#9AA2,r0	;string 'BASIC V2.0 (c) 1987'
9FFE:	trap	36		;print a string pointed to by r0
A000:	mov	r1,sp
A002:	mov	r1,0D00
A006:	mov	#F58,r1
A00A:	mov	r1,0EF2
A00E:	mov	r1,r5
A010:	movb	#A,(r5)+
A014:	clr	0F00
A018:	jmp	86DA

; display character r2
A01C:	cmpb	#20,r2
A020:	blos	A026		;branch if a printable character
A022:	jsr	pc,A42E
A026:	jsr	pc,A3F0
A02A:	jsr	pc,A06E
A02E:	cmp	0D46,0D54
A034:	ble	A046
A036:	clr	0D46
A03A:	mov	#A04A,-(sp)
A03E:	jsr	pc,A04C		;save registers on the stack
A042:	jmp	A47C
A046:	jsr	pc,A3F0
A04A:	rts	pc

; save registers on the stack
A04C:	mov	r4,-(sp)
A04E:	mov	r3,-(sp)
A050:	mov	r2,-(sp)
A052:	mov	r1,-(sp)
A054:	mov	r0,-(sp)
A056:	mov	000A(sp),-(sp)
A05A:	mov	r5,000C(sp)
A05E:	rts	pc

; restore registers from the stack
A060:	mov	(sp)+,r5
A062:	mov	(sp)+,r0
A064:	mov	(sp)+,r1
A066:	mov	(sp)+,r2
A068:	mov	(sp)+,r3
A06A:	mov	(sp)+,r4
A06C:	rts	r5

A06E:	jsr	pc,A04C		;save registers on the stack
A072:	bit	#10,0D5C
A078:	beq	A08A
A07A:	bit	#80,r2
A07E:	beq	A08A
A080:	bic	#80,r2
A084:	mov	0C44,0C48
A08A:	cmpb	r2,#20
A08E:	bge	A094
A090:	jmp	A2F2
A094:	tst	0C50
A098:	bne	A0A6
A09A:	bit	#20,0D5C
A0A0:	bne	A0A6
A0A2:	jmp	A2F2
A0A6:	movb	r2,r1
A0A8:	mov	0D4C,0D56
A0AE:	mov	0C3C,r5		;height of a character in pixels
A0B2:	mov	0D46,-(sp)
A0B6:	mov	0C50,-(sp)
A0BA:	mov	#D68,r4
A0BE:	mov	r1,-(sp)
A0C0:	cmpb	r1,#3F
A0C4:	ble	A0D2
A0C6:	mov	#40,r3
A0CA:	mov	0C48,0C46
A0D0:	br	A0DC
;
A0D2:	mov	#20,r3
A0D6:	mov	#F9CE,0C46	;font table
A0DC:	sub	r3,r1
A0DE:	mul	0C40,r1		;number of bits for each character
A0E2:	movb	0D56,r3
A0E6:	mul	0C3E,r3		;width of a character in pixels
A0EA:	add	r1,r3
A0EC:	clr	r2
A0EE:	div	#8,r2
A0F2:	clr	r1
A0F4:	add	0C46,r2
A0F8:	bisb	(r2)+,r1
A0FA:	swab	r1
A0FC:	bisb	(r2),r1
A0FE:	add	0C3E,r3		;width of a character in pixels
A102:	sub	#8,r3
A106:	ash	r3,r1
A108:	swab	r1
A10A:	mov	#8,r3
A10E:	sub	0C3E,r3		;width of a character in pixels
A112:	ash	r3,r1
A114:	tst	0D5A
A118:	beq	A148
A11A:	cmp	0D5A,#2
A120:	blt	A138
A122:	clr	r0
A124:	mov	0C3E,r3		;width of a character in pixels
A128:	aslb	r1
A12A:	rorb	r0
A12C:	sob	r3,A128
A12E:	mov	r0,r1
A130:	cmp	#2,0D5A
A136:	beq	A148
A138:	mov	#D68,r4
A13C:	mov	0C3E,r3		;width of a character in pixels
A140:	rolb	r1
A142:	rolb	(r4)+
A144:	sob	r3,A140
A146:	br	A14A
A148:	movb	r1,(r4)+
A14A:	add	0C4E,0D56
A150:	mov	(sp)+,r1
A152:	dec	r5
A154:	beq	A15A
A156:	jmp	A0BE
A15A:	bit	#1,0D5A
A160:	bne	A16C
A162:	mov	0C3C,r5		;height of a character in pixels
A166:	mov	0C3E,r4		;width of a character in pixels
A16A:	br	A180
A16C:	mov	#8,r3
A170:	mov	#D68,r4
A174:	aslb	(r4)+
A176:	sob	r3,A174
A178:	mov	0C3E,r5		;width of a character in pixels
A17C:	mov	0C3C,r4		;height of a character in pixels
A180:	bit	#1,0D5C
A186:	beq	A194
A188:	mov	#4,r3
A18C:	mov	#D68,r2
A190:	com	(r2)+
A192:	sob	r3,A190
A194:	inc	r5
A196:	mov	#D68,r3
A19A:	mov	r4,-(sp)
A19C:	movb	(r3)+,r1
A19E:	mov	r3,-(sp)
A1A0:	mov	0D46,-(sp)
A1A4:	mov	#8,-(sp)
A1A8:	mov	r1,r0
A1AA:	clr	r1
A1AC:	mov	0C5A,r3
A1B0:	bic	#FF00,r0
A1B4:	asl	r0
A1B6:	asl	r1
A1B8:	bis	r0,r1
A1BA:	clrb	r1
A1BC:	dec	(sp)
A1BE:	bgt	A212
A1C0:	mov	#FF00,0D64
A1C6:	mov	0C50,(sp)
A1CA:	cmp	#1,r5
A1CE:	bne	A1D6
A1D0:	mov	#1,r2
A1D4:	br	A1DA
A1D6:	mov	0C58,r2
A1DA:	cmp	0C50,0D14
A1E0:	blt	A1F6
A1E2:	mov	0D14,0C50
A1E8:	dec	0C50
A1EC:	dec	(sp)
A1EE:	jsr	pc,A54C
A1F2:	inc	0DAA
A1F6:	jsr	pc,A31E		;plot a dot
A1FA:	inc	0C50
A1FE:	sob	r2,A1DA
A200:	mov	(sp)+,0C50
A204:	tst	r4
A206:	beq	A246
A208:	mov	#8,-(sp)
A20C:	add	(sp),0D46
A210:	clr	r1
A212:	sob	r3,A1B6
A214:	sob	r4,A1AC
A216:	bic	#FF00,r0
A21A:	asl	r0
A21C:	asl	r1
A21E:	bis	r0,r1
A220:	clrb	r1
A222:	tst	(sp)
A224:	beq	A1C0
A226:	dec	(sp)
A228:	beq	A1C0
A22A:	mov	(sp),r3
A22C:	neg	r3
A22E:	add	#8,r3
A232:	mov	#FF,r2
A236:	sec
A238:	ror	r2
A23A:	sob	r3,A238
A23C:	clrb	r2
A23E:	mov	r2,0D64
A242:	ash	(sp),r1
A244:	br	A1C6
A246:	add	0C58,0C50
A24C:	mov	(sp)+,0D46
A250:	mov	(sp)+,r3
A252:	mov	(sp),r4
A254:	dec	r5
A256:	beq	A25C
A258:	jmp	A19C
A25C:	tst	(sp)+
A25E:	bit	#1,0D58
A264:	beq	A2B6
A266:	tst	(sp)+
A268:	sub	0C58,0C50
A26E:	tst	0DAA
A272:	beq	A28E
A274:	clr	0DAA
A278:	mov	0C54,r4
A27C:	jsr	pc,A54C
A280:	sob	r4,A27C
A282:	mov	0D14,0C50
A288:	sub	0C54,0C50
A28E:	mov	(sp)+,0D46
A292:	cmp	#1,0D58
A298:	bne	A2A2
A29A:	add	0C54,0C50
A2A0:	br	A2F2
A2A2:	sub	0D50,0C50
A2A8:	sub	0D50,0C50
A2AE:	add	0C54,0C50
A2B4:	br	A2F2
A2B6:	mov	(sp)+,0C50
A2BA:	tst	0DAA
A2BE:	beq	A2DE
A2C0:	clr	0DAA
A2C4:	mov	0C54,r4
A2C8:	dec	r4
A2CA:	beq	A2D2
A2CC:	jsr	pc,A54C
A2D0:	br	A2C8
A2D2:	mov	0D14,0C50
A2D8:	sub	0D50,0C50
A2DE:	tst	0D58
A2E2:	bne	A2EA
A2E4:	add	0D4E,(sp)
A2E8:	br	A2EE
A2EA:	sub	0D4E,(sp)
A2EE:	mov	(sp)+,0D46
A2F2:	mov	#D68,r4
A2F6:	mov	#4,r3
A2FA:	clr	(r4)+
A2FC:	sob	r3,A2FA
A2FE:	jsr	pc,A060		;restore registers from the stack
A302:	mov	#FF00,0D64
A308:	rts	pc
A30A:	tst	0F00
A30E:	beq	A31E		;plot a dot
A310:	mov	0DC6,sp
A314:	mov	0DCA,r5
A318:	mov	0DCE,r1
A31C:	rts	pc

; plot a dot
A31E:	bic	#FFF0,0C56
A324:	cmp	#4,0C56
A32A:	blt	A3C2
A32C:	bit	#40,0D5C	;screen or plotter?
A332:	beq	A346
; plotter
A334:	mov	0D46,0E0E
A33A:	mov	0C50,0E10
A340:	jsr	pc,78EE
A344:	br	A3C2
; screen
A346:	jsr	pc,A04C		;save registers on the stack
A34A:	mov	0C50,r3		;coordinate Y
A34E:	cmp	r3,0D14		;height of the screen in pixels
A352:	bhis	A3BE		;out of the screen
A354:	mov	0D46,r5		;coordinate X
A358:	cmp	r5,0D16		;width of the screen in pixels
A35C:	bhis	A3BE		;out of the screen
A35E:	mov	0D1C,r0
A362:	sub	0D46,r0
A366:	bpl	A372
A368:	sub	#8,r0
A36C:	ash	r0,r1
A36E:	neg	r0
A370:	ash	r0,r1
A372:	clr	r4
A374:	clr	r2
A376:	div	#20,r2
A37A:	div	#8,r4
A37E:	mul	#F,r3
A382:	add	r4,r3
A384:	asl	r3
A386:	add	r2,r3
A388:	mov	r5,r0
A38A:	clr	r5
A38C:	mov	r3,r2
A38E:	add	0D02,r2		;address of the display RAM
A392:	bisb	(r2),r5
A394:	swab	r5
A396:	bisb	0002(r2),r5
A39A:	ashc	r0,r4
A39C:	bic	#FF,r1
A3A0:	clr	r2
A3A2:	movb	0C56,r2
A3A6:	asl	r2
A3A8:	jsr	pc,@A3DE(r2)
A3AC:	neg	r0
A3AE:	ashc	r0,r4
A3B0:	add	0D02,r3		;address of the display RAM
A3B4:	movb	r5,0002(r3)
A3B8:	swab	r5
A3BA:	movb	r5,(r3)
A3BC:	clc
A3BE:	jsr	pc,A060		;restore registers from the stack
A3C2:	rts	pc

A3C4:	bic	r1,r5
A3C6:	rts	pc

A3C8:	bic	0D64,r5
A3CC:	bis	r1,r5
A3CE:	rts	pc

A3D0:	xor	r1,r5
A3D2:	rts	pc

A3D4:	clr	r1
A3D6:	bis	r5,r1
A3D8:	mov	r1,0004(sp)
A3DC:	rts	pc

; display modes
A3DE:	.word	A3C4
A3E0:	.word	A3C8
A3E2:	.word	A3D0
A3E4:	.word	A3CC
A3E6:	.word	A3D4

A3E8:	movb	(r1)+,(r4)+
A3EA:	cmpb	(r1)+,(r4)+
A3EC:	sob	r3,A3E8
A3EE:	rts	pc

A3F0:	tst	0D60
A3F4:	bne	A42C
A3F6:	mov	0D46,-(sp)
A3FA:	mov	0C50,-(sp)
A3FE:	movb	0C56,-(sp)
A402:	movb	#2,0C56
A408:	add	0D50,0C50
A40E:	sub	0C54,0C50
A414:	mov	r1,-(sp)
A416:	mov	#F800,r1
A41A:	jsr	pc,A31E		;plot a dot
A41E:	mov	(sp)+,r1
A420:	movb	(sp)+,0C56
A424:	mov	(sp)+,0C50
A428:	mov	(sp)+,0D46
A42C:	rts	pc

A42E:	cmpb	#E,r2
A432:	bne	A44A
A434:	mov	0C44,0C48
A43A:	bit	#10,0D5C
A440:	beq	A45A
A442:	mov	#80,0D44
A448:	br	A45A
A44A:	cmpb	#F,r2
A44E:	bne	A45C
A450:	mov	0C42,0C48
A456:	clr	0D44
A45A:	br	A4D0
A45C:	jsr	pc,A04C		;save registers on the stack
A460:	mov	#A476,r0
A464:	clr	r3
A466:	bisb	(r0)+,r3
A468:	beq	A4CC
A46A:	cmpb	r2,(r0)+
A46C:	bne	A464
A46E:	jsr	pc,A3F0
A472:	asl	r3
A474:	add	r3,pc

A476:	.byte	03 0A 14 0D 00 00

A47C:	cmp	0D52,0C50
A482:	bgt	A496
A484:	mov	0D50,r2
A488:	jsr	pc,A54C
A48C:	sob	r2,A488
A48E:	mov	0D52,0C50
A494:	br	A4C8
A496:	add	0D50,0C50
A49C:	br	A4C8
A49E:	clr	0D46
A4A2:	br	A4C8
A4A4:	sub	0D4E,0D46
A4AA:	bge	A4C6
A4AC:	mov	0D54,0D46
A4B2:	sub	0D50,0C50
A4B8:	cmp	#8,0C50
A4BE:	ble	A4C6
A4C0:	mov	0D52,0C50
A4C6:	rts	pc
A4C8:	jsr	pc,A3F0
A4CC:	jsr	pc,A060		;restore registers from the stack
A4D0:	tst	(sp)+
A4D2:	rts	pc

A4D4:	mov	r0,-(sp)
A4D6:	mov	r1,-(sp)
A4D8:	mov	0C58,r1
A4DC:	mul	0C4A,r1
A4E0:	add	0C54,r1
A4E4:	mov	r1,0D50
A4E8:	mov	0C5A,r1
A4EC:	mul	0C4C,r1
A4F0:	add	0C52,r1
A4F4:	mov	r1,0D4E
A4F8:	clr	r0
A4FA:	mov	0D14,r1
A4FE:	sub	#8,r1
A502:	div	0D50,r0
A506:	add	0D50,r1
A50A:	neg	r1
A50C:	add	0D14,r1
A510:	mov	r1,0D52
A514:	clr	r0
A516:	mov	0D16,r1
A51A:	div	0D4E,r0
A51E:	add	0D4E,r1
A522:	neg	r1
A524:	add	0D16,r1
A528:	mov	r1,0D54
A52C:	mov	(sp)+,r1
A52E:	mov	(sp)+,r0
A530:	rts	pc

A532:	jsr	pc,A3F0
A536:	jsr	pc,A4A4
A53A:	movb	#20,r2
A53E:	jsr	pc,A06E
A542:	jsr	pc,A4A4
A546:	jsr	pc,A3F0
A54A:	rts	pc
A54C:	bit	#40,0D5C	;screen or plotter?
A552:	beq	A55A
; plotter
A554:	jsr	pc,7AB0
A558:	rts	pc
; screen
A55A:	mov	r1,-(sp)
A55C:	mov	r3,-(sp)
A55E:	mov	r4,-(sp)
A560:	mov	0D16,r1
A564:	asr	r1
A566:	asr	r1
A568:	asr	r1
A56A:	mov	r1,-(sp)
A56C:	mov	0D1A,r3
A570:	dec	r3
A572:	mul	r1,r3
A574:	mov	r3,-(sp)
A576:	tst	0D5E
A57A:	bne	A588
A57C:	mov	0D16,r4
A580:	asl	r4
A582:	sub	0D16,r3
A586:	br	A58A
; display scroll
A588:	clr	r4
A58A:	add	0D02,r4		;address of the display RAM
A58E:	asl	r1
A590:	add	r4,r1
A592:	jsr	pc,A3E8
A596:	mov	0D02,r1		;address of the display RAM
A59A:	inc	r1
A59C:	mov	0002(sp),r3
A5A0:	jsr	pc,A3E8
A5A4:	mov	0D02,r4		;address of the display RAM
A5A8:	inc	r4
A5AA:	mov	(sp)+,r3
A5AC:	jsr	pc,A3E8
A5B0:	mov	(sp)+,r3
A5B2:	clrb	(r4)+
A5B4:	inc	r4
A5B6:	sob	r3,A5B2
A5B8:	mov	(sp)+,r4
A5BA:	mov	(sp)+,r3
A5BC:	mov	(sp)+,r1
A5BE:	rts	pc

; command AUTO
A5C0:	trap	46		;get a pair of integer numbers
A5C2:	tst	r3		;first number
A5C4:	bne	A5CA
A5C6:	mov	#A,r3		;default value 10 for the first number
A5CA:	mov	r3,0E8A
A5CE:	tst	r4		;second number
A5D0:	bne	A5E8
A5D2:	cmp	#2C,r2		;was a comma between the numbers?
A5D6:	bne	A5E4
A5D8:	tst	0E8C
A5DC:	beq	A5E4
A5DE:	mov	0E8C,r4
A5E2:	br	A5E8
A5E4:	mov	#A,r4		;default value 10 for the second number
A5E8:	mov	r4,0E8C
A5EC:	mov	#1,0D70
A5F2:	jmp	A79C

A5F6:	sub	#8,sp
A5FA:	mov	sp,r0
A5FC:	mov	0E8A,r1
A600:	trap	0A		;ITOA
A602:	mov	sp,r0
A604:	tst	(r0)+
A606:	clrb	0006(sp)
A60A:	mov	#E9E,r3		;input line buffer
A60E:	cmpb	#20,(r0)+
A612:	beq	A60E
A614:	dec	r0
A616:	movb	(r0),r2
A618:	movb	(r0)+,(r3)+
A61A:	beq	A620
A61C:	trap	00		;print character r2
A61E:	br	A616
A620:	dec	r3
A622:	add	0E8C,0E8A
A628:	add	#8,sp
A62C:	rts	pc

; command WAIT
A62E:	mov	#ABCA,r4	;evaluate the argument to the variable 0E86
A632:	mov	#1,r3		;number of arguments
A636:	jsr	pc,ACD6		;evaluate arguments to integer variables
A63A:	asl	r0
A63C:	mov	r0,0F14		;counter decremented at each EVNT interrupt
A640:	bis	#0010,@#EA16	;RTC register B, enable SQW
A646:	mov	#0057,@#EA14	;RTC register A,
				;DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
A64C:	tst	0F14		;counter decremented at each EVNT interrupt
A650:	ble	A658
A652:	tst	0F00
A656:	beq	A64C
A658:	bic	#10,@#EA16	;RTC register B, disable SQW
A65E:	mov	#41,@#EA14	;RTC register A,
				;DV=010 (OSC1=32768Hz), RS=0000 (SQW=none)
A664:	jmp	A79C

; command PLAY
A668:	mov	#ABCC,r4	;evaluate arguments to variables 0E86, 0E88
A66C:	mov	#2,r3		;number of arguments
A670:	jsr	pc,ACD6		;evaluate arguments to integer variables
A674:	cmp	#28,0E86
A67A:	bhis	A67E
A67C:	trap	3F		;error 31 - wrong note in the PLAY operator
A67E:	mov	0E86,r2
A682:	asl	r2
A684:	jsr	pc,A68C
A688:	jmp	A79C

; play a note specified in R2 of duration time specified in R0
A68C:	mov	r0,0F14		;counter decremented at each EVNT interrupt
A690:	mov	#57,@#EA14	;RTC register A,
				;DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
A696:	mov	A6E4(r2),@#E812
A69C:	mov	#FB,@#E814
A6A2:	clr	@#E816		;start of the transfer
A6A6:	jsr	pc,A6DC
A6AA:	bis	#10,@#EA16	;RTC register B, enable SQW
A6B0:	clr	@#E810		;transmit dummy data
A6B4:	jsr	pc,A6DC
A6B8:	tst	0F14		;counter decremented at each EVNT interrupt
A6BC:	ble	A6C0		;branch if specified time elapsed
A6BE:	br	A6B0
A6C0:	tst	@#E816		;end of the transfer
A6C4:	jsr	pc,A6DC
A6C8:	bic	#10,@#EA16	;RTC register B, disable SQW
A6CE:	mov	#73,@#E814
A6D4:	mov	#A2,@#E814
A6DA:	rts	pc

A6DC:	tstb	@#E814
A6E0:	bpl	A6DC
A6E2:	rts	pc

; tone frequency table, notes 0 (F4 = 349.23Hz) to 40 (A7 = 3520.0Hz)
; frequency = 800kHz / table_entry
A6E4:	.word	08F3, 0872, 07F9, 0786
A6EC:	.word	071A, 06B4, 0654, 05F9
A6F4:	.word	05A3, 0552, 0506, 04BD
A6FC:	.word	0479, 0439, 03FC, 03C3
A704:	.word	038D, 035A, 032A, 02FC
A70C:	.word	02D2, 02A9, 0283, 025F
A714:	.word	023D, 021D, 01FE, 01E2
A71C:	.word	01C7, 01AD, 0195, 017E
A724:	.word	0169, 0155, 0141, 012F
A72C:	.word	011E, 010E, 00FF, 00F1
A734:	.word	00E3

; command DIS
A736:	jsr	pc,A73C
A73A:	br	A79C

A73C:	mov	0D46,-(sp)
A740:	mov	0C50,-(sp)
A744:	jsr	pc,C236
A748:	clr	0D5E
A74C:	mov	(sp)+,0C50
A750:	mov	(sp)+,0D46
A754:	tst	0C50
A758:	bne	A764
A75A:	clr	0D46
A75E:	mov	#8,0C50
A764:	tst	0D60
A768:	beq	A772
A76A:	clr	0D60
A76E:	jsr	pc,A3F0
A772:	rts	pc

A774:	mov	0D02,r3		;address of the display RAM
A778:	mov	#01E0,r2	;size of the display RAM (03C0 bytes)
A77C:	clr	(r3)+
A77E:	sob	r2,A77C
A780:	bis	#20,0D5C
A786:	clr	0D46
A78A:	clr	0C50
A78E:	inc	0D5E
A792:	inc	0D60
A796:	rts	pc

; command CLS
A798:	jsr	pc,A774
A79C:	trap	48
A79E:	jmp	8664

; command LOCATE
A7A2:	mov	r1,-(sp)
A7A4:	jsr	pc,A3F0
A7A8:	mov	(sp)+,r1
A7AA:	mov	#2,r3		;number of arguments
A7AE:	mov	#ABD0,r4	;evaluate arguments to variables 0D46, 0C50
A7B2:	jsr	pc,ACD6		;evaluate arguments to integer variables
A7B6:	mov	r1,-(sp)
A7B8:	jsr	pc,A3F0
A7BC:	mov	(sp)+,r1
A7BE:	br	A79C
A7C0:	jsr	pc,A04C		;save registers on the stack
A7C4:	mov	#D76,r0
A7C8:	mov	#1,0E72
A7CE:	mov	#1,0E74
A7D4:	mov	0006(r0),r1
A7D8:	sub	0002(r0),r1
A7DC:	bge	A7E4
A7DE:	neg	0E72
A7E2:	neg	r1
A7E4:	mov	0008(r0),r2
A7E8:	sub	0004(r0),r2
A7EC:	bge	A7F4
A7EE:	neg	0E74
A7F2:	neg	r2
A7F4:	mov	r2,-(sp)
A7F6:	sub	r1,(sp)
A7F8:	ble	A80E
A7FA:	mov	0E72,r3
A7FE:	mov	0E74,0E72
A804:	mov	r3,0E74
A808:	mov	r2,r3
A80A:	mov	r1,r2
A80C:	mov	r3,r1
A80E:	mov	r2,r3
A810:	asl	r3
A812:	mov	r3,0E88
A816:	sub	r1,r3
A818:	mov	r3,0E84
A81C:	mov	r1,r3
A81E:	asl	r3
A820:	mov	r3,0E86
A824:	sub	0E88,0E86
A82A:	tst	(sp)
A82C:	ble	A83C
A82E:	mov	0002(r0),r5
A832:	mov	0004(r0),r4
A836:	mov	0008(r0),r3
A83A:	br	A848
A83C:	mov	0002(r0),r4
A840:	mov	0004(r0),r5
A844:	mov	0006(r0),r3
A848:	bit	#8,0D5C
A84E:	beq	A860
A850:	br	A864
A852:	bit	#8,0D5C
A858:	beq	A860
A85A:	jsr	pc,4812
A85E:	br	A864
A860:	jsr	pc,A88E
A864:	cmp	r4,r3
A866:	beq	A886
A868:	add	0E72,r4
A86C:	tst	0E84
A870:	bge	A87A
A872:	add	0E88,0E84
A878:	br	A852
A87A:	add	0E74,r5
A87E:	sub	0E86,0E84
A884:	br	A852
A886:	tst	(sp)+
A888:	jsr	pc,A060		;restore registers from the stack
A88C:	rts	pc
A88E:	tst	0002(sp)
A892:	ble	A89E
A894:	mov	r5,0D46
A898:	mov	r4,0C50
A89C:	br	A8A6
A89E:	mov	r4,0D46
A8A2:	mov	r5,0C50
A8A6:	movb	0C56,-(sp)
A8AA:	movb	0D74,0C56
A8B0:	mov	r1,-(sp)
A8B2:	mov	#8000,r1
A8B6:	jsr	pc,A30A
A8BA:	mov	(sp)+,r1
A8BC:	movb	(sp)+,0C56
A8C0:	rts	pc
A8C2:	jsr	pc,A8CA
A8C6:	jmp	9052
A8CA:	jsr	pc,A3F0
A8CE:	bis	#60,0D5C	;output to the plotter
A8D4:	mov	0D46,0E1C
A8DA:	mov	0C50,0E1E
A8E0:	mov	0E0E,0D46
A8E6:	mov	0E10,0C50
A8EC:	mov	0D2C,0D14
A8F2:	mov	0D2E,0D16
A8F8:	mov	#2,0C5A
A8FE:	jsr	pc,A4D4
A902:	inc	0D60
A906:	rts	pc
A908:	inc	0D62
A90C:	tst	0F20
A910:	beq	A916
A912:	clr	0C52
A916:	mov	#A91E,-(sp)
A91A:	jmp	AC14
A91E:	trap	3A		;get a character other than space to r2
A920:	cmpb	r2,#3E
A924:	beq	A92E
A926:	cmpb	r2,#3B
A92A:	beq	A916
A92C:	trap	39		;error 28 - illegal PRINT syntax
A92E:	tst	0F20
A932:	bne	A938
A934:	jmp	AA70
A938:	mov	r3,-(sp)
A93A:	mov	0D20,r3
A93E:	mul	#4,r3
A942:	mov	r3,0E22
A946:	asr	r3
A948:	mov	r3,0D28
A94C:	mul	#3,r3
A950:	mov	r3,0E24
A954:	asl	r3
A956:	mov	r3,0D24
A95A:	tst	0C52
A95E:	beq	A96C
A960:	mov	0C52,0D28
A966:	add	0C54,0D24
A96C:	mov	0E24,r3
A970:	add	0D28,r3
A974:	mov	r3,-(sp)
A976:	mov	0E22,r3
A97A:	asl	r3
A97C:	add	0D28,r3
A980:	mov	r3,-(sp)
A982:	mov	0D22,r3
A986:	sub	0D26,r3
A98A:	beq	AA68
A98C:	mov	0D22,r3
A990:	asl	r3
A992:	add	r3,pc
A994:	br	AA36
A996:	br	A9F6
A998:	br	A9CE
A99A:	cmp	0D26,#1
A9A0:	beq	A9B6
A9A2:	blt	A9C0
A9A4:	mov	0E22,0E24
A9AA:	mov	0002(sp),0E22
A9B0:	neg	0E22
A9B4:	br	AA68
A9B6:	mov	(sp),0E24
A9BA:	clr	0E22
A9BE:	br	AA68
A9C0:	mov	0E22,0E24
A9C6:	mov	0002(sp),0E22
A9CC:	br	AA68
A9CE:	cmp	0D26,#1
A9D4:	beq	A9E4
A9D6:	blt	A9EC
A9D8:	mov	0002(sp),0E24
A9DE:	neg	0E24
A9E2:	br	AA68
A9E4:	mov	0002(sp),0E24
A9EA:	br	AA68
A9EC:	mov	(sp),0E22
A9F0:	clr	0E24
A9F4:	br	AA68
A9F6:	cmp	0D26,#2
A9FC:	beq	AA0E
A9FE:	blt	AA24
AA00:	clr	0E22
AA04:	mov	(sp),0E24
AA08:	neg	0E24
AA0C:	br	AA68
AA0E:	mov	0E22,0E24
AA14:	neg	0E24
AA18:	mov	0002(sp),0E22
AA1E:	neg	0E22
AA22:	br	AA68
AA24:	mov	0E22,0E24
AA2A:	neg	0E24
AA2E:	mov	0002(sp),0E22
AA34:	br	AA68
AA36:	cmp	0D26,#2
AA3C:	beq	AA50
AA3E:	blt	AA5E
AA40:	neg	0E22
AA44:	mov	0002(sp),0E24
AA4A:	neg	0E24
AA4E:	br	AA68
AA50:	mov	(sp),0E22
AA54:	neg	0E22
AA58:	clr	0E24
AA5C:	br	AA68
AA5E:	neg	0E22
AA62:	mov	0002(sp),0E24
AA68:	tst	(sp)+
AA6A:	tst	(sp)+
AA6C:	mov	(sp)+,r3
AA6E:	rts	pc
AA70:	jsr	pc,A3F0
AA74:	tst	0C58
AA78:	bne	AA80
AA7A:	mov	#1,0C58
AA80:	tst	0C5A
AA84:	bne	AA8C
AA86:	mov	#1,0C5A
AA8C:	jsr	pc,A4D4
AA90:	jsr	pc,A3F0
AA94:	rts	pc

AA96:	clr	0D62
AA9A:	bic	#10,0D5C
AAA0:	tst	0F20
AAA4:	beq	AAC0
AAA6:	mov	#2,0D20
AAAC:	mov	#18,0D24
AAB2:	mov	#4,0D28
AAB8:	clr	0D26
AABC:	clr	0D22
AAC0:	jsr	pc,A3F0
AAC4:	mov	#1,0C58
AACA:	mov	#1,0C5A
AAD0:	clr	0D58
AAD4:	clr	0D5A
AAD8:	movb	#1,0C56
AADE:	mov	#1,0C4E
AAE4:	clr	0D4C
AAE8:	bic	#1,0D5C
AAEE:	mov	0C3C,0C4A	;height of a character in pixels
AAF4:	mov	0C3E,0C4C	;width of a character in pixels
AAFA:	mov	#1,0C52
AB00:	mov	#1,0C54
AB06:	bit	#40,0D5C	;screen or plotter?
AB0C:	beq	AB40
; plotter
AB0E:	clr	0D60
AB12:	mov	0D46,0E0E
AB18:	mov	0C50,0E10
AB1E:	mov	0E1C,0D46
AB24:	mov	0E1E,0C50
AB2A:	mov	#40,0D14
AB30:	mov	#78,0D16
AB36:	bic	#40,0D5C	;set output to the screen
AB3C:	jsr	pc,A3F0
; screen
AB40:	jsr	pc,A4D4
AB44:	jsr	pc,A3F0
AB48:	rts	pc

AB4A:	mov	#D78,r3
AB4E:	movb	#3,0D74
AB54:	mov	r1,-(sp)
AB56:	mov	r3,r4
AB58:	cmp	(r4)+,(r4)+
AB5A:	mov	#2,r2
AB5E:	mov	#2,r0
AB62:	mov	(r4),r1
AB64:	mov	(r3),(r4)
AB66:	jsr	pc,A7C0
AB6A:	mov	r1,(r4)+
AB6C:	tst	(r3)+
AB6E:	sob	r0,AB62
AB70:	mov	r3,r4
AB72:	cmp	-(r4),-(r4)
AB74:	sob	r2,AB5E
AB76:	mov	(sp)+,r1
AB78:	rts	pc

; evaluate an arithmetical expression to an integer in R0
AB7A:	trap	3A		;get a character other than space to r2
AB7C:	dec	r1
AB7E:	cmpb	r2,#3A		;colon?
AB82:	beq	ABC4
AB84:	cmpb	r2,#A		;end of the line?
AB88:	beq	ABC4
AB8A:	mov	r3,-(sp)
AB8C:	mov	r4,-(sp)
AB8E:	trap	5E		;evaluate an arithmetical expression
AB90:	trap	20		;FIX
AB92:	mov	(sp)+,r4
AB94:	mov	(sp)+,r3
AB96:	trap	3A		;get a character other than space to r2
AB98:	cmpb	r2,#2C		;comma?
AB9C:	beq	ABC0
AB9E:	cmpb	r2,#3A		;colon?
ABA2:	beq	ABBE
ABA4:	cmpb	r2,#A		;end of the line?
ABA8:	beq	ABBE
ABAA:	tst	0D62
ABAE:	beq	ABBC
ABB0:	cmpb	r2,#3B		;semicolon?
ABB4:	beq	ABBE
ABB6:	cmpb	r2,#3E		;'>'
ABBA:	beq	ABBE
ABBC:	trap	39		;error 28 - wrong PRINT syntax
ABBE:	dec	r1
ABC0:	clc
ABC2:	rts	pc
ABC4:	dec	r1
ABC6:	sec
ABC8:	rts	pc

; addresses of integer variables to which arguments of various commands are
; evaluated
ABCA:	.word	0E86			;WAIT
ABCC:	.word	0E86, 0E88		;PLAY
ABD0:	.word	0D46, 0C50		;LOCATE
ABD4:	.word	0C58, 0C5A
ABD8:	.word	0D20
ABDA:	.word	0D5A
ABDC:	.word	0D22
ABDE:	.word	0C52, 0C54
ABE2:	.word	0D58
ABE4:	.word	0D26
ABE6:	.word	0D46, 0C50
ABEA:	.word	0E0E, 0E10
ABEE:	.word	0E84, 0E86, 0E88
ABF4:	.word	0E84, 0E86, 0E88
ABFA:	.word	0D7A, 0D7C, 0D78

; command DRAW
AC00:	mov	r3,-(sp)
AC02:	mov	0D46,0D4A
AC08:	mov	0C50,0D48
AC0E:	bis	#80,0D5C
AC14:	trap	3A		;get a character other than space to r2
AC16:	mov	#AC4C,r0
AC1A:	clr	r3		;those two instructions could be replaced...
AC1C:	bis	(r0)+,r3	;...with a single MOV (R0)+,R3
AC1E:	bne	AC22
AC20:	trap	3B		;error 29 - wrong DRAW function
AC22:	cmp	r2,(r0)+
AC24:	bne	AC1A
AC26:	asl	r3
AC28:	tst	0D62
AC2C:	bne	AC4A
AC2E:	mov	sp,0DC6
AC32:	mov	r1,0DCE
AC36:	mov	r5,0DCA
AC3A:	bit	#40,0D5C	;screen or plotter?
AC40:	bne	AC4A		;skip if plotter
; screen
AC42:	mov	#AC8E,-(sp)
AC46:	mov	sp,0DC6
AC4A:	add	r3,pc

; offset to the handler routine, command code
AC4C:	.word	008D, 'O'	;AC4C+2*008D = AD66
	.word	014F, 'H'	;AC4C+2*014F = AEEA
	.word	0127, 'D'	;AC4C+2*0127 = AE9A
	.word	015F, 'E'	;AC4C+2*015F = AF0A
	.word	0099, 'I'	;AC4C+2*0099 = AD7E
	.word	00D1, 'A'	;AC4C+2*00D1 = ADEE
	.word	0164, 'C'	;AC4C+2*0164 = AF14
	.word	0174, 'X'	;AC4C+2*0174 = AF34
	.word	01D3, 'G'	;AC4C+2*01D3 = AFF2
	.word	0036, 'S'	;AC4C+2*0036 = ACB8
	.word	005B, 'Q'	;AC4C+2*005B = AD02
	.word	004C, 'Z'	;AC4C+2*004C = ACE4
	.word	0051, 'Y'	;AC4C+2*0051 = ACEE
	.word	00E0, 'M'	;AC4C+2*00E0 = AE0C
	.word	00C1, 'N'	;AC4C+2*00C1 = ADCE
	.word	00C9, 'P'	;AC4C+2*00C9 = ADDE
	.word	0000		;end marker

AC8E:	mov	(sp)+,r3
AC90:	mov	0D4A,0D46
AC96:	mov	0D48,0C50
AC9C:	bic	#80,0D5C
ACA2:	trap	48
ACA4:	tst	0F00
ACA8:	beq	ACB4
ACAA:	add	#C,0D46
ACB0:	jmp	86BE
ACB4:	jmp	8664

; graphic command 'S'
ACB8:	mov	#ABD4,r4	;evaluate arguments to variables 0C58, 0C5A
ACBC:	mov	#2,r3		;number of arguments
ACC0:	tst	0F20
ACC4:	beq	ACCE
ACC6:	mov	#ABD8,r4	;evalueate the argument to the variable 0D20
ACCA:	mov	#1,r3		;number of arguments
ACCE:	tst	0D62
ACD2:	bne	ACD6
ACD4:	trap	3B		;error 29 - wrong DRAW function
; evaluate arguments to integer variables
; number of arguments in R3
; addresses of integer variables pointed to by R4
ACD6:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
ACDA:	bhis	ACDE
ACDC:	trap	3D		;error 30 - wrong parameters
ACDE:	mov	r0,@(r4)+
ACE0:	sob	r3,ACD6
ACE2:	rts	pc

; graphic command 'Z'
ACE4:	mov	#ABDE,r4	;evaluate arguments to variables 0C52, 0C54
ACE8:	mov	#2,r3		;number of arguments
ACEC:	br	ACCE

; graphic command 'Y'
ACEE:	mov	#ABE2,r4	;evaluate the argument to the variable 0D58
ACF2:	tst	0F20
ACF6:	beq	ACFC
ACF8:	mov	#ABE4,r4	;evaluate the argument to the variable 0D26
ACFC:	mov	#1,r3		;number of arguments
AD00:	br	ACCE

; graphic command 'Q'
AD02:	mov	#ABDA,r4	;evaluate the argument to the variable 0D5A
AD06:	mov	#1,r3		;number of variables
AD0A:	jsr	pc,ACCE
AD0E:	bic	#FFFC,0D5A
AD14:	tst	0F20
AD18:	beq	AD22
AD1A:	mov	0D5A,0D22
AD20:	rts	pc
AD22:	bit	#1,0D5A
AD28:	bne	AD38
AD2A:	mov	0C3E,0C4C	;width of a character in pixels
AD30:	mov	0C3C,0C4A	;height of a character in pixels
AD36:	br	AD44
AD38:	mov	0C3C,0C4C	;height of a character in pixels
AD3E:	mov	0C3E,0C4A	;width of a character in pixels
AD44:	mov	#1,0C4E
AD4A:	clr	0D4C
AD4E:	cmp	#2,r0
AD52:	blt	AD64
AD54:	beq	AD5A
AD56:	tst	r0
AD58:	beq	AD64
AD5A:	mov	#6,0D4C
AD60:	neg	0C4E
AD64:	rts	pc

; graphic command 'O' - set the current screen position
AD66:	bit	#40,0D5C	;screen or plotter?
AD6C:	beq	AD74
; plotter
AD6E:	mov	#ABEA,r4	;evaluate arguments to variables 0E0E, 0E10
AD72:	br	AD78
; screen
AD74:	mov	#ABE6,r4	;evaluate arguments to variables 0D46, 0C50
AD78:	mov	#2,r3		;number of arguments
AD7C:	br	ACD6		;evaluate arguments to integer variables

; graphic command 'I' - draw a line specified by relative coordinates
AD7E:	mov	#D78,-(sp)
AD82:	mov	(sp),r3
AD84:	mov	0D46,(r3)+
AD88:	mov	0C50,(r3)+
AD8C:	mov	#2,r4		;number of arguments
AD90:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
AD94:	blo	ADCC
AD96:	mov	r0,(r3)+
AD98:	sob	r4,AD90
AD9A:	mov	(sp),r3
AD9C:	add	(r3),0004(r3)
ADA0:	add	0002(r3),0006(r3)
ADA6:	movb	#3,0D74
ADAC:	jsr	pc,A7C0
ADB0:	mov	0004(r3),(r3)
ADB4:	mov	0006(r3),0002(r3)
ADBA:	cmp	(r3)+,(r3)+
ADBC:	mov	#2,r4
ADC0:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
ADC4:	blo	ADC8
ADC6:	br	AD96
ADC8:	tst	(sp)+
ADCA:	rts	pc
ADCC:	trap	3D		;error 30 - wrong parameters

; graphic command 'N' - inverted print mode (white on black)
ADCE:	tst	0D62
ADD2:	bne	ADD6
ADD4:	trap	3B		;error 29 - wrong DRAW function
ADD6:	bis	#1,0D5C
ADDC:	rts	pc

; graphic command 'P' - normal print mode (black on white)
ADDE:	tst	0D62
ADE2:	bne	ADE6
ADE4:	trap	3B		;error 29 - wrong DRAW function
ADE6:	bic	#1,0D5C
ADEC:	rts	pc

; graphic command 'A' - draw a rectangle
ADEE:	mov	r1,-(sp)
ADF0:	mov	#D78,r3
ADF4:	mov	#4,r4		;number of arguments
ADF8:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
ADFC:	blo	AE0A
ADFE:	mov	r0,(r3)+
AE00:	sob	r4,ADF8
AE02:	jsr	pc,AB4A
AE06:	mov	(sp)+,r1
AE08:	rts	pc
AE0A:	trap	3D		;error 30 - wrong parameters

; graphic command 'M' - draw a bitmap specified with hexadecimal numbers
AE0C:	mov	#2,r3
AE10:	clr	r2
AE12:	clr	r4
AE14:	bis	r2,r4
AE16:	trap	3A		;get a character other than space to r2
AE18:	cmpb	r2,#A
AE1C:	beq	AE24
AE1E:	cmpb	r2,#3A
AE22:	bne	AE34
AE24:	cmp	#2,r3
AE28:	bne	AE2E
AE2A:	dec	r1
AE2C:	br	AE98
AE2E:	dec	r1
AE30:	clr	r2
AE32:	br	AE52
AE34:	sub	#30,r2
AE38:	bmi	AE98
AE3A:	cmp	r2,#9
AE3E:	ble	AE50
AE40:	sub	#7,r2
AE44:	cmp	r2,#F
AE48:	bhi	AE98
AE4A:	cmp	r2,#A
AE4E:	blt	AE98
AE50:	sob	r3,AE14
AE52:	mov	#4,r3
AE56:	asl	r4
AE58:	sob	r3,AE56
AE5A:	bis	r2,r4
AE5C:	swab	r4
AE5E:	mov	r1,-(sp)
AE60:	mov	r4,r1
AE62:	cmp	0D14,0C50
AE68:	bgt	AE74
AE6A:	clr	0C50
AE6E:	add	#8,0D46
AE74:	movb	0C56,-(sp)
AE78:	movb	#2,0C56
AE7E:	jsr	pc,A30A
AE82:	mov	(sp)+,0C56
AE86:	mov	(sp)+,r1
AE88:	inc	0C50
AE8C:	cmpb	(r1),#A
AE90:	beq	AE98
AE92:	cmpb	(r1),#3A
AE96:	bne	AE0C
AE98:	rts	pc

; graphic command 'D' - draw a line specified by absolute coordinates
AE9A:	movb	#3,0D74
AEA0:	mov	#D78,r3
AEA4:	mov	#2,r4
AEA8:	mov	0D46,(r3)+
AEAC:	mov	0C50,(r3)+
AEB0:	sob	r4,AEA8
AEB2:	mov	#D78,r3
AEB6:	mov	#4,r4
AEBA:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
AEBE:	bhis	AEC8
AEC0:	cmp	#2,r4
AEC4:	beq	AECC
AEC6:	trap	3D		;error 30 - wrong parameters
AEC8:	mov	r0,(r3)+
AECA:	sob	r4,AEBA
AECC:	jsr	pc,A7C0
AED0:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
AED4:	blo	AEE8
AED6:	mov	#D78,r3
AEDA:	mov	0D46,(r3)+
AEDE:	mov	0C50,(r3)+
AEE2:	mov	#2,r4
AEE6:	br	AEC8
AEE8:	rts	pc

; graphic command 'H' - plot a dot
AEEA:	jsr	pc,AD74
AEEE:	movb	0C56,-(sp)
AEF2:	mov	r1,-(sp)
AEF4:	movb	#3,0C56
AEFA:	mov	#8000,r1
AEFE:	jsr	pc,A31E		;plot a dot
AF02:	mov	(sp)+,r1
AF04:	movb	(sp)+,0C56
AF08:	rts	pc

; graphic command 'E' - erase a dot or a line
AF0A:	clrb	0D74
AF0E:	jsr	pc,AEB2
AF12:	rts	pc

; graphic command 'C' - draw a circle
AF14:	clr	0D76
AF18:	mov	#D7E,0E86
AF1E:	mov	#ABFA,r4	;evaluate argum. to variables 0D7A, 0D7C, 0D78
AF22:	mov	#3,r3		;number of arguments
AF26:	jsr	pc,ACD6		;evaluate arguments to integer variables
AF2A:	jmp	B964

AF2E:	.word	0000, 4000, 8000

; graphic command 'X' - draw the coordinate axes
AF34:	mov	r1,-(sp)
AF36:	mov	0D46,-(sp)
AF3A:	mov	0C50,-(sp)
AF3E:	mov	#ABEE,r4	;evaluate argum. to variables 0E84, 0E86, 0E88
AF42:	mov	#3,r3		;number of arguments
AF46:	jsr	pc,ACD6		;evaluate arguments to integer variables
AF4A:	bic	#FFFC,0E84
AF50:	mov	0E84,-(sp)
AF54:	mov	0E86,r3
AF58:	mov	r0,r4
AF5A:	mov	r0,r1
AF5C:	mul	r3,r1
AF5E:	mov	#D78,r2
AF62:	mov	0D46,(r2)+
AF66:	mov	0C50,(r2)+
AF6A:	mov	0D46,(r2)+
AF6E:	mov	0C50,(r2)
AF72:	bit	#1,(sp)
AF76:	beq	AF7A
AF78:	tst	-(r2)
AF7A:	tst	(sp)
AF7C:	beq	AF84
AF7E:	cmp	#3,(sp)
AF82:	bne	AF86
AF84:	neg	r1
AF86:	add	r1,(r2)
AF88:	movb	#3,0D74
AF8E:	jsr	pc,A7C0
AF92:	mov	(sp)+,r0
AF94:	mov	#8000,r1
AF98:	mov	#D78,r2
AF9C:	cmp	0D46,(r2)+
AFA0:	ble	AFA8
AFA2:	mov	FFFE(r2),0D46
AFA8:	cmp	0C50,(r2)
AFAC:	ble	AFB2
AFAE:	mov	(r2),0C50
AFB2:	inc	r4
AFB4:	movb	0C56,-(sp)
AFB8:	movb	#3,0C56
AFBE:	bit	#1,r0
AFC2:	bne	AFD4
AFC4:	inc	0D46
AFC8:	jsr	pc,A30A
AFCC:	add	r3,0C50
AFD0:	sob	r4,AFC8
AFD2:	br	AFE2
AFD4:	dec	0C50
AFD8:	jsr	pc,A30A
AFDC:	add	r3,0D46
AFE0:	sob	r4,AFD8
AFE2:	movb	(sp)+,0C56
AFE6:	mov	(sp)+,0C50
AFEA:	mov	(sp)+,0D46
AFEE:	mov	(sp)+,r1
AFF0:	rts	pc

; graphic command 'G' - draw horizontal or vertical stripes
AFF2:	mov	#ABF4,r4	;evaluate argum. to variables 0E84, 0E86, 0E88
AFF6:	mov	#3,r3		;number of arguments
AFFA:	jsr	pc,ACD6		;evaluate arguments to integer variables
AFFE:	bic	#FFFC,0E84
B004:	mov	0E84,-(sp)
B008:	mov	0E86,r4
B00C:	mov	#D78,r3
B010:	mov	0D46,(r3)
B014:	mov	(r3)+,-(sp)
B016:	mov	0C50,(r3)
B01A:	mov	(r3)+,-(sp)
B01C:	mov	0D46,(r3)
B020:	add	r4,(r3)
B022:	mov	(r3)+,-(sp)
B024:	mov	0C50,(r3)
B028:	add	r0,(r3)
B02A:	mov	(r3)+,-(sp)
B02C:	jsr	pc,AB4A
B030:	mov	#4,r4
B034:	mov	#D80,r3
B038:	mov	(sp)+,-(r3)
B03A:	sob	r4,B038
B03C:	tst	(sp)
B03E:	beq	B096
B040:	mov	#2,r2
B044:	mov	#D78,r3
B048:	mov	(r3),r4
B04A:	cmp	0004(r3),r4
B04E:	bge	B058
B050:	mov	0004(r3),(r3)
B054:	mov	r4,0004(r3)
B058:	tst	(r3)+
B05A:	sob	r2,B048
B05C:	mov	#D78,r3
B060:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
B064:	bhis	B06A
B066:	mov	#1,r0
B06A:	cmp	#1,(sp)
B06E:	bne	B07E
B070:	mov	0006(r3),r4
B074:	mov	0002(r3),0006(r3)
B07A:	tst	(r3)+
B07C:	br	B086
B07E:	mov	0004(r3),r4
B082:	mov	(r3),0004(r3)
B086:	add	r0,(r3)
B088:	cmp	(r3),r4
B08A:	bge	B096
B08C:	add	r0,0004(r3)
B090:	jsr	pc,A7C0
B094:	br	B086
B096:	tst	(sp)+
B098:	rts	pc

; command EDIT
B09A:	trap	46		;get a pair of integer numbers
B09C:	mov	r3,r0		;first number
B09E:	trap	3C
B0A0:	bvs	B0AA
B0A2:	cmp	r0,r2
B0A4:	beq	B0AE
B0A6:	tst	r0
B0A8:	beq	B0AE
B0AA:	jmp	86BE
B0AE:	bis	#10,0D5C
B0B4:	clr	0D42
B0B8:	clr	0D44
B0BC:	mov	r1,0E86
B0C0:	clr	0E88
B0C4:	mov	r1,-(sp)
B0C6:	jsr	pc,B222
B0CA:	mov	#28,0C50
B0D0:	clr	0D46
B0D4:	mov	#3F,r1
B0D8:	bis	#1,0D5C
B0DE:	mov	#B298,r3
B0E2:	movb	(r3)+,r2
B0E4:	jsr	pc,A01C		;display character r2
B0E8:	sob	r1,B0E2
B0EA:	mov	#20,r2
B0EE:	jsr	pc,A06E
B0F2:	mov	(sp)+,r1
B0F4:	bic	#1,0D5C
B0FA:	clr	0D46
B0FE:	mov	#8,0C50
B104:	clr	0D4A
B108:	mov	#8,0D48
B10E:	mov	#E9E,r3		;input line buffer
B112:	mov	#28,r2
B116:	mov	#2020,(r3)+
B11A:	sob	r2,B116
B11C:	mov	#E9E,r3		;input line buffer
B120:	movb	(r1)+,r2
B122:	bpl	B146
B124:	bic	#FF80,r2
B128:	mov	#8878,r0
B12C:	mov	r2,r4
B12E:	dec	r4
B130:	blt	B13A
B132:	cmpb	(r0)+,#24
B136:	bne	B132
B138:	br	B12E
B13A:	movb	(r0)+,r2
B13C:	cmpb	r2,#24
B140:	beq	B120
B142:	movb	r2,(r3)+
B144:	br	B13A
B146:	cmpb	#E,r2
B14A:	bne	B154
B14C:	movb	#80,0D44
B152:	br	B15E
B154:	cmpb	#F,r2
B158:	bne	B15E
B15A:	clr	0D44
B15E:	movb	r2,(r3)
B160:	cmpb	r2,#3F
B164:	ble	B16A
B166:	bisb	0D44,(r3)
B16A:	tstb	(r3)+
B16C:	cmpb	r2,#A
B170:	bne	B120
B172:	mov	r3,r4
B174:	movb	#20,-(r4)
B178:	clr	0E6C
B17C:	jsr	pc,B6FC
B180:	mov	r5,-(sp)
B182:	jsr	pc,C300
B186:	mov	(sp)+,r5
B188:	mov	#E9E,r0		;input line buffer
B18C:	mov	r4,r1
B18E:	sub	#E9E,r1		;input line buffer
B192:	cmp	r1,0E88
B196:	bge	B19C
B198:	mov	0E88,r1
B19C:	jsr	pc,B262
B1A0:	mov	#E9E,r3		;input line buffer
B1A4:	jsr	pc,A3F0
B1A8:	tst	0E26
B1AC:	beq	B1BE
B1AE:	mov	(sp)+,0C50
B1B2:	mov	(sp)+,0D46
B1B6:	mov	(sp)+,r3
B1B8:	clr	0E26
B1BC:	br	B1CA
B1BE:	mov	0D48,0C50
B1C4:	mov	0D4A,0D46
B1CA:	clr	0D60
B1CE:	jsr	pc,A3F0
B1D2:	jsr	pc,B2EE
B1D6:	jsr	pc,B200
B1DA:	jsr	pc,A774
B1DE:	jsr	pc,A73C
B1E2:	clr	0E6C
B1E6:	jsr	pc,B6FC
B1EA:	mov	#E9E,r1		;input line buffer
B1EE:	tst	0F00
B1F2:	beq	B1F8
B1F4:	jmp	86BE
B1F8:	mov	#86BE,-(sp)
B1FC:	jmp	871C
B200:	cmp	r3,r4
B202:	blos	B206
B204:	mov	r3,r4
B206:	movb	#A,(r4)+
B20A:	jsr	pc,A3F0
B20E:	mov	#E9E,r1		;input line buffer
B212:	cmp	r1,r4
B214:	bge	B21C
B216:	bicb	#80,(r1)+
B21A:	br	B212
B21C:	mov	#E9E,r1		;input line buffer
B220:	rts	pc
B222:	mov	0D02,r2		;address of the display RAM
B226:	mov	0D14,r3
B22A:	mul	0D16,r3
B22E:	ash	#FFFC,r3
B232:	clr	(r2)+
B234:	sob	r3,B232
B236:	mov	#B2D6,r3
B23A:	mov	#17,r1
B23E:	bis	#21,0D5C
B244:	clr	0C50
B248:	clr	0D46
B24C:	mov	#1,0D60
B252:	movb	(r3)+,r2
B254:	jsr	pc,A01C		;display character r2
B258:	sob	r1,B252
B25A:	bic	#21,0D5C
B260:	rts	pc
B262:	movb	(r0)+,r2
B264:	cmpb	r2,#E
B268:	bne	B28A
B26A:	mov	r2,-(sp)
B26C:	mov	#B7FE,r2
B270:	mov	r3,-(sp)
B272:	mov	r1,-(sp)
B274:	mov	#8,r3
B278:	jsr	pc,B5A6
B27C:	mov	(sp)+,r1
B27E:	mov	(sp)+,r3
B280:	mov	(sp)+,r2
B282:	jsr	pc,A01C		;display character r2
B286:	sob	r1,B262
B288:	rts	pc
B28A:	cmpb	r2,#F
B28E:	bne	B282
B290:	mov	r2,-(sp)
B292:	mov	#B7F6,r2
B296:	br	B270

B290:	A6 10 C2 15  F6 B7 EC 01  20 20 20 20  20 20 20 20  &.B.v7l.        
B2A0:	20 20 20 20  20 20 20 20  20 20 20 20  0E 20 73 75              . su
B2B0:	0F 2F 48 20  2D 0E 20 50  4F 44 53 4B  41 5A 4B 41  ./H -. PODSKAZKA
B2C0:	09 0F 20 20  20 20 20 20  20 20 20 20  20 20 20 20  ..              
B2D0:	20 20 20 20  20 20 0F 20  65 64 69 74  20 20 0E 5A        . edit  .Z
B2E0:	41 4D 20 20  20 20 57 52  20 4C 41 54  0F FF CB B5  AM    WR LAT..K5

B2EA:	bis	(r1)+,r1
B2EC:	45fpp
B2EE:	bitb	#80,(r3)
B2F2:	beq	B302
B2F4:	jsr	pc,B6D6
B2F8:	mov	r5,-(sp)
B2FA:	jsr	pc,C300
B2FE:	mov	(sp)+,r5
B300:	br	B31A
B302:	cmpb	#E,(r3)
B306:	beq	B2F4
B308:	cmpb	#F,(r3)
B30C:	beq	B314
B30E:	cmpb	#3F,(r3)
B312:	bge	B31A
B314:	jsr	pc,B6FC
B318:	br	B2F8
B31A:	jsr	pc,BF3A		;wait for a key
B31E:	beq	B2EE
B320:	tst	0F00
B324:	beq	B32A
B326:	jmp	B1DA
B32A:	cmpb	#D,r2
B32E:	bne	B332
B330:	rts	pc
B332:	mov	#B348,r0
B336:	clr	r1
B338:	bisb	(r0)+,r1
B33A:	beq	B36C
B33C:	cmpb	r2,(r0)+
B33E:	bne	B336
B340:	jsr	pc,A3F0
B344:	asl	r1
B346:	add	r1,pc

B348:	mov	1C2E(r4),@#1A54
B34E:	mov	-(r5),(r1)+
B350:	mov	@(r1)+,@(sp)+
B352:	mov	(r1),@1347(r3)
B356:	mov	(r0)+,@01AE(r5)
B35A:	blt	B2CE
B35C:	mov	-(r2),B5F9
B360:	bgt	B278
B362:	jsr	r2,@0EE2(r0)
B366:	illop
B368:	sob	pc,B348
B36A:	45fpp
B36C:	cmpb	r2,#20
B370:	blo	B2EE
B372:	bit	#1,0D42
B378:	beq	B380
B37A:	jsr	pc,B648
B37E:	br	B2EE
B380:	jsr	pc,B7CA
B384:	br	B2EE
B386:	add	#14,r3
B38A:	cmp	r3,#EEE
B38E:	blo	B39C
B390:	sub	#14,r3
B394:	jsr	pc,A3F0
B398:	jmp	B2EE
B39C:	add	0D50,0C50
B3A2:	br	B394
B3A4:	sub	#14,r3
B3A8:	cmp	r3,#E9E
B3AC:	bhis	B3BA
B3AE:	add	#14,r3
B3B2:	jsr	pc,A3F0
B3B6:	jmp	B2EE
B3BA:	sub	0D50,0C50
B3C0:	br	B3B2
B3C2:	jsr	pc,B200
B3C6:	sub	#E9E,r4
B3CA:	mov	r4,0E88
B3CE:	mov	#B60A,-(sp)
B3D2:	jmp	871C
B3D6:	jsr	pc,B200
B3DA:	sub	#E9E,r4
B3DE:	mov	r4,0E88
B3E2:	mov	#B5E2,-(sp)
B3E6:	jmp	871C
B3EA:	jsr	pc,B7A8
B3EE:	br	B3FC
B3F0:	cmp	#E9E,r3
B3F4:	beq	B3FC
B3F6:	dec	r3
B3F8:	jsr	pc,A4A4
B3FC:	jsr	pc,A3F0
B400:	jmp	B2EE
B404:	cmpb	#E,(r3)
B408:	bne	B410
B40A:	jsr	pc,B720
B40E:	br	B41A
B410:	cmpb	#F,(r3)
B414:	bne	B41A
B416:	jsr	pc,B750
B41A:	cmp	r3,r4
B41C:	bhis	B3FC
B41E:	mov	r3,-(sp)
B420:	sub	r3,r4
B422:	mov	r4,r1
B424:	dec	r4
B426:	beq	B430
B428:	inc	r3
B42A:	movb	(r3),-(r3)
B42C:	inc	r3
B42E:	sob	r4,B428
B430:	movb	#20,(r3)
B434:	mov	r3,r4
B436:	mov	(sp)+,r3
B438:	jsr	pc,B780
B43C:	br	B3FC
B43E:	bit	#1,0D42
B444:	beq	B452
B446:	bic	#1,0D42
B44C:	jsr	pc,B632
B450:	br	B3FC
B452:	bis	#1,0D42
B458:	jsr	pc,B638
B45C:	br	B3FC
B45E:	cmpb	(r3),#20
B462:	beq	B46A
B464:	jsr	pc,B7A8
B468:	br	B45E
B46A:	cmp	r3,r4
B46C:	bhis	B3FC
B46E:	jsr	pc,B7A8
B472:	cmpb	(r3),#20
B476:	beq	B46A
B478:	br	B3FC
B47A:	cmp	#E9E,r3
B47E:	beq	B3FC
B480:	dec	r3
B482:	jsr	pc,A4A4
B486:	cmpb	(r3),#20
B48A:	beq	B47A
B48C:	cmp	#E9E,r3
B490:	beq	B3FC
B492:	dec	r3
B494:	jsr	pc,A4A4
B498:	cmpb	(r3),#20
B49C:	bne	B48C
B49E:	jsr	pc,B7A8
B4A2:	br	B3FC
B4A4:	mov	0D48,0C50
B4AA:	mov	0D4A,0D46
B4B0:	mov	#E9E,r3		;input line buffer
B4B4:	br	B3FC
B4B6:	br	B518
B4B8:	br	B522
B4BA:	cmp	r3,r4
B4BC:	bhis	B4B4
B4BE:	mov	0D46,-(sp)
B4C2:	mov	0C50,-(sp)
B4C6:	sub	r3,r4
B4C8:	mov	r3,r1
B4CA:	movb	#20,r2
B4CE:	movb	r2,(r3)+
B4D0:	jsr	pc,A01C		;display character r2
B4D4:	sob	r4,B4CE
B4D6:	jsr	pc,A3F0
B4DA:	mov	r1,r3
B4DC:	mov	r3,r4
B4DE:	mov	(sp)+,0C50
B4E2:	mov	(sp)+,0D46
B4E6:	jmp	B3FC
B4EA:	cmp	r3,#E9E
B4EE:	blos	B4E6
B4F0:	cmp	r3,r4
B4F2:	bne	B4F6
B4F4:	dec	r4
B4F6:	jsr	pc,A3F0
B4FA:	movb	#20,-(r3)
B4FE:	jsr	pc,A532
B502:	jmp	B2EE
B506:	jsr	pc,B6FC
B50A:	br	B510
B50C:	jsr	pc,B6D6
B510:	jsr	pc,B648
B514:	jmp	B2EE
B518:	cmp	r3,r4
B51A:	bhis	B4E6
B51C:	jsr	pc,B7A8
B520:	br	B518
B522:	jsr	pc,A3F0
B526:	mov	r3,-(sp)
B528:	mov	0D46,-(sp)
B52C:	mov	0C50,-(sp)
B530:	jsr	pc,B200
B534:	mov	#B53C,-(sp)
B538:	jmp	871C
B53C:	jsr	pc,B222
B540:	clr	0D46
B544:	mov	#8,0C50
B54A:	mov	#B806,r3
B54E:	movb	(r3)+,r2
B550:	bmi	B558
B552:	jsr	pc,A01C		;display character r2
B556:	br	B54E
B558:	jsr	pc,BF3A		;wait for a key
B55C:	jsr	pc,B222
B560:	mov	#B88A,r2
B564:	mov	#8,0C50
B56A:	clr	0D46
B56E:	mov	#8,r4
B572:	clr	r3
B574:	movb	(r2)+,r3
B576:	jsr	pc,B5A6
B57A:	movb	(r2)+,r1
B57C:	mov	r2,r3
B57E:	movb	(r3)+,r2
B580:	jsr	pc,A01C		;display character r2
B584:	sob	r1,B57E
B586:	mov	r3,r2
B588:	sob	r4,B574
B58A:	mov	#13,r1
B58E:	movb	(r3)+,r2
B590:	jsr	pc,A01C		;display character r2
B594:	sob	r1,B58E
B596:	jsr	pc,BF3A		;wait for a key
B59A:	mov	0E86,r1
B59E:	inc	0E26
B5A2:	jmp	B0C0
B5A6:	mov	0C50,-(sp)
B5AA:	mov	r1,-(sp)
B5AC:	clr	r1
B5AE:	mov	#FC00,0D64
B5B4:	movb	(r2)+,r1
B5B6:	swab	r1
B5B8:	jsr	pc,A31E		;plot a dot
B5BC:	inc	0C50
B5C0:	sob	r3,B5B4
B5C2:	mov	(sp)+,r1
B5C4:	mov	(sp)+,0C50
B5C8:	add	0D4E,0D46
B5CE:	cmp	0D46,0D54
B5D4:	ble	B5E0
B5D6:	clr	0D46
B5DA:	add	0D50,0C50
B5E0:	rts	pc
B5E2:	mov	#2,r3
B5E6:	tstb	-(r1)
B5E8:	cmp	r1,#F58
B5EC:	blos	B5F6
B5EE:	cmpb	-(r1),#A
B5F2:	bne	B5EE
B5F4:	sob	r3,B5E8
B5F6:	tstb	(r1)+
B5F8:	jsr	pc,A3F0
B5FC:	mov	#1,0D60
B602:	mov	r1,0E86
B606:	jmp	B0FA
B60A:	cmp	r1,r5
B60C:	bge	B620
B60E:	jsr	pc,A3F0
B612:	mov	#1,0D60
B618:	mov	r1,0E86
B61C:	jmp	B0FA
B620:	tstb	-(r1)
B622:	cmpb	-(r1),#A
B626:	beq	B62E
B628:	cmp	r1,#F58
B62C:	bne	B622
B62E:	tstb	(r1)+
B630:	br	B60E
B632:	mov	#B7EC,r2
B636:	br	B63C
B638:	mov	#B7F1,r2
B63C:	mov	r5,-(sp)
B63E:	mov	r2,r5
B640:	jsr	pc,C356
B644:	mov	(sp)+,r5
B646:	rts	pc
B648:	jsr	pc,B65E
B64C:	tst	r1
B64E:	beq	B658
B650:	jsr	pc,B780
B654:	jsr	pc,B7A8
B658:	jsr	pc,A3F0
B65C:	rts	pc
B65E:	cmp	#EEE,r3
B662:	blos	B672
B664:	cmp	#EEE,r4
B668:	blos	B672
B66A:	cmp	r3,r4
B66C:	blo	B676
B66E:	jsr	pc,B7CA
B672:	clr	r1
B674:	rts	pc
B676:	mov	r4,-(sp)
B678:	sub	r3,r4
B67A:	inc	r4
B67C:	mov	r4,r1
B67E:	mov	(sp),r3
B680:	movb	(r3)+,(r3)
B682:	cmpb	-(r3),-(r3)
B684:	sob	r4,B680
B686:	inc	r3
B688:	mov	(sp)+,r4
B68A:	inc	r4
B68C:	cmpb	r2,#3F
B690:	ble	B696
B692:	bisb	0D44,r2
B696:	movb	r2,(r3)
B698:	cmpb	r2,#E
B69C:	beq	B6A4
B69E:	cmpb	r2,#F
B6A2:	bne	B6A8
B6A4:	jsr	pc,B6AA
B6A8:	rts	pc
B6AA:	mov	r3,-(sp)
B6AC:	tstb	(r3)+
B6AE:	cmp	r3,r4
B6B0:	beq	B6D2
B6B2:	cmpb	(r3),#3F
B6B6:	bgt	B6C4
B6B8:	cmpb	(r3),#E
B6BC:	beq	B6D2
B6BE:	cmpb	(r3),#F
B6C2:	beq	B6D2
B6C4:	movb	(r3),r2
B6C6:	bicb	#80,r2
B6CA:	bisb	0D44,r2
B6CE:	movb	r2,(r3)
B6D0:	br	B6AC
B6D2:	mov	(sp)+,r3
B6D4:	rts	pc
B6D6:	mov	0C44,0C48
B6DC:	mov	#80,0D44
B6E2:	bis	#20,0D8A
B6E8:	tst	0E6C
B6EC:	beq	B6F4
B6EE:	bic	#20,0D8A
B6F4:	mov	#E,0C38
B6FA:	rts	pc
B6FC:	mov	0C42,0C48
B702:	clr	0D44
B706:	bic	#20,0D8A
B70C:	tst	0E6C
B710:	beq	B718
B712:	bis	#20,0D8A
B718:	mov	#F,0C38
B71E:	rts	pc
B720:	mov	r3,-(sp)
B722:	cmp	r3,#E9E
B726:	ble	B740
B728:	cmpb	-(r3),#E
B72C:	beq	B74C
B72E:	bitb	(r3),#80
B732:	bne	B74C
B734:	cmpb	(r3),#F
B738:	beq	B740
B73A:	cmpb	(r3),#3F
B73E:	ble	B722
B740:	jsr	pc,B6FC
B744:	mov	(sp)+,r3
B746:	jsr	pc,B6AA
B74A:	rts	pc
B74C:	mov	(sp)+,r3
B74E:	rts	pc
B750:	mov	r3,-(sp)
B752:	cmp	r3,#E9E
B756:	ble	B770
B758:	cmpb	-(r3),#F
B75C:	beq	B770
B75E:	bitb	#80,(r3)
B762:	bne	B774
B764:	cmpb	(r3),#E
B768:	beq	B774
B76A:	cmpb	(r3),#3F
B76E:	ble	B752
B770:	mov	(sp)+,r3
B772:	rts	pc
B774:	mov	(sp)+,r3
B776:	jsr	pc,B6D6
B77A:	jsr	pc,B6AA
B77E:	rts	pc
B780:	tst	r1
B782:	beq	B7A6
B784:	mov	0D46,-(sp)
B788:	mov	0C50,-(sp)
B78C:	mov	r3,r0
B78E:	mov	0C48,-(sp)
B792:	jsr	pc,B262
B796:	mov	(sp)+,0C48
B79A:	jsr	pc,A3F0
B79E:	mov	(sp)+,0C50
B7A2:	mov	(sp)+,0D46
B7A6:	rts	pc
B7A8:	cmp	#EEE,r3
B7AC:	blos	B7C8
B7AE:	inc	r3
B7B0:	add	0D4E,0D46
B7B6:	cmp	0D54,0D46
B7BC:	bhis	B7C8
B7BE:	clr	0D46
B7C2:	add	0D50,0C50
B7C8:	rts	pc
B7CA:	cmp	#EED,r3
B7CE:	blo	B7EA
B7D0:	cmpb	r2,#3F
B7D4:	ble	B7DA
B7D6:	bisb	0D44,r2
B7DA:	movb	r2,(r3)+
B7DC:	mov	#1,r1
B7E0:	jsr	pc,B264
B7E4:	cmp	r4,r3
B7E6:	bhis	B7EA
B7E8:	mov	r3,r4
B7EA:	rts	pc

B7E0:	F7 09 80 FA  03 21 01 86  C4 10 87 00  2A 5A 41 4D  w..z.!..D...*ZAM
B7F0:	00 2A 57 53  54 00 60 80  E0 20 F0 48  48 30 60 80  .*WST.`.` pHH0`.
B800:	E0 20 D0 10  10 10 0E 73  75 0F 2F 41  2D 0E 4E 41  ` P....su./A-.NA
B810:	5E 41 4C 4F  20 53 54 52  4F 4B 49 0D  0A 73 75 0F  ^ALO STROKI..su.
B820:	2F 42 2D 0E  50 52 45 44  59 44 55 5D  45 45 0D 0A  /B-.PREDYDU]EE..
B830:	20 20 20 20  20 53 4C 4F  57 4F 0D 0A  73 75 0F 2F       SLOWO..su./
B840:	45 2D 0E 55  44 41 4C 49  54 58 20 5E  41 53 54 58  E-.UDALITX ^ASTX
B850:	0D 0A 20 20  20 20 20 53  54 52 4F 4B  49 0D 0A 73  ..     STROKI..s
B860:	75 0F 2F 46  2D 0E 53 4C  45 44 55 40  5D 45 45 20  u./F-.SLEDU@]EE 
B870:	53 4C 4F 57  4F 73 75 0F  2F 58 2D 0E  4B 4F 4E 45  SLOWOsu./X-.KONE
B880:	43 20 53 54  52 4F 4B 49  0F FF 06 00  20 10 F8 10  C STROKI.... .x.
B890:	20 0D 0F 2D  0E 57 50 52  41 57 4F 20  20 20 0F 06   ..-.WPRAWO   ..
B8A0:	00 20 40 F8  40 20 0B 2D  0E 57 4C 45  57 4F 20 20  . @x@ .-.WLEWO  
B8B0:	0D 0F 06 00  20 90 F8 90  20 0C 2D 0E  57 53 54 41  .... .x. .-.WSTA
B8C0:	57 49 54 58  20 0F 06 00  20 48 F8 48  20 0B 2D 0E  WITX ... HxH .-.
B8D0:	55 44 41 4C  49 54 58 0D  0F 06 00 20  70 A8 20 20  UDALITX.... p(  
B8E0:	16 2D 0E 50  52 45 44 59  44 55 5D 41  51 20 53 54  .-.PREDYDU]AQ ST
B8F0:	52 4F 4B 41  0D 0A 0F 06  00 20 20 A8  70 20 15 2D  ROKA.....  (p .-
B900:	0E 53 4C 45  44 55 40 5D  41 51 20 53  54 52 4F 4B  .SLEDU@]AQ STROK
B910:	41 0D 0A 0F  06 00 20 70  A8 20 70 18  2D 0E 50 52  A..... p( p.-.PR
B920:	45 44 59 44  55 5D 0F 2E  0E 20 4F 50  45 52 41 54  EDYDU]... OPERAT
B930:	4F 52 0D 0F  06 00 70 20  A8 70 20 15  2D 0E 53 4C  OR....p (p .-.SL
B940:	45 44 55 40  5D 49 4A 20  4F 50 45 52  41 54 4F 52  EDU@]IJ OPERATOR
B950:	0D 77 6B 0F  2D 0E 57 59  48 4F 44 20  49 5A 09 0F  .wk.-.WYHOD IZ..
B960:	45 44 49 54  F7 09 E4 E6  F7 95 03 00  06 54 F7 15  EDITw.dfw....Tw.

B960:	bic	(r1)+,r5
B962:	bis	(r1)+,(r1)
B964:	jsr	pc,A04C		;save registers on the stack
B968:	movb	#3,0D74
B96E:	mov	#1,0E8E
B974:	mov	#1,0E90
B97A:	clr	0E92
B97E:	mov	#D76,r0
B982:	tst	(r0)
B984:	bne	B990
B986:	clr	0008(r0)
B98A:	mov	0002(r0),000A(r0)
B990:	mov	0008(r0),r4
B994:	mov	000A(r0),r5
B998:	jsr	pc,BCE0
B99C:	jsr	pc,BD48
B9A0:	mov	#1,0E72
B9A6:	mov	#1,0E74
B9AC:	mov	0004(r0),0E76
B9B2:	mov	0006(r0),0E78
B9B8:	add	r4,0E76
B9BC:	sub	r5,0E78
B9C0:	mov	#FFFF,-(sp)
B9C4:	jsr	pc,BB3C
B9C8:	jsr	pc,BCAE
B9CC:	mov	0E76,r4
B9D0:	mov	0E78,r5
B9D4:	bit	#8,0D5C
B9DA:	beq	B9E0
B9DC:	jsr	pc,4862
B9E0:	tst	(r0)
B9E2:	beq	B9E8
B9E4:	jsr	pc,BB06
B9E8:	bit	#8,0D5C
B9EE:	beq	B9F6
B9F0:	jsr	pc,4812
B9F4:	br	B9FA
B9F6:	jsr	pc,A88E
B9FA:	tst	r3
B9FC:	bge	BA0E
B9FE:	add	0E72,r4
BA02:	sub	0E7A,r2
BA06:	add	0E7C,r1
BA0A:	add	r2,r3
BA0C:	br	BA20
BA0E:	add	0E72,r4
BA12:	add	0E74,r5
BA16:	sub	0E7C,r2
BA1A:	add	0E7E,r1
BA1E:	sub	r1,r3
BA20:	cmp	r4,0E76
BA24:	bne	BA30
BA26:	cmp	r5,0E78
BA2A:	bne	BA30
BA2C:	jmp	BAEC
BA30:	tst	r2
BA32:	bge	BA3A
BA34:	jsr	pc,BAB2
BA38:	br	BA20
BA3A:	tst	r1
BA3C:	bge	B9E8
BA3E:	jsr	pc,BA44
BA42:	br	BA20
BA44:	mov	r4,-(sp)
BA46:	mov	r5,r4
BA48:	mov	(sp),r5
BA4A:	mov	0E72,(sp)
BA4E:	mov	0E74,0E72
BA54:	mov	(sp),0E74
BA58:	mov	0E76,(sp)
BA5C:	mov	0E78,0E76
BA62:	mov	(sp)+,0E78
BA66:	neg	0002(sp)
BA6A:	mov	0E7C,r0
BA6E:	asl	r0
BA70:	sub	0E7E,r0
BA74:	mov	r0,-(sp)
BA76:	sub	0E7A,r0
BA7A:	mov	r0,0E7A
BA7E:	sub	0E7E,0E7C
BA84:	neg	0E7E
BA88:	mov	0E7C,r0
BA8C:	asr	r0
BA8E:	sub	r0,r2
BA90:	add	r1,r2
BA92:	neg	r3
BA94:	add	r2,r3
BA96:	mov	r1,r0
BA98:	asr	r0
BA9A:	sub	r0,r3
BA9C:	mov	0E7E,r0
BAA0:	asr	r0
BAA2:	asr	r0
BAA4:	asr	r0
BAA6:	add	r0,r3
BAA8:	mov	(sp)+,r0
BAAA:	asr	r0
BAAC:	neg	r1
BAAE:	add	r0,r1
BAB0:	rts	pc
BAB2:	neg	0E74
BAB6:	mov	0E7C,r0
BABA:	sub	0E7A,r0
BABE:	neg	0E7A
BAC2:	mov	0E7A,0E7C
BAC8:	add	r0,0E7C
BACC:	asl	r0
BACE:	asl	r0
BAD0:	neg	0E7E
BAD4:	add	r0,0E7E
BAD8:	neg	r2
BADA:	sub	r0,r2
BADC:	neg	r3
BADE:	sub	r1,r3
BAE0:	add	r2,r3
BAE2:	sub	r0,r1
BAE4:	mov	r2,r0
BAE6:	asl	r0
BAE8:	sub	r0,r1
BAEA:	rts	pc
BAEC:	bit	#8,0D5C
BAF2:	beq	BAFA
BAF4:	jsr	pc,4812
BAF8:	br	BAFE
BAFA:	jsr	pc,A88E
BAFE:	tst	(sp)+
BB00:	jsr	pc,A060		;restore registers from the stack
BB04:	rts	pc
BB06:	mov	r4,-(sp)
BB08:	mov	r5,-(sp)
BB0A:	mov	r1,-(sp)
BB0C:	mov	r2,-(sp)
BB0E:	mov	000C(r0),r4
BB12:	mov	000E(r0),r5
BB16:	jsr	pc,BCE0
BB1A:	mov	0004(r0),0E76
BB20:	mov	0006(r0),0E78
BB26:	add	r4,0E76
BB2A:	sub	r5,0E78
BB2E:	jsr	pc,BCAE
BB32:	mov	(sp)+,r2
BB34:	mov	(sp)+,r1
BB36:	mov	(sp)+,r5
BB38:	mov	(sp)+,r4
BB3A:	rts	pc
BB3C:	cmpb	#1,0E82
BB42:	bne	BBA4
BB44:	mov	0E90,0E7A
BB4A:	asl	0E7A
BB4E:	mov	0E92,0E7C
BB54:	asl	0E7C
BB58:	mov	0E8E,0E7E
BB5E:	asl	0E7E
BB62:	add	0E7C,0E7E
BB68:	add	0E7A,0E7C
BB6E:	add	0E7C,0E7E
BB74:	mov	r5,r2
BB76:	asl	r2
BB78:	sub	0E90,r2
BB7C:	sub	0E92,r2
BB80:	mov	r4,r1
BB82:	asl	r1
BB84:	sub	r2,r1
BB86:	mov	0E8E,r3
BB8A:	asr	r3
BB8C:	asr	r3
BB8E:	neg	r3
BB90:	sub	r4,r3
BB92:	add	r2,r3
BB94:	add	0E80,r3
BB98:	mov	r4,-(sp)
BB9A:	mov	r5,r4
BB9C:	mov	(sp)+,r5
BB9E:	neg	0002(sp)
BBA2:	rts	pc
BBA4:	cmpb	#2,0E82
BBAA:	bne	BC0E
BBAC:	mov	0E8E,0E7A
BBB2:	asl	0E7A
BBB6:	neg	0E7A
BBBA:	mov	0E92,0E7C
BBC0:	asl	0E7C
BBC4:	neg	0E7C
BBC8:	mov	0E90,0E7E
BBCE:	asl	0E7E
BBD2:	neg	0E7E
BBD6:	add	0E7C,0E7E
BBDC:	add	0E7A,0E7C
BBE2:	add	0E7C,0E7E
BBE8:	mov	r4,r2
BBEA:	asl	r2
BBEC:	add	0E8E,r2
BBF0:	add	0E92,r2
BBF4:	mov	r5,r1
BBF6:	asl	r1
BBF8:	sub	r2,r1
BBFA:	mov	0E90,r3
BBFE:	asr	r3
BC00:	asr	r3
BC02:	add	r2,r3
BC04:	sub	r5,r3
BC06:	sub	0E80,r3
BC0A:	jmp	BBA2
BC0E:	cmpb	#3,0E82
BC14:	bne	BC2C
BC16:	neg	0E74
BC1A:	neg	0E8E
BC1E:	neg	0E90
BC22:	neg	r4
BC24:	neg	0E80
BC28:	jmp	BBAC
BC2C:	cmpb	#4,0E82
BC32:	bne	BC4A
BC34:	neg	0E72
BC38:	neg	0E90
BC3C:	neg	0E8E
BC40:	neg	r4
BC42:	neg	0E80
BC46:	jmp	BB44
BC4A:	cmpb	#5,0E82
BC50:	bne	BC62
BC52:	neg	0E72
BC56:	neg	0E74
BC5A:	neg	r4
BC5C:	neg	r5
BC5E:	jmp	BB44
BC62:	cmpb	#6,0E82
BC68:	bne	BC7A
BC6A:	neg	0E72
BC6E:	neg	0E74
BC72:	neg	r4
BC74:	neg	r5
BC76:	jmp	BBAC
BC7A:	cmpb	#7,0E82
BC80:	bne	BC98
BC82:	neg	0E72
BC86:	neg	0E8E
BC8A:	neg	0E90
BC8E:	neg	r5
BC90:	neg	0E80
BC94:	jmp	BBAC
BC98:	neg	0E74
BC9C:	neg	0E90
BCA0:	neg	0E8E
BCA4:	neg	r5
BCA6:	neg	0E80
BCAA:	jmp	BB44
BCAE:	cmpb	#1,0E82
BCB4:	bne	BCC6
BCB6:	mov	0E76,-(sp)
BCBA:	mov	0E78,0E76
BCC0:	mov	(sp)+,0E78
BCC4:	rts	pc
BCC6:	cmpb	#4,0E82
BCCC:	beq	BCB6
BCCE:	cmpb	#5,0E82
BCD4:	beq	BCB6
BCD6:	cmpb	#8,0E82
BCDC:	beq	BCB6
BCDE:	br	BCC4
BCE0:	mov	r4,r1
BCE2:	mov	r5,r2
BCE4:	tst	r4
BCE6:	bge	BD1A
BCE8:	tst	r5
BCEA:	bge	BD04
BCEC:	neg	r1
BCEE:	neg	r2
BCF0:	cmp	r1,r2
BCF2:	bge	BCFC
BCF4:	movb	#6,0E82
BCFA:	br	BD46
BCFC:	movb	#5,0E82
BD02:	br	BD46
BD04:	neg	r1
BD06:	cmp	r1,r2
BD08:	bge	BD12
BD0A:	movb	#3,0E82
BD10:	br	BD46
BD12:	movb	#4,0E82
BD18:	br	BD46
BD1A:	tst	r5
BD1C:	bgt	BD34
BD1E:	neg	r2
BD20:	cmp	r1,r2
BD22:	bge	BD2C
BD24:	movb	#7,0E82
BD2A:	br	BD46
BD2C:	movb	#8,0E82
BD32:	br	BD46
BD34:	cmp	r1,r2
BD36:	bge	BD40
BD38:	movb	#2,0E82
BD3E:	br	BD46
BD40:	movb	#1,0E82
BD46:	rts	pc
BD48:	mov	0002(r0),r1
BD4C:	mul	r1,r1
BD4E:	mov	r1,0E80
BD52:	mov	0008(r0),r1
BD56:	mul	r1,r1
BD58:	sub	r1,0E80
BD5C:	mov	000A(r0),r1
BD60:	mul	r1,r1
BD62:	sub	r1,0E80
BD66:	rts	pc

; keyboard interrupt service routine
BD68:	mov	#B2,@#E814
BD6E:	mov	#1,0F18		;flag of a pressed key
BD74:	clr	@#E816		;start of the transfer
BD78:	tstb	@#E814
BD7C:	bpl	BD78
BD7E:	mov	@#E816,0D86	;key scan code, end of the transfer
BD84:	tstb	@#E814
BD88:	bpl	BD84
BD8A:	mov	r2,-(sp)
BD8C:	tst	0E70
BD90:	beq	BDA2
BD92:	mov	r0,-(sp)
BD94:	mov	#28,r2		;note C3
BD98:	mov	#1,r0		;duration time 32 ms
BD9C:	jsr	pc,A68C		;make a beep
BDA0:	mov	(sp)+,r0
BDA2:	mov	0D86,r2
BDA6:	cmpb	r2,#1B		;key SU ?
BDAA:	bne	BDD0
BDAC:	xor	r2,0E6E		;SU keyboard mode flag
BDB0:	mov	#FFE0,r2
BDB4:	xor	r2,0D8C
BDB8:	jsr	pc,C322
BDBC:	xor	r2,0D8C
BDC0:	mov	(sp)+,r2
BDC2:	mov	#72,@#E814
BDC8:	mov	#AA,@#E814
BDCE:	rti
;
BDD0:	tstb	0E6E		;SU keyboard mode flag
BDD4:	beq	BDC0		;branch if not SU keyboard mode
BDD6:	clr	0E6E
BDDA:	cmpb	r2,#17		;key [ ?
BDDE:	bne	BDE6
BDE0:	xor	r2,0E70
BDE4:	br	BEAA
BDE6:	cmpb	r2,#33		;key S ?
BDEA:	beq	BE72
BDEC:	cmpb	r2,#EF		;key P ?
BDF0:	beq	BE14
BDF2:	cmpb	r2,#0B		;key A ?
BDF6:	beq	BEB8		;display the authors
BDF8:	cmpb	r2,#6F		;key L ?
BDFC:	bne	BDC0
BDFE:	tst	@#E81E
BE02:	bmi	BDC0
BE04:	mov	#1,0F42
BE0A:	mfps	-(sp)
BE0C:	mov	#BDC0,-(sp)
BE10:	jmp	C5AE

BE14:	mov	0CFC,-(sp)
BE18:	bit	#80,0D5C
BE1E:	beq	BE2C
BE20:	mov	0D4A,0D46
BE26:	mov	0D48,0C50
BE2C:	jsr	pc,AA96
BE30:	tst	0F42
BE34:	beq	BE48
BE36:	mov	0D4A,0D46
BE3C:	mov	0D48,0C50
BE42:	mov	#1,0C56
BE48:	clr	0F20
BE4C:	mov	#1,0CFC
BE52:	mov	#5E,r2
BE56:	trap	00		;print character r2
BE58:	mov	#50,r2
BE5C:	trap	00		;print character r2
BE5E:	mov	(sp)+,0CFC
BE62:	mov	#1,0F00
BE68:	jsr	pc,C322
BE6C:	clr	0D70
BE70:	br	BDC0

BE72:	clr	0D8C
BE76:	jsr	pc,C322
BE7A:	mov	#EA,@#E814
BE80:	wait
BE82:	tst	0E6E		;SU keyboard mode flag
BE86:	beq	BE80		;branch if not SU keyboard mode
BE88:	clr	0E6E
BE8C:	wait
BE8E:	cmpb	0D86,#EF	;key P ?
BE94:	beq	BE14
BE96:	clr	0E6E
BE9A:	clr	0D8C
BE9E:	jsr	pc,C322
BEA2:	cmpb	0D86,#F7	;key Q ?
BEA8:	bne	BE80
BEAA:	clr	0D86
BEAE:	clr	0D8C
BEB2:	jsr	pc,C322
BEB6:	br	BDC0

; display the authors
BEB8:	clr	0D8C
BEBC:	jsr	pc,C322
BEC0:	clr	0D86
BEC4:	mov	r0,-(sp)
BEC6:	mov	r2,-(sp)
BEC8:	mov	#BEDC,r0	;string 'Awtory: ...' (Authors: ...)
BECC:	trap	36		;print a string pointed to by r0
BECE:	mov	(sp)+,r2
BED0:	mov	(sp)+,r0
BED2:	jmp	BDC0

; EVNT interrupt service routine
BED6:	dec	0F14		;counter decremented at each EVNT interrupt
BEDA:	rti

BED0:	80 15 77 00  EA FE F7 0A  3A 50 02 00  0D 0A 0E 61  ..w.j~w.:P.....a
BEE0:	57 54 4F 52  59 3A 0D 0A  6B 4C 49 4D  45 4E 4B 4F  WTORY:..kLIMENKO
BEF0:	57 2C 6E 41  55 4D 4F 57  41 20 20 20  66 41 4E 44  W,nAUMOWA   fAND
BF00:	45 45 57 41  2C 6B 4F 4E  44 52 41 54  45 4E 4B 4F  EEWA,kONDRATENKO
BF10:	65 52 5B 4F  57 41 2C 7B  45 53 54 41  4B 20 20 20  eR[OWA,{ESTAK   
BF20:	20 20 20 20  64 45 4E 49  53 45 57 49  5E 2C 73 41      dENISEWI^,sA
BF30:	57 5E 45 4E  4B 4F 0F 0D  0A 00 DF 15  A2 00 14 E8  W^ENKO...._."..h

; wait for a key, return the ASCII code of the pressed key in r2
BF3A:	mov	#A2,@#E814
BF40:	clr	0F18		;clear the flag of a pressed key
BF44:	wait
BF46:	tst	0F18		;key pressed?
BF4A:	beq	BF44		;back to the waiting loop if not
BF4C:	clr	0F18		;clear the flag of a pressed key
BF50:	mov	r4,-(sp)
BF52:	mov	r5,-(sp)
BF54:	mov	0D86,r0		;key scan code
BF58:	clr	0D86
BF5C:	bic	#FF00,r0
BF60:	cmp	#DF,r0		;key ZV (backspace) ?
BF64:	bne	BF76
BF66:	tst	0D8E
BF6A:	bne	C062
BF6C:	xor	r0,0D88
BF70:	jsr	pc,C312
BF74:	br	C062
;
BF76:	sub	#0A,r0
BF7A:	asr	r0
BF7C:	asr	r0
BF7E:	tst	0D88
BF82:	beq	C00A
BF84:	cmp	r0,#3D
BF88:	ble	BF8C
BF8A:	br	C062
BF8C:	mov	#C10C,r5	;keywords typed with a single key stroke
BF90:	mov	r0,r4
BF92:	inc	r0
BF94:	cmpb	(r5)+,#24	;'$'
BF98:	bne	BF94
BF9A:	sob	r0,BF94
BF9C:	bicb	#38,r4
BFA0:	cmp	r4,#5
BFA4:	bgt	BFE6
BFA6:	movb	#20,r2
BFAA:	bit	#10,0D5C
BFB0:	beq	BFD2
BFB2:	mov	r4,-(sp)
BFB4:	mov	0004(sp),r4
BFB8:	bit	#1,0D42
BFBE:	beq	BFC6
BFC0:	jsr	pc,B648
BFC4:	br	BFCA
BFC6:	jsr	pc,B7CA
BFCA:	mov	r4,0004(sp)
BFCE:	mov	(sp)+,r4
BFD0:	br	BFE0
BFD2:	jsr	pc,A01C		;display character r2
BFD6:	movb	r2,(r3)+
BFD8:	cmp	r3,#0EEF
BFDC:	blo	BFE0
BFDE:	trap	19		;error 12 - input line too long (more than 80
				;characters)
BFE0:	tst	0D88
BFE4:	beq	C062
BFE6:	movb	(r5)+,r2
BFE8:	cmpb	r2,#2A
BFEC:	beq	BFF4
BFEE:	cmpb	#24,r2
BFF2:	bne	BFAA
BFF4:	clr	0D88
BFF8:	jsr	pc,C312
BFFC:	cmpb	r2,#2A
C000:	beq	C062
C002:	cmp	r4,#5
C006:	ble	BFA6
C008:	br	C062
;
C00A:	cmp	#34,r0
C00E:	bne	C016
C010:	mov	#7F,r0
C014:	br	C046
C016:	mov	#1,r5
C01A:	mov	#10,r2
C01E:	cmp	#3D,r0
C022:	beq	C07E
C024:	asl	r2
C026:	cmpb	#5,r0
C02A:	beq	C06C
C02C:	neg	r2
C02E:	cmp	#4,r0
C032:	beq	C05A
C034:	add	pc,r0
C036:	add	#0098,r0	;C036+0098 = C0CE, table of key codes
C03A:	movb	(r0),r0
C03C:	cmp	r0,#40
C040:	blt	C08E
C042:	bis	0D8A,r0
C046:	bic	0D8C,r0
C04A:	tst	0D8C
C04E:	beq	C064
C050:	clr	0D8C
C054:	jsr	pc,C322
C058:	br	C064
C05A:	xor	r2,0D8C
C05E:	jsr	pc,C322
C062:	clr	r0
C064:	mov	(sp)+,r5
C066:	mov	(sp)+,r4
C068:	mov	r0,r2
C06A:	rts	pc

C06C:	xor	r2,0D8A
C070:	xor	r5,0C38
C074:	movb	0C38,r0
C078:	jsr	pc,C300
C07C:	br	C046
C07E:	xor	r2,0E6C
C082:	asl	r2
C084:	xor	r2,0D8A
C088:	jsr	pc,C2EC
C08C:	br	C062
C08E:	cmp	r0,#30
C092:	blt	C09A
C094:	sub	0E6C,r0
C098:	br	C046
C09A:	tst	0E6C
C09E:	beq	C0A6
C0A0:	cmp	r0,#20
C0A4:	ble	C0AC
C0A6:	add	0E6C,r0
C0AA:	br	C046
C0AC:	cmp	#14,r0
C0B0:	bne	C0B8
C0B2:	bis	#2,r0
C0B6:	br	C046
C0B8:	cmp	#13,r0
C0BC:	bne	C0C2
C0BE:	dec	r0
C0C0:	br	C046
C0C2:	cmp	#8,r0
C0C6:	bne	C046
C0C8:	mov	#2,r0
C0CC:	br	C046

; table of key codes
C0CE:	      41 49  52 5B 00 00	  AIR[..
C0D4:	31 36 42 4A  53 5D 1C 1D	16BJS]..
C0DC:	32 37 57 4B  54 58 1A 14	27WKTX..
C0E4:	33 38 47 4C  55 59 2C 20	38GLUY, 
C0EC:	34 39 44 4D  46 5F 2E 20	49DMF_. 
C0F4:	35 30 45 4E  48 5C 19 13	50ENH\..
C0FC:	3A 2F 56 4F  43 40 7F 1B	:/VOC@..
C104:	3B 2D 5A 50  5E 51 0D 00	;-ZP^Q..

; keywords typed with a single key stroke
C10C:	24 41 55 54  $AUT
C110:	4F 24 49 4E  50 55 54 24  52 55 4E 24  52 45 54 55  O$INPUT$RUN$RETU
C120:	52 4E 24 2A  24 2A 24 53  49 4E 28 24  43 4F 53 28  RN$*$*$SIN($COS(
C130:	24 44 52 41  57 24 49 4E  49 54 24 53  54 45 50 24  $DRAW$INIT$STEP$
C140:	52 45 53 54  4F 52 45 24  44 49 53 24  47 4F 53 55  RESTORE$DIS$GOSU
C150:	42 24 45 58  50 28 24 4C  4F 47 28 24  57 41 49 54  B$EXP($LOG($WAIT
C160:	24 4B 49 4C  4C 24 53 41  56 45 24 52  45 4D 24 44  $KILL$SAVE$REM$D
C170:	45 56 24 2A  24 41 42 53  28 24 53 47  4E 28 24 47  EV$*$ABS($SGN($G
C180:	4F 54 4F 24  4C 45 54 24  53 54 4F 50  24 52 45 41  OTO$LET$STOP$REA
C190:	44 24 44 45  46 20 46 4E  24 2A 24 53  51 52 28 24  D$DEF FN$*$SQR($
C1A0:	41 54 4E 28  24 44 41 54  41 24 4C 49  53 54 24 46  ATN($DATA$LIST$F
C1B0:	4F 52 24 52  41 4E 44 4F  4D 49 5A 45  24 44 49 4D  OR$RANDOMIZE$DIM
C1C0:	24 2A 24 49  4E 54 28 24  52 4E 44 28  24 45 4E 44  $*$INT($RND($END
C1D0:	24 4E 45 58  54 24 48 45  4C 50 24 46  49 4C 45 53  $NEXT$HELP$FILES
C1E0:	24 44 45 4C  45 54 45 24  2A 24 20 4C  4C 49 53 54  $DELETE$*$ LLIST
C1F0:	20 24 20 4C  46 49 4C 45  53 20 24 45  44 49 54 24   $ LFILES $EDIT$
C200:	4E 41 4D 45  24 43 4C 53  24 4C 4F 41  44 24 2A 24  NAME$CLS$LOAD$*$
C210:	2A 24 20 4C  50 52 49 4E  54 20 24 24  54 48 45 4E  *$ LPRINT $$THEN
C220:	24 50 52 49  4E 54 24 50  4C 41 59 24  4C 4F 43 41  $PRINT$PLAY$LOCA
C230:	54 45 24 24  24  TE$$$
C235:	.even

C236:	jsr	pc,A4D4
C23A:	mov	0C50,-(sp)
C23E:	mov	0D46,-(sp)
C242:	mov	r3,-(sp)
C244:	clr	0C50
C248:	bis	#21,0D5C
C24E:	clr	0D46
C252:	mov	r0,-(sp)
C254:	mov	#17,r0		;number of characters to print
C258:	mov	#C2D4,r3	;string "basic v..."
C25C:	movb	(r3)+,r2
C25E:	jsr	pc,A01C		;display character r2
C262:	sob	r0,C25C
C264:	clr	0D46
C268:	clr	0C50
C26C:	mov	0C56,-(sp)
C270:	mov	#2,0C56
C276:	clr	r0
C278:	mov	#A,r2
C27C:	mov	r1,-(sp)
C27E:	movb	C2CA(r0),r1
C282:	swab	r1
C284:	movb	C2B6(r0),r3
C288:	add	r3,0C50
C28C:	movb	C2C0(r0),r3
C290:	add	r3,0D46
C294:	jsr	pc,A31E		;plot a dot
C298:	inc	r0
C29A:	sob	r2,C27E
C29C:	mov	(sp)+,r1
C29E:	mov	(sp)+,0C56
C2A2:	mov	(sp)+,r0
C2A4:	mov	(sp)+,r3
C2A6:	mov	(sp)+,0D46
C2AA:	mov	(sp)+,0C50
C2AE:	bic	#21,0D5C
C2B4:	rts	pc

C2B6:	02 01 01 01 01 FC 01 01 01 01
C2C0:	30 00 00 00 00 08 00 00 00 00
C2CA:	70 88 30 43 FB 38 4C 54 64 38

C2D4:   0F 20 62 61  73 69 63 20  76 20 20 20	. basic v   
C2E0:	20 0E 20 20  57 52 20 4C  41 54 0F FF   .  WR LAT..

C2EC:	mov	#C344,r5
C2F0:	tst	0E6C
C2F4:	beq	C2FA
C2F6:	mov	#C347,r5
C2FA:	jsr	pc,C356
C2FE:	rts	pc
C300:	mov	#C33A,r5
C304:	cmp	#E,0C38
C30A:	beq	C2FA
C30C:	mov	#C33F,r5
C310:	br	C2FA
C312:	mov	#C34A,r5
C316:	tst	0D88
C31A:	bne	C2FA
C31C:	mov	#C34E,r5
C320:	br	C2FA

C322:	mov	r5,-(sp)
C324:	mov	#C352,r5
C328:	tst	0D8C
C32C:	bne	C332
C32E:	mov	#C34E,r5
C332:	jsr	pc,C356
C336:	mov	(sp)+,r5
C338:	rts	pc

C33A:	.asciz	"fRUS"
C341:	.asciz	"fLAT"
C344:	.asciz	"TW"
C347:	.asciz	"TN"
C34A:	.asciz	"BFK"
C34E:	.asciz	"B  " 
C353:	.asciz	"BSU"

C356:	tst	0D5E
C35A:	bne	C3D2
C35C:	mov	0C56,-(sp)
C360:	mov	0D5C,-(sp)
C364:	mov	r2,-(sp)
C366:	mov	0C50,-(sp)
C36A:	mov	0D46,-(sp)
C36E:	mov	#1,0C56
C374:	mov	#1,0D60
C37A:	bic	#40,0D5C	;set output to the screen
C380:	bis	#21,0D5C
C386:	mov	0C48,-(sp)
C38A:	mov	0D44,-(sp)
C38E:	clr	0D44
C392:	clr	0C50
C396:	movb	(r5)+,0D46
C39A:	bic	#FF00,0D46
C3A0:	mov	#E,r2
C3A4:	jsr	pc,A01C		;display character r2
C3A8:	movb	(r5)+,r2
C3AA:	beq	C3AE
C3AC:	br	C3A4
C3AE:	clr	0D60
C3B2:	mov	(sp)+,0D44
C3B6:	mov	(sp)+,0C48
C3BA:	mov	(sp)+,0D46
C3BE:	mov	(sp)+,0C50
C3C2:	mov	(sp)+,r2
C3C4:	mov	(sp)+,0D5C
C3C8:	mov	(sp)+,0C56
C3CC:	bic	#21,0D5C
C3D2:	rts	pc

; command MEM
C3D4:	jsr	pc,A04C		;save registers on the stack
C3D8:	mov	0C48,-(sp)
C3DC:	mov	#C45E,r0	;string '   '
C3E0:	trap	36		;print a string pointed to by r0
C3E2:	mov	0D5C,-(sp)
C3E6:	bis	#1,0D5C		;inverted print mode
; r0 points to a string 'Raspredelenie pamjati (w bajtah)'
C3EC:	trap	36		;print a string pointed to by r0
C3EE:	mov	(sp)+,0D5C
C3F2:	mov	#C48B,r0	;string 'Programma: '
C3F6:	trap	36		;print a string pointed to by r0
C3F8:	mov	r5,r3
C3FA:	sub	0EF2,r3
C3FE:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
C402:	jsr	pc,C440		;convert word r3 to decimal ASCII
C406:	trap	36		;print a string pointed to by r0
C408:	trap	02		;print CR, LF
C40A:	mov	#C497,r0	;string 'Svobodno: '
C40E:	trap	36		;print a string pointed to by r0
C410:	mov	sp,r3
C412:	sub	r5,r3
C414:	bhi	C420
C416:	mov	(sp)+,0C48
C41A:	jsr	pc,A060		;restore registers from the stack
C41E:	trap	01		;error 0 - out of memory
C420:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
C424:	jsr	pc,C440		;convert word r3 to decimal ASCII
C428:	trap	36		;print a string pointed to by r0
C42A:	trap	02		;print CR, LF
C42C:	mov	(sp)+,0C48
C430:	jsr	pc,A060		;restore registers from the stack
C434:	jmp	8664

; r0 <- pointer to a zero terminated buffer
C438:	mov	#09C0,r0
C43C:	clrb	-(r0)
C43E:	rts	pc

; convert word r3 to decimal ASCII, leading zeros are suppressed,
; on entry r0 should point to the end of the output buffer
C440:	clr	0E86		;number of digits
C444:	clr	r2
C446:	div	#A,r2
C44A:	bis	#30,r3		;remainder
C44E:	movb	r3,-(r0)
C450:	inc	0E86
C454:	tst	r2		;quotient
C456:	beq	C45C
C458:	mov	r2,r3
C45A:	br	C444
C45C:	rts	pc

C450:	B7 0A 32 4A  C2 0B 02 03  83 10 F4 01  87 00 20 20  7.2JB.....t...  
C460:	20 00 20 0E  72 41 53 50  52 45 44 45  4C 45 4E 49   . .rASPREDELENI
C470:	45 20 0D 0A  20 50 41 4D  51 54 49 20  28 57 20 42  E .. PAMQTI (W B
C480:	41 4A 54 41  48 29 20 20  0D 0A 00 70  52 4F 47 52  AJTAH)  ...pROGR
C490:	41 4D 4D 41  3A 20 00 73  57 4F 42 4F  44 4E 4F 20  AMMA: .sWOBODNO 
C4A0:	3A 20 00 FF  3A 89 C1 0A  97 A0 0A 00  0B 02 F7 0B  : ..:.A.. ....w.

; command USR
C4A4:	trap	3A		;get a character other than space to r2
C4A6:	dec	r1
C4A8:	cmpb	r2,#A
C4AC:	bne	C4C4
C4AE:	tst	0F16
C4B2:	beq	C4BE
C4B4:	mov	0F16,0D00
C4BA:	clr	0F16
C4BE:	trap	48
C4C0:	jmp	86BE
C4C4:	jsr	pc,F1BE		;get an octal number to r0
C4C8:	dec	r1
C4CA:	tst	r0
C4CC:	bne	C4D0
C4CE:	trap	3D		;error 30 - wrong parameters
C4D0:	jsr	pc,C4E2
C4D4:	bgt	C52C
C4D6:	mov	0F16,0D00
C4DC:	clr	0F16
C4E0:	trap	01		;error 0 - out of memory
C4E2:	mov	0D00,0F16
C4E8:	inc	r0
C4EA:	asr	r0
C4EC:	asl	r0
C4EE:	sub	r0,0D00
C4F2:	mov	r0,0D66
C4F6:	trap	4E
C4F8:	trap	44		;check the available stack space
C4FA:	ble	C52A
C4FC:	mov	0F16,r3
C500:	mov	0D00,r0
C504:	sub	r3,r0
C506:	add	sp,r0
C508:	mov	sp,r3
C50A:	mov	r0,sp
C50C:	cmp	r3,0F16
C510:	bhi	C516
C512:	mov	(r3)+,(r0)+
C514:	br	C50C
C516:	mov	0D00,r0
C51A:	cmp	r0,0F16
C51E:	bhi	C524
C520:	clr	(r0)+
C522:	br	C51A
C524:	mov	0D66,r0
C528:	trap	44		;check the available stack space
C52A:	rts	pc
C52C:	mov	r1,r3
C52E:	mov	0D00,r1
C532:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
C536:	mov	#6,r4		;number of digits
C53A:	jsr	pc,801A		;convert the word in r1 to octal ASCII
C53E:	trap	36		;print a string pointed to by r0
C540:	trap	02		;print CR, LF
C542:	mov	r3,r1
C544:	br	C4BE

; command @
; syntax @x where x is a digit in range 0-3
C546:	tst	@#E81E
C54A:	bmi	C5AC		;error 51 - expansion block not ready
C54C:	bit	#2,@#E81E
C552:	bne	C5AC		;error 51 - expansion block not ready
C554:	mov	#2000,@#E880	;switch the memory banks, MK-92 ROM enabled
C55A:	mov	#4,r3		;number of ROM pages in the MK-92
C55E:	clr	r0
C560:	trap	3A		;get a character other than space to r2
C562:	trap	38		;is r2 a digit?
C564:	bne	C57A		;branch if r2 is not a decimal digit
; select the specified MK-92 ROM page
C566:	bic	#FFFC,r2
C56A:	ash	#B,r2
C56E:	mov	r2,r0
C570:	bis	r2,@#E880
C574:	mov	#1,r3		;don't try with the next ROM page
C578:	br	C57C
C57A:	dec	r1
; find the MK-92 ROM page which contains valid data
C57C:	cmp	#CBB,@#4000
C582:	bne	C590		;invalid data, try the next ROM page
C584:	cmp	r0,@#400C
C588:	bne	C590		;invalid data, try the next ROM page
C58A:	jsr	pc,401A
C58E:	bhis	C5A4

; select the next ROM page in the MK-92
C590:	add	#800,@#E880
C596:	add	#800,r0
C59A:	sob	r3,C57C
C59C:	mov	#6000,@#E880
C5A2:	trap	03		;error 1 - unknown operator

C5A4:	bis	#4020,@#E880
C5AA:	jmp	(r2)

C5AC:	trap	67		;error 51 - expansion block not ready

; unidentified interrupt service routine (vector FC)
C5AE:	mov	r5,-(sp)
C5B0:	mov	r4,-(sp)
C5B2:	mov	r3,-(sp)
C5B4:	mov	r1,-(sp)
C5B6:	mov	r0,-(sp)
C5B8:	mov	@#E880,r1
C5BC:	mov	#2000,@#E880	;switch the memory banks, MK-92 ROM enabled
C5C2:	mov	#400E,r4
C5C6:	tst	0F42
C5CA:	ble	C5D0
C5CC:	mov	#4010,r4
C5D0:	bit	#2,@#E81E
C5D6:	bne	C5F2
C5D8:	mov	#4,r3		;number of ROM pages in the MK-92
; find the MK-92 ROM page which contains valid data
C5DC:	clr	r0
C5DE:	cmp	#CBB,@#4000
C5E4:	bne	C60E		;invalid data, try the next ROM page
C5E6:	cmp	r0,@#400C
C5EA:	bne	C60E		;invalid data, try the next ROM page
C5EC:	tst	(r4)
C5EE:	ble	C60E		;invalid data, try the next ROM page
C5F0:	jsr	pc,@(r4)+
C5F2:	mov	r1,@#E880
C5F6:	clr	0F42
C5FA:	clr	0D86
C5FE:	clr	0F18		;clear the flag of a pressed key
C602:	mov	(sp)+,r0
C604:	mov	(sp)+,r1
C606:	mov	(sp)+,r3
C608:	mov	(sp)+,r4
C60A:	mov	(sp)+,r5
C60C:	rti

; select the next ROM page in the MK-92
C60E:	add	#0800,@#E880
C614:	add	#0800,r0
C618:	sob	r3,C5DE
C61A:	br	C5F2

; command TIME
; format example (hours:minutes:seconds): 15:45:30
C61C:	jsr	pc,A04C		;save registers on the stack
C620:	trap	3A		;get a character other than space to r2
C622:	dec	r1
C624:	mov	#3,r4		;number of items
C628:	mov	#C6EC,r5	;parameter boundaries table
C62C:	mov	#0D76,r3	;scratch buffer
C630:	mov	@#EA16,0E82	;save the RTC register B
C636:	cmpb	r2,#A		;end of line?
C63A:	bne	C640		;branch if parameters present
C63C:	jmp	C688		;jump if no parameters
; command with parameters - set time
; copy the parameters to the buffer 0D76..0D7B
C640:	trap	08		;ATOI
C642:	cmpb	(r5)+,r0	;test the lower limit
C644:	bgt	C67C
C646:	cmpb	(r5)+,r0	;test the upper limit
C648:	blt	C67C
C64A:	trap	3A		;get a character other than space to r2
C64C:	cmpb	r2,#3A		;data should be followed by a colon...
C650:	beq	C658
C652:	cmpb	r4,#1		;...except of seconds
C656:	bne	C67C
C658:	asl	r0
C65A:	mov	r0,(r3)+
C65C:	sob	r4,C640		;next data
; copy the contents of the buffer 0D76..0D7B to the RTC registers
C65E:	mov	#3,r4
C662:	mov	#0D76,r3
C666:	mov	#EA08,r5
C66A:	bis	#0100,@#EA16	;RTC register B, enable Periodic Interrupts
C670:	mov	(r3)+,(r5)
C672:	cmpb	r4,#1		;last data?
C676:	beq	C6D0
C678:	cmp	-(r5),-(r5)	;r5 <- r5 - 2
C67A:	sob	r4,C670		;next data
; invalid parameters
C67C:	mov	0E82,@#EA16	;restore the RTC register B
C682:	jsr	pc,A060		;restore registers from the stack
C686:	trap	3D		;error 30 - wrong parameters
; command without parameters - display time
C688:	mov	#3,r4		;number of items
C68C:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
C690:	mov	#EA00,r5
C694:	bit	#0100,0E82	;Periodic Interrupts enabled?
C69A:	bne	C6E4		;exit if yes, RTC missing
; read the RTC registers and convert the contents to decimal ASCII
C69C:	mov	(r5),r3
C69E:	bic	#FF00,r3
C6A2:	asr	r3
C6A4:	jsr	pc,C440		;convert word r3 to decimal ASCII
C6A8:	cmp	#2,0E86		;two digits?
C6AE:	beq	C6B4		;skip if yes
C6B0:	movb	#30,-(r0)	;add a leading zero
C6B4:	cmp	#1,r4		;last data?
C6B8:	beq	C6C4
C6BA:	movb	#3A,-(r0)	;':'
C6BE:	cmp	(r5)+,(r5)+	;r5 <- r5 + 4
C6C0:	mov	(r5),r3
C6C2:	sob	r4,C69C		;next data
C6C4:	trap	36		;print a string pointed to by r0
C6C6:	trap	02		;print CR, LF
C6C8:	mov	0E82,@#EA16	;restore the RTC register B
C6CE:	br	C6E4
; write completed
C6D0:	bit	#0100,0E82	;Periodic Interrupts disabled?
C6D6:	beq	C6C8		;exit if not, RTC missing
C6D8:	mov	#0057,@#EA14	;RTC register A,
				;DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
C6DE:	mov	#000E,@#EA16	;RTC register B, binary format, 24h mode
;
C6E4:	jsr	pc,A060		;restore registers from the stack
C6E8:	jmp	86DA

; parameter boundaries - lower and upper limits
C6EC:	.byte	00, 17		;hours 0..23
C6EE:	.byte	00, 3B		;minutes 0..59
66F0:	.byte	00, 3B		;seconds 0..59

; command DATE
; format example: 25-SEP-90 SUN
C6F2:	jsr	pc,A04C		;save registers on the stack
C6F6:	trap	3A		;get a character other than space to r2
C6F8:	dec	r1
C6FA:	clr	0E88		;counter of data
C6FE:	clr	0E86
C702:	mov	#C91D,r5	;parameter boundaries table
C706:	mov	#D76,r3		;scratch buffer
C70A:	mov	@#EA16,0E82	;save the EA16 register
C710:	cmpb	r2,#A		;end of line?
C714:	bne	C71A		;branch if parameters present
C716:	jmp	C822		;jump if no parameters
; command with parameters - set date
C71A:	bis	#100,@#EA16
; day or year (numerical entry expected)
C720:	trap	08		;ATOI
C722:	cmpb	(r5)+,r0	;test the lower limit
C724:	bgt	C7F8
C726:	cmpb	(r5)+,r0	;test the upper limit
C728:	blt	C7F8
C72A:	mov	#EA0E,r5
C72E:	cmp	#2,0E88		;year? (data #2)
C734:	bne	C73C
C736:	mov	#EA12,r5
C73A:	br	C744
C73C:	trap	3A		;get a character other than space to r2
C73E:	cmpb	r2,#2D		;'-'
C742:	bne	C7F8
C744:	asl	r0
C746:	mov	r0,(r3)
C748:	mov	(r3)+,(r5)+
C74A:	cmp	#1,0E88		;month?
C750:	beq	C7E4		;prepare for the year
C752:	cmp	#3,0E88		;day of the week?
C758:	beq	C804		;end of data
C75A:	cmp	#2,0E88		;year?
C760:	beq	C7F0		;prepare for the day of the week
; 0E88 = #0, prepare for the month
C762:	mov	#C8E2,r4	;table of month names
; month or day of the week (alpha entry expected)
C766:	clr	r0
C768:	mov	#2,r5
C76C:	cmp	#A,r0
C770:	blt	C7F8
C772:	cmp	#2,0E88
C778:	bne	C780
C77A:	cmp	#7,r0
C77E:	blt	C7F8
C780:	trap	3A		;get a character other than space to r2
C782:	trap	38		;is r2 a digit?
C784:	bne	C788		;branch if r2 is not a decimal digit
C786:	br	C7F8		;digits not allowed
C788:	inc	r0
C78A:	cmpb	(r4),r2
C78C:	beq	C794
C78E:	add	#3,r4
C792:	br	C788
C794:	trap	3A		;get a character other than space to r2
C796:	trap	38		;is r2 a digit?
C798:	bne	C79C		;branch if r2 is not a decimal digit
C79A:	br	C7F8		;digits not allowed
C79C:	tstb	(r4)+
C79E:	cmpb	(r4),r2
C7A0:	bne	C7AA
C7A2:	cmp	#1,r5
C7A6:	beq	C7C4
C7A8:	sob	r5,C794
C7AA:	cmpb	#1,r5
C7AE:	bne	C7B8
C7B0:	inc	r4
C7B2:	sub	#3,r1
C7B6:	br	C768
C7B8:	add	#2,r4
C7BC:	sub	#2,r1
C7C0:	jmp	C768
C7C4:	cmp	#2,0E88
C7CA:	beq	C7D8
; month
C7CC:	mov	#EA10,r5	;write month register
C7D0:	inc	0E88
C7D4:	jmp	C73C
; day of the week
C7D8:	inc	0E88
C7DC:	mov	#EA0C,r5	;write day of the week register
C7E0:	jmp	C744
; prepare for the year
C7E4:	inc	0E88		;0E88 <- #2
C7E8:	mov	#C91F,r5	;table of year boundaries
C7EC:	jmp	C720
; prepare for the day of the week
C7F0:	mov	#C907,r4	;table of day of the week names
C7F4:	jmp	C766
; invalid data
C7F8:	mov	0E82,@#EA16
C7FE:	jsr	pc,A060		;restore registers from the stack
C802:	trap	3D		;error 30 - wrong parameters
; write completed
C804:	bit	#100,0E82
C80A:	beq	C81A
C80C:	mov	#57,@#EA14
C812:	mov	#E,@#EA16
C818:	br	C8DA
C81A:	mov	0E82,@#EA16
C820:	br	C8DA
; command without parameters - display date
C822:	mov	#4,0E88		;number of items
C828:	bit	#0100,0E82
C82E:	bne	C8DA
C830:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
C834:	mov	r0,0E80
C838:	sub	#4,r0
C83C:	mov	#EA12,r5
C840:	mov	(r5),r3
C842:	bic	#FF00,r3
C846:	asr	r3
C848:	cmp	#3,0E88
C84E:	beq	C87C		;month
C850:	cmp	#1,0E88
C856:	beq	C894		;day of the week
C858:	jsr	pc,C440		;convert word r3 to decimal ASCII
C85C:	cmp	#2,0E86		;two digits?
C862:	beq	C868
C864:	movb	#30,-(r0)
C868:	cmp	#2,0E88
C86E:	beq	C874
C870:	movb	#2D,-(r0)	;'-'
C874:	tst	-(r5)
C876:	dec	0E88
C87A:	br	C840
; month
C87C:	mov	#C8E2,r4	;table of month names
C880:	cmpb	#C,r3
C884:	blt	C7F8		;branch if month > 12
C886:	cmpb	#1,r3
C88A:	bgt	C7F8		;branch if month < 1
C88C:	mul	#3,r3
C890:	add	r3,r4
C892:	br	C8AC
; day of the week
C894:	mov	#C907,r4	;table of day of the week names
C898:	mov	r0,r5
C89A:	mov	0E80,r0
C89E:	cmpb	#7,r3
C8A2:	blt	C8CE		;branch if day > 7
C8A4:	cmpb	#1,r3
C8A8:	bgt	C8CE		;branch if day < 1
C8AA:	br	C88C
C8AC:	mov	#3,r2
C8B0:	movb	-(r4),-(r0)
C8B2:	sob	r2,C8B0
C8B4:	cmp	#1,0E88
C8BA:	bne	C870
C8BC:	movb	#20,-(r0)
C8C0:	mov	r5,r0
C8C2:	trap	36		;print a string pointed to by r0
C8C4:	trap	02		;print CR, LF
C8C6:	mov	0E82,@#EA16
C8CC:	br	C8DA
C8CE:	mov	0E82,@#EA16
C8D4:	jsr	pc,A060		;restore registers from the stack
C8D8:	trap	3D		;error 30 - wrong parameters
C8DA:	jsr	pc,A060		;restore registers from the stack
C8DE:	jmp	86DA

C8E2:	.asciz	"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
C907:	.asciz	"MONTUEWENTHUFRISATSUN"

; parameter boundaries - lower and upper limits
C91D:	.byte	01, 1F		;day 1..31
C91F:	.byte	59, 63		;year 89..99
C921:	.even

; command CALL
C922:	trap	3A		;get a character other than space to r2
C924:	cmpb	r2,#23
C928:	bne	C932
C92A:	jsr	pc,F1BE		;get an octal number to r0
C92E:	dec	r1
C930:	br	C938
C932:	dec	r1
C934:	trap	5E		;evaluate an arithmetical expression
C936:	trap	20		;FIX
C938:	mov	r0,-(sp)
C93A:	trap	3A		;get a character other than space to r2
C93C:	cmpb	r2,#2C
C940:	beq	C946
C942:	dec	r1
C944:	br	C958
C946:	trap	56		;get a variable name to r4
C948:	bvs	C960		;branch if name not found
C94A:	dec	r1
C94C:	clr	r0
C94E:	trap	5C		;r3 = pointer to the variable table
C950:	beq	C960
C952:	trap	4C
C954:	beq	C960
C956:	cmp	(r3)+,(r3)+
C958:	jsr	pc,@(sp)+
C95A:	trap	48
C95C:	jmp	8664
C960:	trap	3D		;error 30 - wrong parameters

; data initialising RAM in address range 0C38..0D41
C962:	      0F 00  0F 00 07 00  05 00 23 00  5C FA 76 FB
C970:	CE F9 5C FA  07 00 05 00  01 00 08 00  01 00 01 00
C980:	01 00 01 00  01 00 01 00  00 00 01 00  02 00 04 00
C990:	00 02 20 20  20 20 20 20  00 00 20 20  20 20 00 00  ..      ..    ..
C9A0:	00 08 0E 73  62 6F 6A 20  70 6F 20 61  64 72 20 20  ...sboj po adr  
C9B0:	20 20 20 20  20 0F 00 0E  6F 7B 20 20  20 20 20 20       ...o{      
C9C0:	20 20 73 74  72 20 0F 00  0E 6F 73 74  20 70 6F 20    str ...ost po 
C9D0:	61 64 72 65  73 75 20 30  30 30 30 30  30 0F 00 0E  adresu 000000...
C9E0:	64 77 20 6F  7B 20 6B 61  6E 61 6C 61  20 20 30 30  dw o{ kanala  00
C9F0:	30 30 30 30  0F 00 0E 6F  7B 20 77 65  6B 20 70 72  0000...o{ wek pr
CA00:	65 72 79 77  20 30 30 30  30 30 30 0F  00 0E 0D 0A  eryw 000000.....
CA10:	6F 7B 20 20  20 20 0F 20  53 20 20 20  20 52 20 20  o{    . S    R  
CA20:	20 00 47 17  03 01 01 00  01 00 F0 0E  00 02 C0 05   .G.......p...@.
CA30:	00 00 44 0F  00 00 00 00  00 00 00 00  4A 0F 40 00  ..D.........J.@.
CA40:	78 00 00 1E  20 00 70 00  01 00 02 00  00 00 18 00  x... .p.........
CA50:	00 00 01 00  FE 0D 00 01  68 01 24 00  8C 01 1C 00  ....~...h.$.....
CA60:	01 00 01 00  01 00 7F 00  04 00 09 00

; RAM initialisation
CA6C:	mov	#200,r0
CA70:	mov	#1F00,r1
CA74:	clr	(r0)+
CA76:	sob	r1,CA74
CA78:	mov	#C962,r0
CA7C:	mov	#85,r1
CA80:	mov	#C38,r2
CA84:	mov	(r0)+,(r2)+
CA86:	sob	r1,CA84
CA88:	rts	pc

; command PATCH
CA8A:	jsr	pc,A04C		;save registers on the stack
CA8E:	mov	@#4,-(sp)
CA92:	mov	#CA9A,@#4
CA98:	br	CAA2

CA9A:	bis	#1,0002(sp)
CAA0:	rti

CAA2:	clr	0E96
CAA6:	jsr	pc,CB18
CAAA:	clr	r3
CAAC:	clr	r4
CAAE:	jsr	pc,BF3A		;wait for a key
CAB2:	cmp	#30,r2
CAB6:	bhi	CAD0
CAB8:	cmp	#37,r2
CABC:	blo	CAD0
CABE:	trap	00		;print character r2
CAC0:	bic	#FFF8,r2
CAC4:	asl	r4
CAC6:	asl	r4
CAC8:	asl	r4
CACA:	add	r2,r4
CACC:	inc	r3
CACE:	br	CAAE
CAD0:	clr	r0
CAD2:	cmpb	r2,CAFA(r0)
CAD6:	beq	CAE2
CAD8:	inc	r0
CADA:	cmp	r0,#8
CADE:	bhis	CB02
CAE0:	br	CAD2
CAE2:	trap	00		;print character r2
CAE4:	asl	r0
CAE6:	jmp	@CAEA(r0)

CAEA:	.word	CB42, CB7C, CBC2, CB82
CAF2:	.word	CBE2, CBEC, CC0E, CBD4

CAFA:	.byte	'/', 0D, 1C, 1D
CAFE:	.byte	'@', '\', 'G', 'E'

CB02:	cmp	#20,r2
CB06:	bhi	CB10
CB08:	cmp	#7F,r2
CB0C:	beq	CB10
CB0E:	trap	00		;print character r2
CB10:	mov	#3F,r2
CB14:	trap	00		;print character r2
CB16:	br	CAA2
CB18:	jsr	pc,CB24
CB1C:	mov	#2A,r2
CB20:	trap	00		;print character r2
CB22:	br	CB26
CB24:	trap	02		;print CR, LF
CB26:	rts	pc
CB28:	tst	r3
CB2A:	beq	CB26
CB2C:	mov	0E94,r0
CB30:	clc
CB32:	cmp	#1,0E96
CB38:	bne	CB3E
CB3A:	movb	r4,(r0)
CB3C:	br	CB26
CB3E:	mov	r4,(r0)
CB40:	br	CB26
CB42:	mov	#2,0E96
CB48:	tst	r3
CB4A:	beq	CB50
CB4C:	mov	r4,0E94
CB50:	mov	0E94,r4
CB54:	asr	r4
CB56:	blo	CB10
CB58:	mov	0E94,r0
CB5C:	clc
CB5E:	mov	(r0),r1
CB60:	blo	CB10
CB62:	mov	(r0),r5
CB64:	mov	#6,r4		;number of digits
CB68:	mov	#EF2,r0		;buffer for the octal number 0EEB-0EF0
CB6C:	clrb	-(r0)
CB6E:	jsr	pc,801A		;convert the word in r1 to octal ASCII
CB72:	trap	36		;print a string pointed to by r0
CB74:	mov	#20,r2
CB78:	trap	00		;print character r2
CB7A:	br	CAAA
CB7C:	jsr	pc,CB28
CB80:	br	CAA2
CB82:	tst	0E96
CB86:	beq	CB10
CB88:	jsr	pc,CB28
CB8C:	add	0E96,0E94
CB92:	mov	0E94,r1
CB96:	jsr	pc,CB24
CB9A:	mov	#EF2,r0		;buffer for the octal number 0EEB-0EF0
CB9E:	clrb	-(r0)
CBA0:	mov	#6,r4		;number of digits
CBA4:	jsr	pc,801A		;convert the word in r1 to octal ASCII
CBA8:	trap	36		;print a string pointed to by r0
CBAA:	cmp	#2,0E96
CBB0:	beq	CBBA
CBB2:	mov	#5C,r2
CBB6:	trap	00		;print character r2
CBB8:	br	CBFA
CBBA:	mov	#2F,r2
CBBE:	trap	00		;print character r2
CBC0:	br	CB50
CBC2:	tst	0E96
CBC6:	beq	CB10
CBC8:	jsr	pc,CB28
CBCC:	sub	0E96,0E94
CBD2:	br	CB92
CBD4:	mov	(sp)+,@#4
CBD8:	jsr	pc,A060		;restore registers from the stack
CBDC:	trap	02		;print CR, LF
CBDE:	jmp	86DA
CBE2:	jsr	pc,CB28
CBE6:	mov	r5,0E94
CBEA:	br	CB92
CBEC:	mov	#1,0E96
CBF2:	tst	r3
CBF4:	beq	CBFA
CBF6:	mov	r4,0E94
CBFA:	mov	0E94,r0
CBFE:	clc
CC00:	movb	(r0),r1
CC02:	bic	#FF00,r1
CC06:	blo	CB10
CC08:	mov	#3,r4
CC0C:	br	CB68
CC0E:	tst	r3
CC10:	beq	CBC6
CC12:	mov	r4,0E94
CC16:	asr	r4
CC18:	blo	CB56
CC1A:	jmp	@0E94

; command RENUM
CC1E:	jsr	pc,A04C		;save registers on the stack
CC22:	mov	r5,-(sp)
CC24:	clr	r3
CC26:	mov	#D76,r4
CC2A:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
CC2E:	blo	CC5A
CC30:	tst	r0
CC32:	bne	CC3A
CC34:	mov	#A,(r4)+
CC38:	br	CC3C
CC3A:	mov	r0,(r4)+
CC3C:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
CC40:	blo	CC5A
CC42:	tst	r0
CC44:	bne	CC52
CC46:	mov	r1,-(sp)
CC48:	jsr	pc,CE6E
CC4C:	mov	(sp)+,r1
CC4E:	mov	r0,(r4)+
CC50:	br	CC54
CC52:	mov	r0,(r4)+
CC54:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
CC58:	bhis	CC62
CC5A:	tst	(sp)+
CC5C:	jsr	pc,A060		;restore registers from the stack
CC60:	trap	3D		;error 30 - wrong parameters
CC62:	tst	r0
CC64:	bne	CC6C
CC66:	mov	#A,(r4)
CC6A:	br	CC6E
CC6C:	mov	r0,(r4)
CC6E:	mov	0EF2,r1
CC72:	jsr	pc,CE6E
CC76:	mov	#D76,r4
CC7A:	cmp	r0,0002(r4)
CC7E:	beq	CC96
CC80:	trap	42		;move the pointer r1 to the end of the line
CC82:	cmp	r1,(sp)
CC84:	bne	CC8E
CC86:	tst	(sp)+
CC88:	jsr	pc,A060		;restore registers from the stack
CC8C:	trap	43		;error 33 - illegal use of the RENUM operator
CC8E:	mov	r1,0E72
CC92:	trap	08		;ATOI
CC94:	br	CC76
CC96:	mov	0E72,-(sp)
CC9A:	mov	r0,-(sp)
CC9C:	trap	3A		;get a character other than space to r2
CC9E:	cmpb	r2,#3A
CCA2:	beq	CC9C
CCA4:	cmpb	r2,#A
CCA8:	bne	CCB4
CCAA:	cmp	r1,0004(sp)
CCAE:	bne	CC9C
CCB0:	jmp	CDD8
CCB4:	tstb	r2
CCB6:	bpl	CC9C
CCB8:	cmpb	r2,#8D
CCBC:	beq	CCDA
CCBE:	cmpb	r2,#8B
CCC2:	beq	CD08
CCC4:	cmpb	r2,#8C
CCC8:	beq	CD08
CCCA:	cmpb	r2,#B2
CCCE:	bne	CC9C
CCD0:	trap	3A		;get a character other than space to r2
CCD2:	trap	38		;is r2 a digit?
CCD4:	bne	CCD0		;branch if r2 is not a decimal digit
CCD6:	dec	r1
CCD8:	br	CD08
CCDA:	trap	3A		;get a character other than space to r2
CCDC:	cmpb	r2,#47
CCE0:	beq	CCE8
CCE2:	cmpb	r2,#54
CCE6:	bne	CCDA
CCE8:	dec	r1
CCEA:	trap	60		;get a pair of characters to r4
CCEC:	cmp	r4,#474F	;"GO"
CCF0:	beq	CD04
CCF2:	cmp	r4,#5448	;"TH"
CCF6:	bne	CCDA
CCF8:	trap	60		;get a pair of characters to r4
CCFA:	trap	3A		;get a character other than space to r2
CCFC:	trap	38		;is r2 a digit?
CCFE:	bne	CCB4		;branch if r2 is not a decimal digit
CD00:	dec	r1
CD02:	br	CD08
CD04:	trap	60		;get a pair of characters to r4
CD06:	br	CD08
CD08:	trap	3A		;get a character other than space to r2
CD0A:	dec	r1
CD0C:	mov	r1,0E94
CD10:	clr	0E98
CD14:	cmpb	-(r1),#A
CD18:	bne	CD14
CD1A:	inc	r1
CD1C:	trap	08		;ATOI
CD1E:	mov	r0,-(sp)
CD20:	mov	0E94,r1
CD24:	trap	3A		;get a character other than space to r2
CD26:	trap	38		;is r2 a digit?
CD28:	beq	CD3A		;branch if r2 is a decimal digit
CD2A:	cmpb	r2,#3A
CD2E:	beq	CD40
CD30:	cmpb	r2,#A
CD34:	beq	CD40
CD36:	tst	(sp)+
CD38:	br	CC9C
CD3A:	jsr	pc,CE7C
CD3E:	br	CD24
CD40:	mov	0E94,r1
CD44:	trap	08		;ATOI
CD46:	mov	r0,r3
CD48:	jsr	pc,CE6E
CD4C:	cmp	r0,r3
CD4E:	beq	CD78
CD50:	trap	42		;move the pointer r1 to the end of the line
CD52:	cmp	r1,0006(sp)
CD56:	beq	CD5C
CD58:	trap	08		;ATOI
CD5A:	br	CD4C
CD5C:	mov	0002(sp),r2
CD60:	mov	0004(sp),r1
CD64:	clr	0E96
CD68:	inc	0E96
CD6C:	cmp	r2,(sp)
CD6E:	beq	CE42
CD70:	trap	42		;move the pointer r1 to the end of the line
CD72:	trap	08		;ATOI
CD74:	mov	r0,r2
CD76:	br	CD68
CD78:	mov	0002(sp),r2
CD7C:	mov	0004(sp),r1
CD80:	clr	0E96
CD84:	inc	0E96
CD88:	cmp	r2,r3
CD8A:	beq	CDA4
CD8C:	trap	42		;move the pointer r1 to the end of the line
CD8E:	cmp	r1,0006(sp)
CD92:	bne	CD9E
CD94:	tst	(sp)+
CD96:	mov	0E9A,r1
CD9A:	jmp	CC9C
CD9E:	trap	08		;ATOI
CDA0:	mov	r0,r2
CDA2:	br	CD84
CDA4:	tst	(sp)+
CDA6:	jsr	pc,CE86
CDAA:	cmp	0E98,r5
CDAE:	beq	CDBC
CDB0:	sub	0E98,r5
CDB4:	tst	r5
CDB6:	bmi	CDD2
CDB8:	jsr	pc,CED0
CDBC:	movb	(r4)+,@0E94
CDC0:	tstb	(r4)
CDC2:	beq	CDCA
CDC4:	inc	0E94
CDC8:	br	CDBC
CDCA:	mov	0E9A,r1
CDCE:	jmp	CC9C
CDD2:	jsr	pc,CEAA
CDD6:	br	CDBC
CDD8:	mov	0002(sp),0E94
CDDE:	mov	0002(sp),r1
CDE2:	clr	0E96
CDE6:	clr	0E98
CDEA:	trap	3A		;get a character other than space to r2
CDEC:	trap	38		;is r2 a digit?
CDEE:	bne	CDF6		;branch if r2 is not a decimal digit
CDF0:	jsr	pc,CE7C
CDF4:	br	CDEA
CDF6:	inc	0E96
CDFA:	jsr	pc,CE86
CDFE:	cmp	0E98,r5
CE02:	beq	CE16
CE04:	sub	0E98,r5
CE08:	tst	r5
CE0A:	bmi	CE12
CE0C:	jsr	pc,CED0
CE10:	br	CE16
CE12:	jsr	pc,CEAA
CE16:	movb	(r4)+,@0E94
CE1A:	tstb	(r4)
CE1C:	beq	CE24
CE1E:	inc	0E94
CE22:	br	CE16
CE24:	mov	0E9A,r1
CE28:	cmpb	(r1)+,#A
CE2C:	bne	CE28
CE2E:	cmp	r1,0004(sp)
CE32:	bne	CE3C
CE34:	mov	r1,0D66
CE38:	jmp	CEFC
CE3C:	mov	r1,0E94
CE40:	br	CDE6
CE42:	tst	(sp)+
CE44:	mov	#CF10,r0	;string 'nedopustimaja ssylka' (bad link)
CE48:	trap	36		;print a string pointed to by r0
CE4A:	trap	02		;print CR, LF
CE4C:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
CE50:	jsr	pc,C440		;convert word r3 to decimal ASCII
CE54:	trap	36		;print a string pointed to by r0
CE56:	mov	#2D,r2
CE5A:	trap	00		;print character r2
CE5C:	jsr	pc,CE86
CE60:	trap	36		;print a string pointed to by r0
CE62:	trap	02		;print CR, LF
CE64:	mov	0E94,r1
CE68:	trap	08		;ATOI
CE6A:	jmp	CC9C
CE6E:	mov	0EF2,r1
CE72:	inc	r1
CE74:	mov	r1,0E72
CE78:	trap	08		;ATOI
CE7A:	rts	pc
CE7C:	mov	r1,0E9A
CE80:	inc	0E98
CE84:	rts	pc
CE86:	mov	#D76,r5
CE8A:	mov	(r5)+,r2
CE8C:	mov	0002(r5),r3
CE90:	mov	0E96,r4
CE94:	dec	r4
CE96:	mul	r4,r3
CE98:	add	r2,r3
CE9A:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
CE9E:	jsr	pc,C440		;convert word r3 to decimal ASCII
CEA2:	mov	0E86,r5		;number of digits
CEA6:	mov	r0,r4
CEA8:	rts	pc
CEAA:	mov	0E9A,r0
CEAE:	add	r5,0E9A
CEB2:	mov	0E9A,r2
CEB6:	mov	r2,r3
CEB8:	movb	(r0)+,(r2)+
CEBA:	cmp	r0,0006(sp)
CEBE:	bne	CEB8
CEC0:	mov	r2,0006(sp)
CEC4:	clrb	(r2)+
CEC6:	cmp	r2,r0
CEC8:	bne	CEC4
CECA:	mov	r3,0E9A
CECE:	rts	pc
CED0:	mov	0006(sp),r0
CED4:	add	r5,0006(sp)
CED8:	mov	0006(sp),r2
CEDC:	cmp	sp,r2
CEDE:	ble	CEF0
CEE0:	movb	(r0),(r2)
CEE2:	movb	-(r0),-(r2)
CEE4:	cmp	r0,0E9A
CEE8:	bne	CEE2
CEEA:	mov	r2,0E9A
CEEE:	rts	pc
CEF0:	cmp	(sp)+,(sp)+
CEF2:	tst	(sp)+
CEF4:	mov	(sp)+,r5
CEF6:	jsr	pc,A060		;restore registers from the stack
CEFA:	trap	01		;error 0 - out of memory
CEFC:	cmp	(sp)+,(sp)+
CEFE:	tst	(sp)+
CF00:	jsr	pc,A060		;restore registers from the stack
CF04:	mov	0D66,r5
CF08:	clr	0EF6
CF0C:	jmp	86DA

CF10:	0E 4E 45 44  4F 50 55 53  54 49 4D 41  51 20 53 53  .NEDOPUSTIMAQ SS
CF20:	59 4C 4B 41  0F 0D 0A 00  E6 10 26 11  C3 15 03 00  YLKA....f.&.C...

; command PAINT
CF28:	mov	r3,-(sp)
CF2A:	mov	r4,-(sp)
CF2C:	mov	#3,r3		;number of arguments
CF30:	mov	#D78,r4
CF34:	jsr	pc,AB7A		;evaluate arithm. expression to integer in R0
CF38:	bhis	CF40
CF3A:	mov	(sp)+,r4
CF3C:	mov	(sp)+,r3
CF3E:	trap	3D		;error 30 - wrong parameters
CF40:	mov	r0,(r4)+
CF42:	sob	r3,CF34
CF44:	mov	-(r4),0E88
CF48:	mov	-(r4),0C50
CF4C:	mov	-(r4),0D46
CF50:	mov	(sp)+,r4
CF52:	mov	(sp)+,r3
CF54:	mov	r5,0DCA
CF58:	mov	r1,0DCE
CF5C:	jsr	pc,CF70
CF60:	trap	48
CF62:	tst	0F00
CF66:	beq	CF6C
CF68:	jmp	86BE
CF6C:	jmp	8664
CF70:	mov	sp,0DC6
CF74:	jsr	pc,A04C		;save registers on the stack
CF78:	mov	0E88,r1
CF7C:	asl	r1
CF7E:	asl	r1
CF80:	asl	r1
CF82:	mov	#F422,0E84
CF88:	add	r1,0E84
CF8C:	clr	r2
CF8E:	mov	0D16,r3
CF92:	mul	0D14,r3
CF96:	div	#10,r2
CF9A:	mov	0D04,r1
CF9E:	clr	(r1)+
CFA0:	sob	r2,CF9E
CFA2:	mov	0D46,r4
CFA6:	mov	0C50,r0
CFAA:	mov	0C56,-(sp)
CFAE:	mov	#8000,-(sp)
CFB2:	jsr	pc,D1AC
CFB6:	bvc	CFC0
CFB8:	cmp	#7,r2
CFBC:	bvs	D008
CFBE:	br	CFC6
CFC0:	jsr	pc,D1AC
CFC4:	bvc	CFC0
CFC6:	mov	r4,-(sp)
CFC8:	mov	r0,-(sp)
CFCA:	tst	(sp)
CFCC:	bmi	D008
CFCE:	jsr	pc,D0B8
CFD2:	cmp	#C000,(sp)
CFD6:	beq	D008
CFD8:	tst	r0
CFDA:	bgt	CFE4
CFDC:	inc	r0
CFDE:	jsr	pc,D014
CFE2:	br	CFCA
CFE4:	cmp	#3F,r0
CFE8:	bgt	CFF2
CFEA:	dec	r0
CFEC:	jsr	pc,D014
CFF0:	br	CFCA
CFF2:	mov	r0,0D66
CFF6:	dec	r0
CFF8:	jsr	pc,D014
CFFC:	mov	0D66,r0
D000:	inc	r0
D002:	jsr	pc,D014
D006:	br	CFCA
D008:	tst	(sp)+
D00A:	mov	(sp)+,0C56
D00E:	jsr	pc,A060		;restore registers from the stack
D012:	rts	pc
D014:	mov	(sp)+,0E76
D018:	mov	0E74,r4
D01C:	jsr	pc,D180
D020:	bvs	D056
D022:	jsr	pc,D15C
D026:	bne	D056
D028:	dec	r4
D02A:	jsr	pc,D180
D02E:	bvs	D054
D030:	jsr	pc,D15C
D034:	bne	D054
D036:	inc	r4
D038:	inc	r4
D03A:	jsr	pc,D15C
D03E:	bne	D04C
D040:	jsr	pc,D1AC
D044:	bvs	D048
D046:	br	D040
D048:	mov	r4,-(sp)
D04A:	mov	r0,-(sp)
D04C:	mov	0E74,r4
D050:	dec	r4
D052:	br	D06E
D054:	beq	D0B2
D056:	dec	r4
D058:	bne	D06E
D05A:	jsr	pc,D180
D05E:	bvs	D0B2
D060:	jsr	pc,D15C
D064:	bne	D0B2
D066:	inc	r4
D068:	mov	r4,-(sp)
D06A:	mov	r0,-(sp)
D06C:	br	D0B2
D06E:	cmp	r4,0E72
D072:	ble	D0B2
D074:	jsr	pc,D180
D078:	bvs	D056
D07A:	jsr	pc,D15C
D07E:	bne	D056
D080:	inc	r4
D082:	jsr	pc,D180
D086:	bvc	D08C
D088:	mov	r4,-(sp)
D08A:	mov	r0,-(sp)
D08C:	dec	r4
D08E:	cmp	r4,#7
D092:	bge	D09E
D094:	sub	#7,r4
D098:	mov	r4,r3
D09A:	clr	r4
D09C:	br	D0A4
D09E:	sub	#7,r4
D0A2:	clr	r3
D0A4:	jsr	pc,D1E4
D0A8:	bvs	D056
D0AA:	cmp	r4,0E72
D0AE:	ble	D0B2
D0B0:	br	D08E
D0B2:	mov	0E76,-(sp)
D0B6:	rts	pc
D0B8:	mov	(sp)+,0E76
D0BC:	mov	(sp)+,r0
D0BE:	mov	(sp)+,r4
D0C0:	mov	r4,0E74
D0C4:	dec	r4
D0C6:	jsr	pc,D15C
D0CA:	bne	D14E
D0CC:	tst	r4
D0CE:	beq	D108
D0D0:	cmp	r4,#7
D0D4:	bge	D0E0
D0D6:	sub	#7,r4
D0DA:	mov	r4,r3
D0DC:	clr	r4
D0DE:	br	D0E6
D0E0:	clr	r3
D0E2:	sub	#7,r4
D0E6:	jsr	pc,D1E4
D0EA:	bvc	D0D0
D0EC:	mov	r4,0E72
D0F0:	mov	0E74,r4
D0F4:	dec	r4
D0F6:	cmp	r4,0E72
D0FA:	bne	D108
D0FC:	tst	0E72
D100:	bne	D156
D102:	jsr	pc,D180
D106:	bvs	D156
D108:	jsr	pc,D15C
D10C:	bisb	r1,(r5)
D10E:	mov	r4,r3
D110:	mov	r0,r5
D112:	bic	#FFF8,r3
D116:	bic	#FFF8,r5
D11A:	add	0E84,r5
D11E:	clr	r1
D120:	movb	(r5),r1
D122:	mov	#7,r2
D126:	sub	r3,r2
D128:	neg	r3
D12A:	ash	r3,r1
D12C:	neg	r3
D12E:	ash	r3,r1
D130:	swab	r1
D132:	clrb	r1
D134:	ash	r2,r1
D136:	mov	#3,0C56
D13C:	mov	r4,0D46
D140:	mov	r0,0C50
D144:	jsr	pc,A30A
D148:	tst	r4
D14A:	beq	D156
D14C:	br	D0F4
D14E:	tst	(sp)
D150:	bge	D0BC
D152:	bis	#4000,(sp)
D156:	mov	0E76,-(sp)
D15A:	rts	pc
D15C:	clr	r2
D15E:	mov	r0,r5
D160:	mov	r4,r3
D162:	div	#8,r2
D166:	mul	0D16,r5
D16A:	asr	r5
D16C:	asr	r5
D16E:	asr	r5
D170:	add	r2,r5
D172:	mov	#1,r1
D176:	ash	r3,r1
D178:	add	0D04,r5
D17C:	bitb	r1,(r5)
D17E:	rts	pc
D180:	cmp	#77,r4
D184:	blt	D1A6
D186:	tst	r4
D188:	bmi	D1A6
D18A:	mov	#4,0C56
D190:	clr	r1
D192:	mov	r4,0D46
D196:	mov	r0,0C50
D19A:	jsr	pc,A30A
D19E:	tst	r1
D1A0:	bmi	D1A6
D1A2:	clear	v
D1A4:	rts	pc
D1A6:	clc
D1A8:	set	v
D1AA:	br	D1A4
D1AC:	mov	r4,0D46
D1B0:	mov	r0,0C50
D1B4:	cmp	#77,r4
D1B8:	blt	D1DE
D1BA:	clr	r1
D1BC:	mov	#7,r2
D1C0:	mov	#4,0C56
D1C6:	jsr	pc,A30A
D1CA:	cmp	#77,r4
D1CE:	blt	D1DE
D1D0:	asl	r1
D1D2:	blo	D1DE
D1D4:	inc	r4
D1D6:	dec	r2
D1D8:	bge	D1CA
D1DA:	clear	v
D1DC:	rts	pc
D1DE:	clc
D1E0:	set	v
D1E2:	br	D1DC
D1E4:	mov	r4,0D46
D1E8:	mov	r0,0C50
D1EC:	clr	r1
D1EE:	mov	#7,r2
D1F2:	mov	#4,0C56
D1F8:	jsr	pc,A30A
D1FC:	add	#7,r4
D200:	swab	r1
D202:	tst	r3
D204:	beq	D20C
D206:	ash	r3,r1
D208:	neg	r3
D20A:	sub	r3,r4
D20C:	asrb	r1
D20E:	blo	D21E
D210:	tst	r4
D212:	beq	D21E
D214:	dec	r4
D216:	dec	r2
D218:	bge	D20C
D21A:	clear	v
D21C:	rts	pc
D21E:	clc
D220:	set	v
D222:	br	D21C

; command TRON
D224:	mov	#1,0F08
D22A:	trap	48
D22C:	jmp	8664

; command TROFF
D230:	clr	0F08
D234:	trap	48
D236:	jmp	8664

D23A:	mov	r1,-(sp)
D23C:	mov	#5B,r2		;'['
D240:	trap	00		;print character r2
D242:	trap	3A		;get a character other than space to r2
D244:	trap	38		;is r2 a digit?
D246:	bne	D24C		;branch if r2 is not a decimal digit
D248:	trap	00		;print character r2
D24A:	br	D242
D24C:	mov	#5D,r2		;']'
D250:	trap	00		;print character r2
D252:	mov	(sp)+,r1
D254:	rts	pc

; file access routine
; byte 0(R0) - ?
; byte 1(R0) - action:	0 - kill file
;			1 - read file
;			2 - write file
;			3 - rename file
;			4 - ?
; word 2(R0) - pointer to the file name(s) in the Radix-50 format
D256:	jsr	pc,A04C		;save registers on the stack
D25A:	mov	#FFFF,0F38
D260:	mov	#FFFF,0F3A
D266:	mov	r0,r1
D268:	cmpb	(r1),#2
D26C:	bhis	D2AA
D26E:	movb	(r1)+,0F24
D272:	cmpb	(r1),#5		;action code
D276:	bhis	D2B0		;invalid command
D278:	mov	0F24,r3
D27C:	jsr	pc,DF18		;check the memory module
D280:	movb	(r1)+,r2	;action code
D282:	mov	(r1)+,(sp)	;pointer to the file name(s)
D284:	mov	(sp),r0
D286:	mov	r1,0F32
D28A:	tst	(r1)+
D28C:	mov	r1,0F34
D290:	tst	(r1)+
D292:	mov	r1,0F36
D296:	clr	r5
D298:	asl	r2
D29A:	tst	(r2)+		;R2 <- R2 + 2
D29C:	add	pc,r2		;D29E+0002 = D2A0
D29E:	add	(r2),pc

D2A0:	.word	007A		;D2A0+007A = D31A, kill file
D2A2:	.word	001A		;D2A0+001A = D2BA, read file
D2A4:	.word	008C		;D2A0+008C = D32C, write file
D2A6:	.word	0016		;D2A0+0016 = D2B6, rename file
D2A8:	.word	033E		;D2A0+033E = D5DE

D2AA:	mov	#-1,(sp)
D2AE:	br	D312

D2B0:	mov	#-2,(sp)
D2B4:	br	D312

; rename file
D2B6:	mov	#40,r5
; read file
D2BA:	jsr	r5,D4A6
D2BE:	mov	r4,0F30
D2C2:	jsr	r5,D6B4
D2C6:	br	D30E

D2C8:	mov	#8,-(sp)
D2CC:	tst	r5
D2CE:	bne	D2F0
D2D0:	add	(sp)+,r1
D2D2:	mov	0F30,@0F34
D2D8:	mov	(r1),(sp)
D2DA:	mov	(r1)+,@0F32
D2DE:	mov	0004(r1),@0F36
D2E4:	clr	0F1C
D2E8:	clc
D2EA:	jsr	pc,A060		;restore registers from the stack
D2EE:	rts	pc

D2F0:	add	#6,r0
D2F4:	mov	#200,(r1)+
D2F8:	mov	(r0)+,(r1)+
D2FA:	mov	(r0)+,(r1)+
D2FC:	mov	(r0)+,(r1)+
D2FE:	sub	(sp)+,r1
D300:	jmp	D616

D304:	clr	(sp)
D306:	br	D2E4

D308:	mov	#-3,(sp)
D30C:	br	D312
D30E:	mov	#-4,(sp)
D312:	clr	0F1C
D316:	sec
D318:	br	D2EA

; kill file
D31A:	jsr	r5,D4A6
D31E:	jsr	r5,D6B4
D322:	br	D30E

D324:	mov	#200,(r1)
D328:	jmp	D672

; write file
D32C:	clr	0F38
D330:	mov	#80,r5
D334:	jsr	r5,D4A6
D338:	mov	05C4,0F2E
D33E:	clr	0F26
D342:	clr	0F28
D346:	br	D34E
D348:	jsr	r5,D4EE
D34C:	br	D392
D34E:	jsr	pc,D566
D352:	mov	r4,0F30
D356:	mov	#F26,r5
D35A:	jsr	r5,D4BA
D35E:	.word	0200
D360:	br	D348
D362:	mov	0008(r1),r0
D366:	mov	@0F32,r2
D36A:	beq	D372
D36C:	cmp	#FFFF,r2
D370:	bne	D3B8
D372:	cmp	(r5)+,r0
D374:	bhis	D388
D376:	cmp	(r5),r0
D378:	bhis	D382
D37A:	mov	(r5),-(r5)
D37C:	add	#8,r5
D380:	mov	-(r5),-(r5)
D382:	mov	r0,-(r5)
D384:	mov	r3,0004(r5)
D388:	add	r0,0F30
D38C:	jsr	pc,D686
D390:	br	D356
D392:	tst	(r5)+
D394:	mov	@0F32,r2
D398:	bne	D3A4
D39A:	ror	(r5)
D39C:	cmp	(r5),-(r5)
D39E:	blo	D3A8
D3A0:	tst	(r5)+
D3A2:	br	D3A8
D3A4:	inc	r2
D3A6:	bne	D308
D3A8:	mov	(r5),@0F32
D3AC:	beq	D308
D3AE:	mov	0004(r5),r3
D3B2:	jsr	r5,D4F8
D3B6:	.word	01CB
D3B8:	cmp	r0,r2
D3BA:	blo	D388
D3BC:	mov	r1,-(sp)
D3BE:	mov	0F3E,r1		;DREND
D3C2:	jsr	pc,D684
D3C6:	jsr	pc,D686
D3CA:	cmp	r1,#09C0
D3CE:	bhi	D430
D3D0:	mov	(sp)+,r1
D3D2:	mov	0F30,r4
D3D6:	mov	r1,r5
D3D8:	sub	r2,0008(r1)
D3DC:	sub	#E,r5
D3E0:	sub	05C6,r5
D3E4:	cmp	r5,#5CA
D3E8:	blo	D400
D3EA:	bit	#100,(r5)
D3EE:	beq	D400
D3F0:	jsr	pc,D4D0
D3F4:	mov	#200,(r1)
D3F8:	clr	0008(r1)
D3FC:	jsr	pc,D686
D400:	jsr	pc,D4D0
D404:	mov	#100,(r1)+
D408:	mov	(sp),r0
D40A:	mov	(r0)+,(r1)+
D40C:	mov	(r0)+,(r1)+
D40E:	mov	(r0)+,(r1)+
D410:	mov	r2,(r1)+
D412:	clr	(r1)+
D414:	mov	@#2C,(r1)
D418:	add	#B2,(r1)
D41C:	mov	@0000(r1),(r1)
D420:	mov	r2,@0F32
D424:	mov	r4,@0F34
D428:	jsr	r5,D532
D42C:	jmp	D2E4

; EXTEND:
; enlarge the size of a directory
D430:	tst	(sp)+
D432:	mov	0F2E,r2
D436:	inc	0F1C
D43A:	cmp	r2,05C0
D43E:	bge	D49E
D440:	mov	#5C8,r1
D444:	mov	r1,r4
D446:	add	#1FC,r4
D44A:	mov	(r1)+,r5
D44C:	jsr	pc,D67E
D450:	cmp	r1,r4
D452:	blo	D44C
D454:	clr	r4
D456:	bit	#500,(r1)
D45A:	beq	D44C
D45C:	mov	(r1),-(sp)
D45E:	mov	#800,(r1)
D462:	inc	r2
D464:	mov	05C2,-(sp)
D468:	mov	r2,05C2
D46C:	jsr	r5,D532
D470:	mov	#5C0,r0
D474:	tst	(r0)+
D476:	mov	(sp)+,(r0)+
D478:	mov	(sp)+,(r1)
D47A:	cmp	(r0)+,(r0)+
D47C:	mov	r5,(r0)+
D47E:	mov	(r1)+,(r0)+
D480:	cmp	r1,#09C0
D484:	blos	D47E
D486:	mov	r2,r0
D488:	jsr	r5,D538
D48C:	jsr	r5,D52A
D490:	inc	05C4
D494:	jsr	r5,D532
D498:	dec	0F1C
D49C:	br	D3B2
D49E:	mov	#FFFB,(sp)
D4A2:	jmp	D312

D4A6:	bis	(sp),0F3C
D4AA:	mov	#1,r3
D4AE:	jsr	r5,D4F8
D4B2:	.word	0102
D4B4:	tst	(r5)+
D4B6:	tst	(r5)+
D4B8:	rts	r5

; ENTRY:
; scan for entry of specified type in current segment
D4BA:	bit	(r5),(r1)
D4BC:	bne	D4B4
D4BE:	bit	(r1),#800
D4C2:	bne	D4B6
D4C4:	add	0008(r1),0F30
D4CA:	jsr	pc,D686
D4CE:	br	D4BA

; PUSH:
; make room in current directory segment for new entry
D4D0:	mov	r3,-(sp)
D4D2:	mov	r1,r5
D4D4:	jsr	r5,D4BA
D4D8:	.word	0000
D4DA:	mov	r1,r3
D4DC:	jsr	pc,D686
D4E0:	cmp	(r3)+,(r1)+
D4E2:	mov	-(r3),-(r1)
D4E4:	cmp	r3,r5
D4E6:	bne	D4E2
D4E8:	mov	r5,r1
D4EA:	mov	(sp)+,r3
D4EC:	rts	pc

D4EE:	mov	05C2,r0
D4F2:	beq	D528
D4F4:	mov	r0,r3
D4F6:	tst	(r5)+
D4F8:	mov	r0,-(sp)
D4FA:	mov	r3,r0
D4FC:	bic	#FFE0,r0
D500:	cmp	r0,0F38
D504:	bne	D50E
D506:	cmp	0F24,0F3A
D50C:	beq	D51A
D50E:	mov	r0,0F38
D512:	mov	r3,-(sp)
D514:	jsr	r5,D530
D518:	mov	(sp)+,r3
D51A:	mov	0F24,0F3A
D520:	mov	#5C8,r1
D524:	mov	(r1)+,r4
D526:	mov	(sp)+,r0
D528:	rts	r5

; SEGRD1:
; read directory segments
D52A:	mov	#1,0F38
D530:	cmp	#A1,pc		;instead of SEC : BR D454
; SEGWR:
; write directory segments
; D532:	clc
D534:	mov	0F38,r0
; SEGRW:
D538:	jsr	r0,D542
D53C:	.word	0002		;number of sectors
D53E:	.word	05C0		;USRBUF
D540:	.word	0F24		;device number

; Carry set = read, Carry cleared = write
D542:	mov	(r0)+,r1	;number of sectors
D544:	mov	(r0)+,r2	;source/destination address
D546:	mov	@(r0)+,r3	;device number
D548:	mov	(sp)+,r0
D54A:	rol	r0
D54C:	add	0F56,r0
D550:	bit	#1,r0		;read or write?
D554:	beq	D560
D556:	bic	#1,r0
D55A:	jsr	pc,D77A		;read sectors from the memory module
D55E:	br	D564
D560:	jsr	pc,D7A0		;write sectors to the memory module
D564:	rts	r5

; CONSOL:
; remove unnecessary entries from a directory
D566:	mov	r4,-(sp)
D568:	mov	r3,-(sp)
D56A:	mov	r1,-(sp)
D56C:	mov	#E,r4
D570:	add	05C6,r4
D574:	jsr	r5,D4BA
D578:	.word	0100
D57A:	br	D574
D57C:	mov	#200,(r1)
D580:	add	r4,r1
D582:	br	D574
D584:	mov	(sp),r1
D586:	jsr	r5,D4BA
D58A:	.word	0200
D58C:	br	D5D2
D58E:	mov	r1,r2
D590:	add	r4,r2
D592:	bit	#200,(r2)
D596:	beq	D5B6
D598:	add	0008(r2),0008(r1)
D59E:	mov	r2,r5
D5A0:	add	r4,r5
D5A2:	mov	r1,-(sp)
D5A4:	jsr	r5,D4BA
D5A8:	.word	0000
D5AA:	mov	r1,r3
D5AC:	mov	(r5)+,(r2)+
D5AE:	cmp	r5,r3
D5B0:	blos	D5AC
D5B2:	mov	(sp)+,r1
D5B4:	br	D586
D5B6:	tst	0008(r1)
D5BA:	bne	D5CE
D5BC:	mov	r1,r2
D5BE:	mov	r1,r3
D5C0:	sub	r4,r3
D5C2:	cmp	r3,#5CA
D5C6:	blo	D5CE
D5C8:	bit	#400,(r3)
D5CC:	bne	D59E
D5CE:	add	r4,r1
D5D0:	br	D586
D5D2:	mov	r1,0F3E
D5D6:	mov	(sp)+,r1
D5D8:	mov	(sp)+,r3
D5DA:	mov	(sp)+,r4
D5DC:	rts	pc

D5DE:	mov	#1,r3
D5E2:	jsr	r5,D4F8
D5E6:	.word	0103
D5E8:	jsr	r5,D4EE
D5EC:	br	D676
D5EE:	mov	(sp),r0
D5F0:	jsr	r5,D4BA
D5F4:	.word	0100
D5F6:	br	D5E8
D5F8:	tst	(r1)+
D5FA:	mov	r1,r2
D5FC:	add	#6,r2
D600:	cmp	(r0)+,(r1)+
D602:	beq	D60E
D604:	mov	r2,r1
D606:	cmp	(r1)+,(r1)+
D608:	add	05C6,r1
D60C:	br	D5EE
D60E:	cmp	r1,r2
D610:	bne	D600
D612:	sub	#8,r1
D616:	mov	#F26,r0
D61A:	mov	(r1)+,(r0)+
D61C:	mov	(r1)+,(r0)+
D61E:	mov	(r1)+,(r0)+
D620:	mov	(r1),(r0)
D622:	cmp	-(r0),-(r0)
D624:	cmp	-(r1),-(r1)
D626:	mov	r1,-(sp)
D628:	mov	r3,-(sp)
D62A:	mov	#1,r3
D62E:	jsr	r5,D6B4
D632:	br	D646
D634:	mov	#200,(r1)
D638:	mov	r3,r1
D63A:	cmp	r1,(sp)
D63C:	beq	D646
D63E:	inc	0F1C
D642:	jsr	pc,D690
D646:	mov	(sp)+,r3
D648:	jsr	r5,D4F8
D64C:	.word	1581
D64E:	mov	#400,-(r1)
D652:	bit	#40,0F3C
D658:	bne	D6A2
D65A:	add	#8,r1
D65E:	mov	(r1),r2
D660:	mov	@0F32,(r1)
D664:	mov	0D66,0006(r1)
D66A:	sub	(r1),r2
D66C:	jsr	pc,D686
D670:	add	r2,(r1)
D672:	jsr	pc,D690
D676:	dec	0F1C
D67A:	jmp	D304

; INCR1A:
; move R1 past one or two directory entries
D67E:	add	0008(r1),r5
D682:	br	D686
; INCR2:
D684:	mov	pc,-(sp)
; INCR1:
D686:	add	05C6,r1
D68A:	add	#E,r1
D68E:	rts	pc

; CLOSUP:
; consolidate and rewrite a directory segment
D690:	mov	r0,-(sp)
D692:	mov	#5CA,r1
D696:	jsr	pc,D566
D69A:	jsr	r5,D532
D69E:	mov	(sp)+,r0
D6A0:	rts	pc

D6A2:	tst	(r1)+
D6A4:	mov	(r0)+,(r1)+
D6A6:	mov	(r0)+,(r1)+
D6A8:	mov	(r0)+,(r1)+
D6AA:	cmp	(r1)+,(r1)+
D6AC:	bic	#40,0F3C
D6B2:	br	D672

D6B4:	mov	r0,-(sp)
D6B6:	jsr	r5,D4F8
D6BA:	.word	1380
D6BC:	jsr	r5,D4BA
D6C0:	.word	0400
D6C2:	br	D6EC
D6C4:	tst	(r1)+
D6C6:	mov	r1,r2
D6C8:	add	#6,r2
D6CC:	cmp	(r0)+,(r1)+
D6CE:	bne	D6DE
D6D0:	cmp	r1,r2
D6D2:	bne	D6CC
D6D4:	sub	#8,r1
D6D8:	tst	(r5)+
D6DA:	mov	(sp)+,r0
D6DC:	rts	r5
D6DE:	mov	r2,r1
D6E0:	add	(r1)+,0F30
D6E4:	cmp	(r1)+,(r1)+
D6E6:	add	05C6,r1
D6EA:	br	D6BA
D6EC:	jsr	r5,D4EE
D6F0:	br	D6DA
D6F2:	br	D6BA

; write to the memory module address register
; R0 points to the buffer containing the address
D6F4:	jsr	pc,A04C		;save registers on the stack
D6F8:	mov	#3,r1		;number of address bytes
D6FC:	tst	0F54		;memory module type
D700:	bne	D704		;skip if a ROM module
D702:	dec	r1		;two address bytes for a RAM module
D704:	mov	sp,r2
D706:	clr	r0
D708:	jsr	r5,D738
D70C:	.word	D718		;rts pc
D70E:	.word	00A8		;Write Address
D710:	.word	0000
D712:	.word	D72E		;movb @0(r2),@#E810; inc (r2)
D714:	jsr	pc,A060		;restore registers from the stack
D718:	rts	pc

D71A:	tstb	@#E814
D71E:	bpl	D71A
D720:	rts	pc

D722:	movb	@#E810,(r2)+
D726:	rts	pc

D728:	movb	(r2)+,@#E810
D72C:	rts	pc

D72E:	movb	@0000(r2),@#E810
D734:	inc	(r2)
D736:	rts	pc

; number of bytes in r1
; device number in r3
; the call to this procedure should be followed by:
; 1. address of the procedure called before the transfer
; 2. code to be written to the E816 register (command for the memory module)
; 3. bit mask for the E814 register (data direction)
; 4. address of the data transfer procedure
D738:	mov	#0009,@#E812
D73E:	jsr	pc,@(r5)+	;procedure called before the transfer
D740:	tst	@#E816		;terminate the previous transfer
D744:	bic	#FFFE,r3
D748:	bis	#00F8,r3
D74C:	mov	r3,@#E814
D750:	mov	(r5)+,@#E816	;command for the SMP module
D754:	jsr	pc,D71A
D758:	bic	(r5)+,r3
D75A:	mov	r3,@#E814
D75E:	jsr	pc,D71A
D762:	jsr	pc,@0000(r5)	;call the data transfer procedure
D766:	jsr	pc,D71A
D76A:	dec	r1
D76C:	bne	D762
D76E:	tst	@#E816		;end of the transfer
D772:	tst	(r5)+
D774:	jsr	pc,D71A
D778:	rts	r5

; read R1 sectors from the memory module starting from the sector R0
D77A:	jsr	pc,D7DA		;convert the sector number in R0 to an address
D77E:	swab	r1		;convert the number of sectors to read to ...
D780:	asl	r1		;... the number of bytes
D782:	jsr	pc,DF18		;check the memory module
D786:	mov	#F52,r0		;r0 = pointer to the source address bytes
D78A:	tst	0F54		;memory module type
D78E:	beq	D792		;skip if a RAM module
D790:	dec	r0		;address bytes 0F51..0F53 if a ROM module
; read a memory block from the SMP
; pointer to the buffer containing the source address in r0
; destination address in r2
; number of bytes in r1
; device number in r3
D792:	jsr	r5,D738
D796:	.word	D6F4		;write to the SMP address register
D798:	.word	00D8		;Read Postincrement
D79A:	.word	0008
D79C:	.word	D722		;movb @#E810,(r2)+
D79E:	br	D7C2

; write R1 sectors to the memory module starting from the sector R0
D7A0:	jsr	pc,D7DA		;convert the sector number in R0 to an address
D7A4:	swab	r1		;convert the number of sectors to write to ...
D7A6:	asl	r1		;... the number of bytes
; write a memory block to the SMP
; destination address in 0F52 (bytes in big endian order)
; source address in r2
; number of bytes in r1
; device number in r3
D7A8:	jsr	pc,DF18		;check the memory module
D7AC:	mov	#F52,r0		;r0 = pointer to the destination address bytes
D7B0:	tst	0F54		;memory module type
D7B4:	bne	D7C2		;skip if a ROM module
D7B6:	jsr	r5,D738
D7BA:	.word	D6F4		;write to the SMP address register
D7BC:	.word	00C8		;Write Postincrement
D7BE:	.word	0000
D7C0:	.word	D728		;movb (r2)+,@#E810
D7C2:	bic	#FFFE,r3
D7C6:	bis	#58,r3
D7CA:	mov	r3,@#E814
D7CE:	mov	#A2,@#E814
D7D4:	bic	#FFFE,r3
D7D8:	rts	pc

; convert the sector number in R0 to an address in 0F51..0F53
D7DA:	clr	0F50
D7DE:	clr	0F52
D7E2:	asl	r0
D7E4:	movb	r0,0F52
D7E8:	swab	r0
D7EA:	movb	r0,0F51
D7EE:	rts	pc

; erase the SMP with spaces
D7F0:	clr	0F50
D7F4:	mov	#FFFF,0F52	;obligatory destination address
D7FA:	mov	#F51,r0		;r0 = pointer to the destination address bytes
D7FE:	clr	r1		;number of bytes (65536 decimal)
D800:	jsr	r5,D738
D804:	.word	D6F4		;write to the SMP address register
D806:	.word	0020		;Erase Postdecrement
D808:	.word	0000
D80A:	.word	D80E		;movb #20,@#E810
D80C:	br	D7C2

D80E:	movb	#20,@#E810
D814:	rts	pc

; fetch a file name pointed to by R1 and convert it to Radix-50
; output buffer pointed to by R0
; returns Carry set in case of illegal characters in the file name
D816:	clr	(r0)+
D818:	clr	(r0)+
D81A:	mov	r0,r4
D81C:	clr	(r0)
D81E:	cmp	-(r0),-(r0)
D820:	mov	#5B5B,r3
D824:	trap	3A		;get a character other than space to r2
D826:	trap	38		;is r2 a digit?
D828:	bvs	D858
D82A:	bne	D830		;branch if r2 is not a decimal digit
D82C:	add	#2E,r2
D830:	sub	#40,r2
D834:	asrb	r3
D836:	bhis	D848
D838:	asl	r2
D83A:	asl	r2
D83C:	asl	r2
D83E:	mov	r2,-(sp)
D840:	asl	r2
D842:	asl	r2
D844:	add	(sp)+,r2
D846:	br	D834
D848:	cmp	r0,r4
D84A:	beq	D864
D84C:	add	r2,(r0)
D84E:	asrb	r3
D850:	blo	D824
D852:	tst	(r0)+
D854:	swab	r3
D856:	br	D824
D858:	cmpb	r2,#2E
D85C:	bne	D868
D85E:	mov	r4,r0
D860:	tst	(r4)+
D862:	br	D820
D864:	sec
D866:	rts	pc
D868:	clc
D86A:	rts	pc

D86C:	mov	r1,-(sp)
D86E:	trap	4E
D870:	tst	0EF6
D874:	bne	D87A
D876:	mov	r5,0EF6
D87A:	mov	0EF6,r4
D87E:	mov	0EF2,r3
D882:	sub	r3,r4
D884:	movb	(r3)+,r2
D886:	bmi	D8AA
D888:	cmp	r2,#A
D88C:	bne	D890
D88E:	inc	r4
D890:	cmp	r3,0EF6
D894:	blo	D884
D896:	inc	r4
D898:	add	#1FF,r4
D89C:	clrb	r4
D89E:	swab	r4
D8A0:	asr	r4
D8A2:	mov	r4,0004(r0)
D8A6:	mov	(sp)+,r1
D8A8:	rts	pc
D8AA:	mov	#8878,r1
D8AE:	dec	r4
D8B0:	bic	#FF80,r2
D8B4:	beq	D8BE
D8B6:	cmpb	(r1)+,#24
D8BA:	bne	D8B6
D8BC:	sob	r2,D8B6
D8BE:	cmpb	(r1)+,#24
D8C2:	beq	D890
D8C4:	inc	r4
D8C6:	br	D8BE

; fetch the file name optionally preceded by the device name
D8C8:	mov	r0,-(sp)
D8CA:	trap	3A		;get a character other than space to r2
D8CC:	cmpb	r2,#22		;quotation mark
D8D0:	bne	D908
D8D2:	mov	r1,-(sp)
D8D4:	trap	60		;get a pair of characters to r4
D8D6:	cmp	r4,#534D	;"SM"
D8DA:	bne	D900
D8DC:	trap	08		;ATOI
D8DE:	mov	r0,r4
D8E0:	mov	0002(sp),r0
D8E4:	cmpb	(r1)+,#3A	;colon
D8E8:	bne	D900
D8EA:	mov	r4,(r0)+
D8EC:	tst	(sp)+
D8EE:	mov	(r0)+,r0	;R0 points to the output buffer
D8F0:	jsr	pc,D816		;fetch the filename and convert it to Radix-50
D8F4:	blo	D908		;branch if illegal characters in the filename
D8F6:	cmpb	r2,#22		;quotation mark
D8FA:	bne	D908
D8FC:	mov	(sp)+,r0
D8FE:	rts	pc
D900:	mov	(sp)+,r1
D902:	mov	0F1E,(r0)+
D906:	br	D8EE
D908:	tst	(sp)+
D90A:	trap	7F		;error 63 - illegal file name

; print 'vy uvereny?' (are you sure?) then wait for a key
D90C:	mov	r0,-(sp)
D90E:	mov	r1,-(sp)
D910:	mov	r3,-(sp)
D912:	mov	#DFBC,r0	;string 'vy uvereny?' (are you sure?)
D916:	trap	36		;print a string pointed to by r0
D918:	trap	40		;input a line from the keyboard
D91A:	movb	(r1),r2		;r2 = key code
D91C:	mov	(sp)+,r3
D91E:	mov	(sp)+,r1
D920:	mov	(sp)+,r0
D922:	rts	pc

; command KILL
D924:	mov	#D06,r0
D928:	jsr	pc,D8C8		;fetch the device and file name
D92C:	jsr	pc,D90C		;print 'vy uvereny?' (are you sure?)
D930:	cmpb	#59,r2		;'Y'
D934:	bne	D94C
D936:	mov	(r0),r3
D938:	jsr	pc,DF18		;check the memory module
D93C:	tst	0F54		;memory module type
D940:	beq	D944		;skip if a RAM module
D942:	trap	71		;error 56 - file write protected
D944:	jsr	pc,D256		;file access
D948:	bhis	D94C
D94A:	trap	7D		;error 62 - file not found
D94C:	trap	02		;print CR, LF
D94E:	jmp	86DA

; command LOAD
D952:	clr	0D66
D956:	mov	#D06,r0
D95A:	jsr	pc,D8C8		;fetch the device and file name
D95E:	clr	0E80
D962:	mov	r3,-(sp)
D964:	mov	r1,-(sp)
D966:	trap	60		;get a pair of characters to r4
D968:	cmp	r4,#2C41	;",A"
D96C:	beq	D98E
D96E:	tst	0F48
D972:	bne	D97A
D974:	mov	#CAB,0F48
D97A:	inc	0E80
D97E:	cmp	r4,#2C52	;",R"
D982:	bne	D99A
D984:	inc	0E80
D988:	inc	0EFC
D98C:	mov	r1,(sp)
D98E:	tst	0F48
D992:	bne	D99A
D994:	mov	#CBB,0F48
D99A:	movb	#1,0001(r0)	;read file
D9A0:	jsr	pc,D256		;file access
D9A4:	blo	D94A
D9A6:	swab	0D0A
D9AA:	asl	0D0A
D9AE:	mov	0D0C,r2
D9B2:	clr	0F50
D9B6:	clr	0F52
D9BA:	asl	r2
D9BC:	movb	r2,0F52
D9C0:	swab	r2
D9C2:	movb	r2,0F51
D9C6:	mov	#1,0EFC
D9CC:	tst	0E80
D9D0:	beq	D9E0
D9D2:	mov	0EF2,r3
D9D6:	jsr	pc,DA0A
D9DA:	inc	r3
D9DC:	mov	r3,r5
D9DE:	br	D9D6
D9E0:	mov	r1,(sp)
D9E2:	trap	60		;get a pair of characters to r4
D9E4:	cmp	r4,#2C52	",R"
D9E8:	bne	D9F0
D9EA:	inc	0EFC
D9EE:	mov	r1,(sp)
D9F0:	mov	(sp)+,r1
D9F2:	mov	(sp)+,r3
D9F4:	mov	0EF2,r5
D9F8:	inc	r5
D9FA:	clr	0EF6
D9FE:	clr	0F00
DA02:	clr	0EF0
DA06:	jmp	8664

DA0A:	jsr	pc,A04C		;save registers on the stack
DA0E:	mov	#1,r1
DA12:	mov	r3,r2
DA14:	mov	0F24,r3
DA18:	jsr	pc,D782
DA1C:	jsr	r5,DA3C
DA20:	.word	0001
DA22:	jsr	pc,A060		;restore registers from the stack
DA26:	movb	(r3),r2
DA28:	beq	DA5A
DA2A:	bic	#FF00,r2
DA2E:	add	r2,0D66
DA32:	dec	0D0A
DA36:	bgt	DA3A
DA38:	trap	73		;error 57 - file overflow
DA3A:	rts	pc

DA3C:	mov	0F50,r1
DA40:	swab	r1
DA42:	mov	0F52,r0
DA46:	swab	r0
DA48:	add	(r5)+,r0
DA4A:	adc	r1
DA4C:	swab	r0
DA4E:	mov	r0,0F52
DA52:	swab	r1
DA54:	mov	r1,0F50
DA58:	rts	r5

DA5A:	cmp	0D66,0D0E
DA60:	beq	DA64
DA62:	trap	75		;error 58 - checksum error
DA64:	tst	0E80
DA68:	bne	DA6C
DA6A:	tst	(sp)+
DA6C:	tst	(sp)+
DA6E:	mov	(sp)+,r1
DA70:	mov	(sp)+,r3
DA72:	mov	#1,0CFC
DA78:	asr	0EFC
DA7C:	bhis	DA82
DA7E:	jmp	D94C
DA82:	clr	0EFC
DA86:	jmp	8AAA

; command NAME
DA8A:	mov	#D06,r0
DA8E:	jsr	pc,D8C8		;fetch the device and file name
DA92:	trap	60		;get a pair of characters to r4
DA94:	cmp	r4,#4153	;"AS"
DA98:	bne	DAC4
DA9A:	mov	#D10,r0
DA9E:	jsr	pc,D8C8		;fetch the device and file name
DAA2:	mov	#D06,r0
DAA6:	mov	(r0),r3
DAA8:	jsr	pc,DF18		;check the memory module
DAAC:	tst	0F54		;memory module type
DAB0:	beq	DAB4		;skip if a RAM module
DAB2:	trap	71		;error 56 - file write protected
DAB4:	movb	#3,0001(r0)	;rename file
DABA:	jsr	pc,D256		;file access
DABE:	blo	DAC6
DAC0:	jmp	86DA
DAC4:	trap	7B		;error 61 - wrong NAME operator format
DAC6:	trap	79		;error 60 - renamed file not found

; command SAVE
DAC8:	clr	0D66
DACC:	mov	#D06,r0
DAD0:	jsr	pc,D86C
DAD4:	jsr	pc,D8C8		;fetch the device and file name
DAD8:	mov	(r0),r3
DADA:	jsr	pc,DF18		;check the memory module
DADE:	tst	0F54		;memory module type
DAE2:	beq	DAE6		;skip if a RAM module
DAE4:	trap	71		;error 56 - file write protected
DAE6:	clr	0E80
DAEA:	mov	r1,-(sp)
DAEC:	trap	60		;get a pair of characters to r4
DAEE:	cmp	r4,#2C41	",A"
DAF2:	beq	DB20
DAF4:	mov	(sp)+,r1
DAF6:	tst	0F48
DAFA:	bne	DB02
DAFC:	mov	#CAB,0F48
DB02:	inc	0E80
DB06:	mov	r5,r4
DB08:	mov	0EF2,r3
DB0C:	sub	r3,r4
DB0E:	inc	r4
DB10:	add	#1FF,r4
DB14:	clrb	r4
DB16:	swab	r4
DB18:	asr	r4
DB1A:	mov	r4,0004(r0)
DB1E:	br	DB2E
DB20:	tst	(sp)+
DB22:	tst	0F48
DB26:	bne	DB2E
DB28:	mov	#CBB,0F48
DB2E:	movb	#2,0001(r0)	;write file
DB34:	jsr	pc,D256		;file access
DB38:	bhis	DB3C
DB3A:	trap	77		;error 59 - SMP overflow
DB3C:	mov	0D0C,r2
DB40:	swab	r2
DB42:	asl	r2
DB44:	mov	r2,0F22
DB48:	tst	0E80
DB4C:	beq	DB6A
DB4E:	mov	0EF2,r0
DB52:	mov	r5,-(sp)
DB54:	trap	4E
DB56:	movb	(r0)+,r2
DB58:	jsr	pc,DB74
DB5C:	cmp	r0,r5
DB5E:	blo	DB56
DB60:	mov	(sp)+,r5
DB62:	jsr	pc,DBA4
DB66:	jmp	86D6
DB6A:	mov	#1,0EFE
DB70:	jmp	8520

DB74:	jsr	pc,A04C		;save registers on the stack
DB78:	mov	0F22,r0		;destination address
DB7C:	swab	r0
DB7E:	mov	r0,0F52
DB82:	mov	#2,r1		;number of bytes to write
DB86:	mov	0F24,r3
DB8A:	mov	sp,r2
DB8C:	cmp	(r2)+,(r2)+	;r2 = source address
DB8E:	clrb	0001(r2)
DB92:	jsr	pc,D7A8		;write a memory block to the SMP
DB96:	inc	0F22
DB9A:	jsr	pc,A060		;restore registers from the stack
DB9E:	add	r2,0D66
DBA2:	rts	pc

DBA4:	mov	#D06,r0
DBA8:	movb	#4,0001(r0)
DBAE:	jsr	pc,D256		;file access
DBB2:	rts	pc

; command INIT
DBB4:	mov	#D06,r0
DBB8:	jsr	pc,DDBE		;test for the end of the command line
DBBC:	beq	DBC2		;skip if command without parameters
DBBE:	jsr	pc,D8C8		;fetch the device and file name
DBC2:	jsr	pc,D90C		;print 'vy uvereny?' (are you sure?)
DBC6:	cmpb	#59,r2		;'Y'
DBCA:	bne	DC52
DBCC:	mov	r1,-(sp)
DBCE:	mov	(r0),r3		;device number
DBD0:	jsr	pc,D7F0		;erase the SMP with spaces
DBD4:	jsr	pc,DF18		;check the memory module
DBD8:	tst	0F54		;memory module type
DBDC:	beq	DBE0		;skip if a RAM module
DBDE:	trap	71		;error 56 - file write protected
DBE0:	clr	r4
DBE2:	clr	0F50
DBE6:	clr	0F52
; determine the SMP memory size
DBEA:	mov	#1,r1		;number of bytes
DBEE:	mov	#F52,r0		;source address
DBF2:	mov	#5C0,r2		;destination address
DBF6:	movb	#FF,(r2)
DBFA:	jsr	pc,D792		;read a memory block from the SMP
DBFE:	cmpb	05C0,#FF
DC04:	beq	DC1C
DC06:	cmpb	05C0,#20
DC0C:	bne	DC18
DC0E:	inc	r4
DC10:	jsr	r5,DA3C
DC14:	.word	0800
DC16:	br	DBEA
DC18:	trap	6F		;error 55 - input/output error
DC1A:	trap	77		;error 59 - SMP overflow
DC1C:	asl	r4
DC1E:	asl	r4
DC20:	sub	0C64,r4
DC24:	ble	DC1A
DC26:	mov	r4,0C6E
DC2A:	clr	0F38
DC2E:	mov	#DE80,r4	;data blocks copied to the SMP
DC32:	mov	#4,-(sp)	;number of copied blocks
DC36:	mov	(r4)+,r0	;destination address
DC38:	swab	r0
DC3A:	mov	r0,0F52
DC3E:	mov	(r4)+,r2	;source address
DC40:	mov	(r4)+,r1	;number of bytes to write
DC42:	mov	r4,-(sp)
DC44:	jsr	pc,D7A8		;write a memory block to the SMP
DC48:	mov	(sp)+,r4
DC4A:	dec	(sp)		;counter of copied blocks
DC4C:	bne	DC36		;next block
DC4E:	tst	(sp)+
DC50:	mov	(sp)+,r1
DC52:	jmp	86DA

; command FILES
DC56:	jsr	pc,A04C		;save registers on the stack
DC5A:	mov	#D06,r0
DC5E:	jsr	pc,DDBE		;test for the end of the command line
DC62:	beq	DC6C		;branch if command without parameters
DC64:	jsr	pc,D8C8		;fetch the device and file name
DC68:	mov	r1,0002(sp)
DC6C:	mov	(r0),0F24
DC70:	mov	(r0),r3
DC72:	jsr	pc,DF18		;check the memory module
DC76:	clr	0F26
DC7A:	clr	0F28
DC7E:	clr	0F2A
DC82:	clr	r5
DC84:	jsr	r5,D4A6
DC88:	mov	r4,0F30
DC8C:	mov	#5,r5
DC90:	jsr	pc,DD9A
DC94:	jsr	r5,D4BA
DC98:	.word	0600
DC9A:	br	DD1E
DC9C:	jsr	pc,DD84
DCA0:	bit	(r1)+,#400
DCA4:	bne	DCBE
DCA6:	mov	#DDF9,r4
DCAA:	movb	(r4)+,(r0)+
DCAC:	bne	DCAA
DCAE:	movb	#20,-(r0)
DCB2:	cmpb	(r0)+,(r0)+
DCB4:	add	#6,r1
DCB8:	add	(r1),0F26
DCBC:	br	DCE0
DCBE:	jsr	pc,DE2C
DCC2:	add	(r1),0F2A
DCC6:	inc	0F28
DCCA:	mov	#EA7,r0
DCCE:	mov	#EA8,r4
DCD2:	movb	-(r0),-(r4)
DCD4:	movb	-(r0),-(r4)
DCD6:	movb	-(r0),-(r4)
DCD8:	movb	#2E,-(r4)
DCDC:	add	#6,r0
DCE0:	mov	(r1),r3
DCE2:	jsr	pc,DD6C
DCE6:	cmpb	(r0)+,(r0)+
DCE8:	mov	0F30,r3
DCEC:	jsr	pc,DD6C
DCF0:	clrb	(r0)+
DCF2:	mov	#E9E,r0		;input line buffer
DCF6:	trap	36		;print a string pointed to by r0
DCF8:	trap	02		;print CR, LF
DCFA:	add	(r1)+,0F30
DCFE:	cmp	(r1)+,(r1)+
DD00:	add	05C6,r1
DD04:	sob	r5,DC94
DD06:	tst	0F20
DD0A:	bne	DD16
DD0C:	jsr	pc,BF3A		;wait for a key
DD10:	cmpb	r2,#D
DD14:	bne	DD60
DD16:	trap	02		;print CR, LF
DD18:	mov	#6,r5
DD1C:	br	DC94
DD1E:	jsr	r5,D4EE
DD22:	br	DD26
DD24:	br	DC94
DD26:	cmp	r5,#6
DD2A:	beq	DD3A
DD2C:	jsr	pc,DD94
DD30:	tst	0F20
DD34:	bne	DD3A
DD36:	jsr	pc,BF3A		;wait for a key
DD3A:	mov	#4,r5
DD3E:	jsr	pc,DD94
DD42:	mov	#DE1E,r5
DD46:	mov	@(r5)+,r3
DD48:	jsr	pc,DD84
DD4C:	jsr	pc,DD6C
DD50:	clrb	0001(r0)
DD54:	cmpb	-(r0),-(r0)
DD56:	trap	36		;print a string pointed to by r0
DD58:	mov	(r5)+,r0
DD5A:	trap	36		;print a string pointed to by r0
DD5C:	tst	(r5)
DD5E:	bne	DD46
DD60:	jsr	pc,A060		;restore registers from the stack
DD64:	clr	0F20
DD68:	jmp	86DA
DD6C:	clr	r2
DD6E:	div	#A,r2
DD72:	beq	DD7A
DD74:	bis	#30,r2
DD78:	movb	r2,(r0)
DD7A:	inc	r0
DD7C:	bis	#30,r3
DD80:	movb	r3,(r0)+
DD82:	rts	pc
DD84:	mov	#A,r2
DD88:	mov	#EB2,r0
DD8C:	mov	#2020,-(r0)
DD90:	sob	r2,DD8C
DD92:	rts	pc
DD94:	trap	02		;print CR, LF
DD96:	sob	r5,DD94
DD98:	rts	pc

DD9A:	mov	0D5C,-(sp)
DD9E:	mov	#DE06,r0	;string 'Spravochnik' (directory)
DDA2:	trap	36		;print a string pointed to by r0
DDA4:	bis	#1,0D5C
DDAA:	trap	36		;print a string pointed to by r0
DDAC:	mov	0F24,r2
DDB0:	bis	#30,r2
DDB4:	trap	00		;print character r2
DDB6:	trap	36		;print a string pointed to by r0
DDB8:	mov	(sp)+,0D5C
DDBC:	rts	pc

; test for the end of the command line
DDBE:	mov	0F1E,(r0)
DDC2:	trap	3A		;get a character other than space to r2
DDC4:	dec	r1
DDC6:	cmpb	r2,#A
DDCA:	beq	DDD0
DDCC:	cmpb	r2,#3A
DDD0:	rts	pc

DDD0:	87 00 0E 46  41 4A 4C 4F  57 2C 20 00  42 4C 4F 4B  ...FAJLOW, .BLOK
DDE0:	4F 57 0D 0A  00 53 57 4F  42 4F 44 4E  59 48 20 42  OW...SWOBODNYH B
DDF0:	4C 4F 4B 4F  57 0F 0D 0A  00 0E 3C 53  57 4F 42 4F  LOKOW.....<SWOBO
DE00:	44 4E 4F 3E  0F 00 20 20  00 0E 20 73  50 52 41 57  DNO>..  .. sPRAW
DE10:	4F 5E 4E 49  4B 0F 20 53  4D 00 20 0D  0A 00 28 0F  O^NIK. SM. ...(.
DE20:	D2 DD 2A 0F  DC DD 26 0F  E5 DD 00 00

DE2C:	mov	r0,-(sp)
DE2E:	mov	r3,-(sp)
DE30:	mov	r4,-(sp)
DE32:	mov	r5,-(sp)
DE34:	mov	#3,r4
DE38:	sub	r4,r0
DE3A:	mov	#3,r5
DE3E:	add	#6,r0
DE42:	mov	(r1)+,r3
DE44:	jsr	pc,DE58		;expansion of the Radix-50 encoded word
DE48:	movb	r2,-(r0)
DE4A:	sob	r5,DE44
DE4C:	sob	r4,DE3A
DE4E:	mov	(sp)+,r5
DE50:	mov	(sp)+,r4
DE52:	mov	(sp)+,r3
DE54:	mov	(sp)+,r0
DE56:	rts	pc

; expansion of the Radix-50 encoded word
DE58:	clr	r2
DE5A:	div	#28,r2
DE5E:	mov	r3,-(sp)
DE60:	mov	r2,r3
DE62:	mov	(sp)+,r2
DE64:	beq	DE7A
DE66:	cmp	r2,#1B
DE6A:	blt	DE76
DE6C:	beq	DE72
DE6E:	add	#9,r2
DE72:	add	#FFC9,r2
DE76:	add	#20,r2
DE7A:	add	#20,r2
DE7E:	rts	pc

; data copied to the SMP by the INIT command
; destination address, source address, number of bytes
DE80:	.word	0400, 0C5C, 001C
DE86:	.word	0000, DE98, 003C
DE8C:	.word	0200, DED4, 0002
DE92:	.word	03D2, DED6, 0025

; boot loader written to the SMP
DE98:	nop
DE9A:	jsr	pc,@#CA6C	;RAM initialisation
DE9E:	jsr	pc,@#A4D4
DEA2:	mov	@#0D02,@#E800	;address of the display RAM
DEA8:	mov	#88C6,@#E802
DEAE:	jsr	r0,DECA
DEB2:	.asciz	"\016\r\n smp BEZ ZAGRUZ^IKA"	;SMP without loader
DEC9:	.even
DECA:	movb	(r0)+,r2
DECC:	beq	DECC
DECE:	jsr	pc,@#A01C	;display character r2
DED2:	br	DECA

DED4:	             00 00 01 00  06 00 50 8E  42 41 53 49  ......P.BASI
DEE0:	43 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20  C               
DEF0:	20 20 20 20  20 20 20 20  20 20 20 FF  C0 15 06 0D             .@...

; command DEV
DEFC:	mov	#D06,r0
DF00:	jsr	pc,DDBE		;test for the end of the command line
DF04:	bne	DF0C		;branch if command with parameters
DF06:	clr	0F1E
DF0A:	br	DF14
DF0C:	jsr	pc,D8C8		;fetch the device and file name
DF10:	mov	(r0),0F1E
DF14:	jmp	86DA

; check the memory module
; returns 0 in the variable 0F54 if write test passed
DF18:	jsr	pc,A04C		;save registers on the stack
DF1C:	mov	#1,0F54		;memory module type <- ROM
DF22:	mov	0F50,-(sp)
DF26:	mov	0F52,-(sp)
; read data at location 0000
DF2A:	clr	0F50
DF2E:	clr	0F52
DF32:	mov	#E82,r2		;destination address
DF36:	clr	(r2)
DF38:	mov	#F51,r0		;source address
DF3C:	mov	#1,r1		;number of bytes
DF40:	jsr	pc,D792		;read a memory block from the SMP
DF44:	mov	#E82,r2		;source address
DF48:	mov	(r2),0D66
; complement data at location 0000
DF4C:	comb	(r2)
DF4E:	mov	#F51,r0		;destination address
DF52:	mov	#1,r1		;number of bytes
DF56:	jsr	pc,D7B6		;write a memory block to the SMP
; verify data at location 0000
DF5A:	mov	#E82,r2		;destination address
DF5E:	clr	(r2)
DF60:	mov	#F51,r0		;source address
DF64:	mov	#1,r1		;number of bytes
DF68:	jsr	pc,D792		;read a memory block from the SMP
DF6C:	cmpb	0E82,0D66
DF72:	beq	DF94
; restore original data at location 0000
DF74:	mov	#D66,r2		;source address
DF78:	mov	#F51,r0		;destination address
DF7C:	mov	#1,r1		;number of bytes
DF80:	jsr	pc,D7B6		;write a memory block to the SMP
DF84:	clr	0F54		;memory module type <- RAM
DF88:	clr	0F56
DF8C:	mov	#4,0C64
DF92:	br	DFAE
DF94:	cmpb	#FF,0E82
DF9A:	bne	DF9E
DF9C:	trap	6B		;error 53 - SMP not ready
DF9E:	mov	#4,0F56
DFA4:	mov	#8,0C64
DFAA:	inc	0F54		;memory module type <- ROM
DFAE:	mov	(sp)+,0F52
DFB2:	mov	(sp)+,0F50
DFB6:	jsr	pc,A060		;restore registers from the stack
DFBA:	rts	pc

DFBC:	0E 57 59 20  .WY 
DFC0:	55 57 45 52  45 4E 59 3F  0F 00 FF FF  FF FF FF FF  UWERENY?........


; HALT mode vectors

E000:	.word	0000		;power on
E002:	.word	E00E, 00E0	;HALT in the HALT mode
E006:	.word	E012, 00E0	;double bus error
E00A:	.word	E018, 00E0	;interrupt vector error

; instruction HALT or signal HALT in the HALT mode handler routine
E00E:	clr	r0
E010:	br	E01C
; double bus error handler routine
E012:	mov	#2,r0
E016:	br	E01C
; interrupt vector error handler routine
E018:	mov	#4,r0
E01C:	tst	@#28
E020:	beq	E028
; the location 0028 can contain the address of alternative handler routines
E022:	add	@#28,r0
E026:	jmp	(r0)
; The default handler routine displays an error message followed by the
; address where the event has occurred, then hangs the system.
E028:	mov	(sp),r1		;error address taken from the stack
; The above instruction indicates that upon entering the HALT mode the PSW
; and the PC registers are stored on the system stack instead of special
; registers, unlike in the 1801VM1 or 1801VM2 processors.
E02A:	mov	#200,sp
E02E:	mov	E04E(r0),r0	;pointer to the message
E032:	mov	r0,r5
E034:	add	#15,r0		;end of the buffer for the octal number
E038:	mov	#6,r4		;number of digits
E03C:	jsr	pc,801A		;convert the word in r1 to octal ASCII
E040:	mov	r5,r0
E042:	movb	(r0)+,r2
E044:	beq	E04C
E046:	jsr	pc,A01C		;display character r2
E04A:	br	E042
E04C:	br	E04C		;hang the system

E04E:	.word	0C9E	;string "OST PO ADRESU 000000" - stop at address...
E050:	.word	0CB5	;string "DW OSH KANALA 000000" - double bus error 
E052:	.word	0CCC	;string "OSH WEK PRERYW 000000" - interr. vector error

; tests
E054:	mov	#200,sp
E058:	jsr	pc,E05E
E05C:	br	E09C

E05E:	jsr	pc,@#CA6C	;RAM initialisation
E062:	mov	#1,@#D5E
E068:	jsr	pc,@#A4D4
E06C:	mov	#3,0C56
E072:	mov	#BD68,@#C8	;keyboard controller interrupt vector
E078:	clr	@#CA
E07C:	mov	#0036,@#E812
E082:	mov	#E2,@#E814
E088:	mov	@#0D02,@#E800	;address of the display RAM
E08E:	mov	#88C6,@#E802
E094:	mov	#1,0D60
E09A:	rts	pc

E09C:	clr	@#C50
E0A0:	clr	@#D46
E0A4:	inc	0D5E
E0A8:	bis	#21,0D5C
E0AE:	mov	#E16C,r1	;string "TESTY" (tests)
E0B2:	jsr	pc,E0FA		;display the string pointed to by r1
E0B6:	bic	#1,0D5C
E0BC:	mov	#E114,r1
E0C0:	jsr	pc,E0FA		;display the string pointed to by r1
E0C4:	mov	#E15E,r1	;string "NOMER TESTA"
E0C8:	mov	#20,0C50
E0CE:	clr	0D46
E0D2:	jsr	pc,E0FA		;display the string pointed to by r1
E0D6:	jsr	pc,@#BF3A	;wait for a key
E0DA:	jsr	pc,@#A01C	;display character r2
E0DE:	bic	#FFF8,r2
E0E2:	dec	r2
E0E4:	asl	r2
E0E6:	clr	@#D5E
E0EA:	cmp	#4,r2
E0EE:	bge	E0F6
E0F0:	mov	#1000,@#E81A	;RAM address range 0000-3FFF
				;ROM address range 4000-DFFF, EC00-FDFF
E0F6:	jmp	@E106(r2)

; display a zero terminated string pointed to by r1
E0FA:	movb	(r1)+,r2
E0FC:	beq	E104
E0FE:	jsr	pc,@#A01C	;display character r2
E102:	br	E0FA
E104:	rts	pc

; addresses of test procedures
E106:	.word	45C6, 41BC, 4000, E184, E184, E184, F600

E114:	             0E 31 20 73  6D 70 20 20  32 20 4B 4C      .1 smp  2 KL
E120:	41 57 49 41  54 55 52 41  20 33 20 76  6B 69 20 20  AWIATURA 3 vki  
E130:	34 20 4D 41  47 4E 49 54  4F 46 4F 4E  20 35 20 61  4 MAGNITOFON 5 a
E140:	64 73 61 20  36 20 54 45  4C 45 57 49  5A 4F 52 20  dsa 6 TELEWIZOR 
E150:	20 0D 0A 0D  0A 37 20 77  59 48 4F 44  20 00 4E 4F   ....7 wYHOD .NO
E160:	4D 45 52 20  54 45 53 54  41 3A 0F 00  0E 20 20 20  MER TESTA:...   
E170:	20 20 20 20  54 45 53 54  59 20 20 20  20 20 20 20      TESTY       
E180:	20 0F 00 FF

; call the test procedure from the MK-92 ROM
; R2=6 - "vki", R2=8 - tape recorder, R2=A - "adsa", R2=C - tv
E184:	jsr	pc,A04C		;save registers on the stack
E188:	mov	@#E880,r1
E18C:	tst	@#E81E
E190:	bmi	E1E8
E192:	mov	#2000,@#E880	;switch the memory banks, MK-92 ROM enabled
E198:	sub	#6,r2
E19C:	add	#4012,r2	;table of addresses of the test procedures
E1A0:	mov	r2,r4
E1A2:	bit	#2,@#E81E
E1A8:	bne	E1C8
E1AA:	mov	#4,r3		;number of ROM pages in the MK-92
; find the MK-92 ROM page which contains valid data
E1AE:	clr	r0
E1B0:	cmp	#0CBB,@#4000
E1B6:	bne	E1DA		;invalid data, try the next ROM page
E1B8:	cmp	r0,@#400C
E1BC:	bne	E1DA		;invalid data, try the next ROM page
E1BE:	tst	(r4)
E1C0:	ble	E1DA		;invalid data, try the next ROM page
E1C2:	mov	r1,-(sp)
E1C4:	jsr	pc,@(r4)+
E1C6:	mov	(sp)+,r1
E1C8:	mov	r1,@#E880
E1CC:	mov	#0A00,@#E81A	;RAM address range 0000-7FFF, E800-EBFF
				;ROM address range 8000-DFFF, EC00-FDFF
E1D2:	jsr	pc,A060		;restore registers from the stack
E1D6:	jmp	E054		;back to the "TESTS" menu

; select the next ROM page in the MK-92
E1DA:	add	#800,@#E880
E1E0:	add	#800,r0
E1E4:	sob	r3,E1B0
E1E6:	br	E1C8

E1E8:	inc	0D5E
E1EC:	mov	#E1FA,r1	;'BR ne gotov' (something not ready)
E1F0:	jsr	pc,E0FA		;display the string pointed to by r1
E1F4:	jsr	pc,BF3A		;wait for a key
E1F8:	br	E1C8

E1FA:	0E 0D  0A 62 72 20	...br 
E200:	4E 45 20 47  4F 54 4F 57  0F 00 FF FF  FF FF FF FF  NE GOTOW........

EC00:	jsr	pc,A04C		;save registers on the stack
EC04:	clr	0D90
EC08:	clr	0E7E
EC0C:	clr	0E80
EC10:	mov	#1,0E8A
EC16:	trap	3A		;get a character other than space to r2
EC18:	dec	r1
EC1A:	cmpb	r2,#22
EC1E:	bne	ED0A
EC20:	inc	0D90
EC24:	mov	#D06,r0
EC28:	jsr	pc,D8C8		;fetch the device and file name
EC2C:	tst	0F48
EC30:	bne	EC38
EC32:	mov	#CBB,0F48
EC38:	trap	46		;get a pair of integer numbers
EC3A:	mov	r3,0E7C		;first number
EC3E:	bne	EC44
EC40:	inc	0E7E
EC44:	mov	#D06,r0
EC48:	movb	#1,0001(r0)	;read file
EC4E:	jsr	pc,D256		;file access
EC52:	bhis	EC58
EC54:	trap	7D		;error 62 - file not found
EC56:	br	ED0A
EC58:	mov	0D0C,r0
EC5C:	jsr	pc,D7DA		;convert the sector number in R0 to an address
EC60:	mov	0D06,r3
EC64:	mov	#5C0,r2
EC68:	mov	#1,r1
EC6C:	jsr	pc,D782
EC70:	jsr	r5,DA3C
EC74:	.word	0001
EC76:	dec	r2
EC78:	movb	(r2),r2
EC7A:	beq	ED0A
EC7C:	tst	0E7E
EC80:	beq	ECAC
EC82:	tst	0F00
EC86:	bne	ED0A
EC88:	trap	00		;print character r2
EC8A:	cmpb	r2,#A
EC8E:	bne	EC64
EC90:	dec	0E8A
EC94:	beq	EC64
EC96:	tst	0F20
EC9A:	bne	EC64
EC9C:	mov	r0,-(sp)
EC9E:	jsr	pc,BF3A		;wait for a key
ECA2:	cmpb	r2,#D
ECA6:	bne	EC9E
ECA8:	mov	(sp)+,r0
ECAA:	br	EC64
ECAC:	tst	0E80
ECB0:	beq	ECF8
ECB2:	trap	38		;is r2 a digit?
ECB4:	bne	ECC2		;branch if r2 is not a decimal digit
ECB6:	mov	#F4A,r1
ECBA:	add	r5,r1
ECBC:	movb	r2,(r1)
ECBE:	inc	r5
ECC0:	br	EC64
ECC2:	tst	r5
ECC4:	bne	ECCC
ECC6:	inc	0E8E
ECCA:	br	EC64
ECCC:	mov	#F4A,r1
ECD0:	mov	r0,-(sp)
ECD2:	trap	08		;ATOI
ECD4:	cmp	0E7C,r0
ECD8:	bgt	ECF0
ECDA:	inc	0E7E
ECDE:	mov	(sp)+,r0
ECE0:	sub	r5,r0
ECE2:	sub	0E8E,r0
ECE6:	sub	#2,r0
ECEA:	clrb	-(r1)
ECEC:	sob	r5,ECEA
ECEE:	br	EC64
ECF0:	mov	(sp)+,r0
ECF2:	clr	0E80
ECF6:	br	EC64
ECF8:	cmpb	r2,#A
ECFC:	bne	EC64
ECFE:	inc	0E80
ED02:	clr	r5
ED04:	clr	0E8E
ED08:	br	EC64
ED0A:	jsr	pc,A060		;restore registers from the stack
ED0E:	rts	pc

; command OPEN
ED10:	jsr	pc,A04C		;save registers on the stack
ED14:	trap	3A		;get a character other than space to r2
ED16:	cmpb	r2,#23
ED1A:	bne	ED7C
ED1C:	trap	08		;ATOI
ED1E:	mov	r0,r5
ED20:	ble	ED7C
ED22:	cmp	#6,r5
ED26:	blt	ED7C
ED28:	cmpb	(r1)+,#2C
ED2C:	bne	ED7C
ED2E:	trap	3A		;get a character other than space to r2
ED30:	movb	r2,r3
ED32:	bic	#FF80,r3
ED36:	cmpb	#49,r3
ED3A:	beq	ED42
ED3C:	cmpb	#4F,r3
ED40:	bne	ED7C
ED42:	trap	3A		;get a character other than space to r2
ED44:	cmpb	r2,#2C
ED48:	bne	ED7C
ED4A:	mov	r1,-(sp)
ED4C:	trap	3A		;get a character other than space to r2
ED4E:	cmpb	r2,#22
ED52:	bne	ED7A
ED54:	trap	60		;get a pair of characters to r4
ED56:	cmp	r4,#4C50	;"LP"
ED5A:	bne	ED82
ED5C:	trap	3A		;get a character other than space to r2
ED5E:	cmpb	r2,#3A
ED62:	bne	ED7A
ED64:	mov	(sp)+,r1
ED66:	cmpb	r3,#4F
ED6A:	bne	ED7C
ED6C:	dec	r5
ED6E:	mul	#8,r5
ED72:	mov	#504C,0BC0(r5)
ED78:	br	EE24
ED7A:	mov	(sp)+,r1
ED7C:	jsr	pc,A060		;restore registers from the stack
ED80:	trap	7B		;error 61 - wrong NAME operator format
ED82:	mov	(sp)+,r1
ED84:	mov	#D06,r0
ED88:	mov	r3,-(sp)
ED8A:	jsr	pc,D8C8		;fetch the device and file name
ED8E:	mov	(sp)+,r3
ED90:	tst	0F48
ED94:	bne	ED9C
ED96:	mov	#CBB,0F48
ED9C:	movb	#1,0001(r0)	;read file
EDA2:	jsr	pc,D256		;file access
EDA6:	blo	EDE8
EDA8:	mov	0D0C,r2
EDAC:	mov	0D0A,r4
EDB0:	cmpb	r3,#49
EDB4:	bne	EE32
EDB6:	mov	r2,r0
EDB8:	jsr	pc,D7DA		;convert the sector number in R0 to an address
EDBC:	jsr	pc,EF28
EDC0:	mov	0F50,(r0)+
EDC4:	mov	0F52,(r0)+
EDC8:	add	r2,r4
EDCA:	mov	r0,r2
EDCC:	mov	r4,r0
EDCE:	jsr	pc,D7DA		;convert the sector number in R0 to an address
EDD2:	mov	r5,-(sp)
EDD4:	jsr	r5,EF02
EDD8:	wait
EDDA:	mov	(sp)+,r5
EDDC:	mov	r2,r0
EDDE:	mov	0F50,(r0)+
EDE2:	mov	0F52,(r0)+
EDE6:	br	EE14
EDE8:	cmpb	r3,#49
EDEC:	bne	EDF4
EDEE:	jsr	pc,A060		;restore registers from the stack
EDF2:	trap	7D		;error 62 - file not found
EDF4:	mov	#D06,r0
EDF8:	movb	#2,0001(r0)	;write file
EDFE:	jsr	pc,D256		;file access
EE02:	bhis	EE0A
EE04:	jsr	pc,A060		;restore registers from the stack
EE08:	trap	77		;error 59 - SMP overflow
EE0A:	mov	0D0C,r2
EE0E:	mov	0D0A,r4
EE12:	br	EDB6
EE14:	mov	0D0C,(r0)+
EE18:	mov	0F44,(r0)+
EE1C:	mov	0F46,(r0)+
EE20:	mov	0F48,(r0)+
EE24:	mov	r1,0002(sp)
EE28:	jsr	pc,A060		;restore registers from the stack
EE2C:	trap	48
EE2E:	jmp	8664
EE32:	mov	r1,-(sp)
EE34:	mov	#D06,r0
EE38:	mov	r4,r1
EE3A:	asl	r1
EE3C:	mov	r1,0D0A
EE40:	movb	#2,0001(r0)	;write file
EE46:	jsr	pc,D256		;file access
EE4A:	bhis	EE54
EE4C:	mov	(sp)+,r1
EE4E:	jsr	pc,A060		;restore registers from the stack
EE52:	trap	77		;error 59 - SMP overflow
EE54:	add	0D0C,r1
EE58:	mov	r1,r0
EE5A:	jsr	pc,D7DA		;convert the sector number in R0 to an address
EE5E:	mov	r5,-(sp)
EE60:	jsr	r5,EF02
EE64:	wait
EE66:	mov	(sp)+,r5
EE68:	mov	0F52,-(sp)
EE6C:	mov	0F50,-(sp)
EE70:	mov	0D0C,-(sp)
EE74:	bic	#FF80,0D06
EE7A:	mov	r3,-(sp)
EE7C:	mov	0D06,r3
EE80:	mov	#1,r1		;number of sectors
EE84:	mov	r2,r0		;starting sector
EE86:	mov	r2,-(sp)
EE88:	mov	#09C0,r2	;destination address
EE8C:	jsr	pc,D77A		;read sectors from the memory module
EE90:	mov	#09C0,r2	;source address
EE94:	mov	#1,r1		;number of sectors
EE98:	mov	0D0C,r0		;starting sector
EE9C:	jsr	pc,D7A0		;write sectors to the memory module
EEA0:	mov	(sp)+,r2
EEA2:	inc	r2
EEA4:	inc	0D0C
EEA8:	sob	r4,EE7C
EEAA:	mov	0D0C,r0
EEAE:	dec	r0
EEB0:	jsr	pc,D7DA		;convert the sector number in R0 to an address
EEB4:	mov	0D06,r3
EEB8:	mov	#09C0,r2
EEBC:	mov	#1,r1
EEC0:	jsr	pc,D782
EEC4:	mov	r5,-(sp)
EEC6:	jsr	r5,DA3C
EECA:	.word	0001
EECC:	mov	(sp)+,r5
EECE:	cmpb	#A,09C0
EED4:	bne	EEB8
EED6:	mov	#1,r1
EEDA:	mov	#09C0,r2
EEDE:	jsr	pc,D782
EEE2:	tstb	09C0
EEE6:	bne	EEB8
EEE8:	mov	(sp)+,r3
EEEA:	mov	(sp)+,0D0C
EEEE:	jsr	pc,EF28
EEF2:	mov	0F50,(r0)+
EEF6:	mov	0F52,(r0)+
EEFA:	mov	(sp)+,(r0)+
EEFC:	mov	(sp)+,(r0)+
EEFE:	mov	(sp)+,r1
EF00:	br	EE14
EF02:	mov	r1,-(sp)
EF04:	mov	r0,-(sp)
EF06:	mov	0F50,r1
EF0A:	swab	r1
EF0C:	mov	0F52,r0
EF10:	swab	r0
EF12:	sub	(r5)+,r0
EF14:	sbc	r1
EF16:	swab	r0
EF18:	mov	r0,0F52
EF1C:	swab	r1
EF1E:	mov	r1,0F50
EF22:	mov	(sp)+,r0
EF24:	mov	(sp)+,r1
EF26:	rts	r5
EF28:	mov	#BC0,r0
EF2C:	dec	r5
EF2E:	mul	#14,r5
EF32:	add	r5,r0
EF34:	mov	#4D53,(r0)+
EF38:	bic	#FF80,0D06
EF3E:	mov	0D06,(r0)
EF42:	movb	r3,0001(r0)
EF46:	tst	(r0)+
EF48:	rts	pc

; command CLOSE
EF4A:	jsr	pc,A04C		;save registers on the stack
EF4E:	trap	3A		;get a character other than space to r2
EF50:	cmpb	r2,#23
EF54:	bne	EF5E
EF56:	trap	08		;ATOI
EF58:	cmp	r0,#6
EF5C:	blos	EF64
EF5E:	jsr	pc,A060		;restore registers from the stack
EF62:	trap	7B		;error 61 - wrong NAME operator format
EF64:	mov	#BC0,r2
EF68:	dec	r0
EF6A:	mov	r0,r3
EF6C:	mul	#14,r3
EF70:	add	r3,r2
EF72:	tst	(r2)
EF74:	bne	EF78
EF76:	trap	7B		;error 61 - wrong NAME operator format
EF78:	cmp	(r2),#504C
EF7C:	bne	EF82
EF7E:	clr	(r2)
EF80:	br	EFFE
EF82:	cmp	(r2),#4D53
EF86:	bne	EFFE
EF88:	mov	0006(r2),r3
EF8C:	swab	r3
EF8E:	mov	r3,0006(r2)
EF92:	asr	0006(r2)
EF96:	blo	EF9E
EF98:	tstb	0006(r2)
EF9C:	beq	EFA2
EF9E:	incb	0007(r2)
EFA2:	clr	0D0A
EFA6:	movb	0007(r2),0D0A
EFAC:	mov	000C(r2),0D0C
EFB2:	mov	000E(r2),0F44
EFB8:	mov	0010(r2),0F46
EFBE:	mov	0012(r2),0F48
EFC4:	mov	0002(r2),0D06
EFCA:	bic	#FF00,0D06
EFD0:	sub	0D0C,0D0A
EFD6:	mov	#D06,r0
EFDA:	movb	#4,0001(r0)
EFE0:	jsr	pc,D256		;file access
EFE4:	tst	0D0A
EFE8:	bne	EFF6
EFEA:	mov	#D06,r0
EFEE:	clrb	0001(r0)	;kill file
EFF2:	jsr	pc,D256		;file access
EFF6:	mov	#A,r1
EFFA:	clr	(r2)+
EFFC:	sob	r1,EFFA
EFFE:	jsr	pc,A060		;restore registers from the stack
F002:	trap	48
F004:	jmp	8664
F008:	dec	(sp)
F00A:	mov	(sp),r3
F00C:	mul	#14,r3
F010:	mov	r3,r4
F012:	add	#BC0,r4
F016:	cmp	#504C,(r4)
F01A:	beq	F026
F01C:	cmp	#4D53,(r4)
F020:	bne	F028
F022:	tst	(r0)+
F024:	tst	(r0)+
F026:	tst	(r0)+
F028:	rts	r0

; command GET
F02A:	mov	#1,0E9C
F030:	br	F036

; command PUT
F032:	clr	0E9C
F036:	jsr	pc,A04C		;save registers on the stack
F03A:	trap	3A		;get a character other than space to r2
F03C:	cmpb	r2,#23
F040:	beq	F044
F042:	trap	7B		;error 61 - wrong NAME operator format
F044:	trap	08		;ATOI
F046:	cmp	#6,r0
F04A:	blo	F042
F04C:	jsr	r0,F008
F050:	trap	7D		;error 62 - file not found
F052:	jmp	9052
F056:	cmpb	0003(r4),#4F
F05C:	bne	F066
F05E:	tst	0E9C
F062:	beq	F06C
F064:	trap	3D		;error 30 - wrong parameters
F066:	tst	0E9C
F06A:	beq	F064
F06C:	trap	3A		;get a character other than space to r2
F06E:	cmpb	r2,#2C
F072:	bne	F042
F074:	tst	0E9C
F078:	beq	F11E
F07A:	mov	r1,-(sp)
F07C:	mov	#09C0,r2
F080:	movb	(r1),(r2)+
F082:	cmpb	#A,(r1)
F086:	beq	F08E
F088:	cmpb	#3A,(r1)+
F08C:	bne	F080
F08E:	movb	#3D,FFFF(r2)
F094:	mov	0002(r4),r3
F098:	mov	0004(r4),0F50
F09E:	mov	0006(r4),0F52
F0A4:	cmp	0F50,0008(r4)
F0AA:	blos	F0B6
F0AC:	cmp	0F52,000A(r4)
F0B2:	blos	F0B6
F0B4:	trap	6F		;error 55 - input/output error
F0B6:	mov	r5,-(sp)
F0B8:	mov	r4,-(sp)
F0BA:	mov	#1,r1
F0BE:	jsr	pc,D782
F0C2:	jsr	r5,DA3C
F0C6:	.word	0001
F0C8:	tstb	FFFF(r2)
F0CC:	bne	F0D0
F0CE:	trap	6F		;error 55 - input/output error
F0D0:	cmpb	#A,FFFF(r2)
F0D6:	bne	F0BA
F0D8:	mov	(sp)+,r4
F0DA:	mov	0F50,0004(r4)
F0E0:	mov	0F52,0006(r4)
F0E6:	movb	#A,FFFE(r2)
F0EC:	mov	(sp)+,r5
F0EE:	mov	#09C0,r1
F0F2:	trap	64
F0F4:	bvs	F106
F0F6:	bne	F0FC
F0F8:	mov	r4,r0
F0FA:	trap	66
F0FC:	mov	r0,-(sp)
F0FE:	trap	3A		;get a character other than space to r2
F100:	cmp	r2,#3D
F104:	beq	F108
F106:	trap	11		;error 8 - illegal LET operator
F108:	trap	5E		;evaluate an arithmetical expression
F10A:	bvs	F11C
F10C:	mov	(sp)+,r0
F10E:	mov	r2,(r0)+
F110:	mov	r3,(r0)+
F112:	mov	r4,(r0)+
F114:	mov	(sp)+,r1
F116:	mov	r5,000A(sp)
F11A:	br	F1B4
F11C:	trap	0F		;error 7 - mismatched parentheses
F11E:	mov	r4,-(sp)
F120:	mov	#1C,r0
F124:	trap	44		;check the available stack space
F126:	bhis	F12A
F128:	trap	01		;error 0 - out of memory
F12A:	trap	5E		;evaluate an arithmetical expression
F12C:	bvc	F130
F12E:	trap	17		;error 11 - illegal PRINT operator
F130:	mov	r1,-(sp)
F132:	jsr	pc,9510		;floating point to ASCII conversion
F136:	mov	sp,r2		;pointer to the output string
F138:	tstb	(r2)+		;search for the end of the output string
F13A:	bne	F138
F13C:	movb	#0D,-1(r2)	;append CR/LF at the end of the string
F142:	movb	#0A,(r2)
F146:	mov	sp,r2		;r2 = source address
F148:	mov	0016(r2),r4
F14C:	mov	0002(r4),r3
F150:	mov	0004(r4),0F50
F156:	mov	0006(r4),0F52	;destination address (big endian order)
F15C:	mov	#1,r1		;number of bytes to write
F160:	cmpb	#20,(r2)
F164:	bne	F16A
F166:	inc	r2
F168:	br	F160
F16A:	jsr	pc,D7A8		;write a memory block to the SMP
F16E:	jsr	r5,DA3C
F172:	.word	0001
F174:	cmp	0F50,0008(r4)
F17A:	bhi	F186
F17C:	blo	F18C
F17E:	cmp	0F52,000A(r4)
F184:	blos	F18C
F186:	jsr	pc,A060		;restore registers from the stack
F18A:	trap	6F		;error 55 - input/output error
F18C:	tstb	FFFF(r2)
F190:	beq	F1AA
F192:	cmpb	#A,FFFF(r2)
F198:	bne	F15C
F19A:	mov	0F50,0004(r4)
F1A0:	mov	0F52,0006(r4)
F1A6:	clrb	(r2)
F1A8:	br	F15C
F1AA:	add	#14,sp
F1AE:	mov	(sp)+,r1
F1B0:	mov	(sp)+,r4
F1B2:	dec	r0
F1B4:	jsr	pc,A060		;restore registers from the stack
F1B8:	trap	48
F1BA:	jmp	8664

; get an octal number in ASCII form pointed to by r1 to r0
F1BE:	clr	r0
F1C0:	clr	r2
F1C2:	asl	r0
F1C4:	asl	r0
F1C6:	asl	r0
F1C8:	bis	r2,r0
F1CA:	trap	3A		;get a character other than space to r2
F1CC:	trap	38		;is r2 a digit?
F1CE:	bne	F1D6		;branch if r2 is not a decimal digit
F1D0:	sub	#30,r2
F1D4:	br	F1C2
F1D6:	rts	pc

; command BSAVE
F1D8:	jsr	pc,A04C		;save registers on the stack
F1DC:	mov	#D06,r0
F1E0:	jsr	pc,D8C8		;fetch the device and file name
F1E4:	tst	0F48
F1E8:	bne	F1F0
F1EA:	mov	#DF6,0F48
F1F0:	jsr	pc,F1BE		;get an octal number to r0
F1F4:	mov	r0,0F4A
F1F8:	beq	F274
F1FA:	jsr	pc,F1BE		;get an octal number to r0
F1FE:	mov	r0,0F4C
F202:	beq	F274
F204:	mov	r0,r4
F206:	bic	#1FF,r0
F20A:	asr	r0
F20C:	swab	r0
F20E:	bic	#FE00,r4
F212:	beq	F216
F214:	inc	r0
F216:	mov	r0,0D0A
F21A:	mov	r3,-(sp)
F21C:	mov	0D06,r3
F220:	jsr	pc,DF18		;check the memory module
F224:	mov	(sp)+,r3
F226:	tst	0F54		;memory module type
F22A:	beq	F230		;skip if a RAM module
F22C:	trap	71		;error 56 - file write protected
F22E:	br	F274
F230:	mov	#D06,r0
F234:	movb	#2,0001(r0)	;write file
F23A:	jsr	pc,D256		;file access
F23E:	bhis	F244
F240:	trap	77		;error 59 - SMP overflow
F242:	br	F274
F244:	mov	0D0C,r0
F248:	swab	r0
F24A:	asl	r0
F24C:	mov	r0,0F22
F250:	mov	#4,r4
F254:	mov	#F4A,r0
F258:	movb	(r0)+,r2
F25A:	jsr	pc,DB74
F25E:	sob	r4,F258
F260:	mov	0F4A,r0
F264:	mov	0F4C,r4
F268:	movb	(r0)+,r2
F26A:	jsr	pc,DB74
F26E:	sob	r4,F268
F270:	jsr	pc,DBA4
F274:	jsr	pc,A060		;restore registers from the stack
F278:	jmp	86BE

; command BLOAD
F27C:	jsr	pc,A04C		;save registers on the stack
F280:	clr	0E86
F284:	clr	0E80
F288:	mov	#D06,r0
F28C:	jsr	pc,D8C8		;fetch the device and file name
F290:	tst	0F48
F294:	bne	F29C
F296:	mov	#DF6,0F48
F29C:	jsr	pc,F1BE		;get an octal number to r0
F2A0:	mov	r0,0E86
F2A4:	dec	r1
F2A6:	trap	3A		;get a character other than space to r2
F2A8:	cmpb	r2,#2C		;optional comma followed by the length
F2AC:	beq	F2BA
F2AE:	cmpb	r2,#A
F2B2:	beq	F2C2
F2B4:	jsr	pc,A060		;restore registers from the stack
F2B8:	trap	3D		;error 30 - wrong parameters
F2BA:	jsr	pc,F1BE		;get an octal number to r0
F2BE:	mov	r0,0E80
F2C2:	mov	#D06,r0
F2C6:	movb	#1,0001(r0)	;read file
F2CC:	jsr	pc,D256		;file access
F2D0:	bhis	F2D6
F2D2:	trap	7D		;error 62 - file not found
F2D4:	br	F39E
F2D6:	mov	0D0C,r0
F2DA:	mov	0D06,r3
F2DE:	jsr	pc,D7DA		;convert the sector number in R0 to an address
F2E2:	mov	#F4A,r2
F2E6:	mov	#4,r5
F2EA:	mov	#1,r1
F2EE:	jsr	pc,D782
F2F2:	mov	r5,-(sp)
F2F4:	jsr	r5,DA3C
F2F8:	.word	0001
F2FA:	mov	(sp)+,r5
F2FC:	sob	r5,F2EA
F2FE:	tst	0E80
F302:	bne	F328
F304:	mov	0F4C,0E80
F30A:	mov	r0,-(sp)
F30C:	mov	#F3BE,r0	;string 'DLINA: ' (length)
F310:	trap	36		;print a string pointed to by r0
F312:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
F316:	mov	0E80,r1
F31A:	mov	#6,r4		;number of digits
F31E:	jsr	pc,801A		;convert the word in r1 to octal ASCII
F322:	trap	36		;print a string pointed to by r0
F324:	trap	02		;print CR, LF
F326:	mov	(sp)+,r0
F328:	tst	0F16
F32C:	bne	F33C
F32E:	mov	0E80,r0
F332:	jsr	pc,C4E2
F336:	bgt	F33C
F338:	jmp	F3A6
F33C:	mov	0F16,r2
F340:	sub	0E80,r2
F344:	cmp	0D00,r2
F348:	ble	F34E
F34A:	jmp	F3A6
F34E:	tst	0E86
F352:	bne	F382
F354:	mov	r0,-(sp)
F356:	mov	#F3B4,r0	;string 'ADRES? '
F35A:	trap	36		;print a string pointed to by r0
F35C:	jsr	pc,C438		;r0 <- pointer to a zero terminated buffer
F360:	mov	0D00,r1
F364:	mov	#6,r4		;number of digits
F368:	jsr	pc,801A		;convert the word in r1 to octal ASCII
F36C:	trap	36		;print a string pointed to by r0
F36E:	trap	02		;print CR, LF
F370:	jsr	pc,BF3A		;wait for a key
F374:	mov	(sp)+,r0
F376:	cmpb	r2,#59		;'Y'
F37A:	bne	F39E
F37C:	mov	0D00,0E86
F382:	mov	0E86,r2
F386:	mov	0E80,r5
F38A:	mov	#1,r1
F38E:	jsr	pc,D782
F392:	mov	r5,-(sp)
F394:	jsr	r5,DA3C
F398:	.word	0001
F39A:	mov	(sp)+,r5
F39C:	sob	r5,F38A
F39E:	jsr	pc,A060		;restore registers from the stack
F3A2:	jmp	86BE
F3A6:	clr	0F16
F3AA:	mov	0D00,sp
F3AE:	jsr	pc,A060		;restore registers from the stack
F3B2:	trap	01		;error 0 - out of memory

F3B0:	AE AC 01 89  0E 61 64 72  65 73 3F 20  0F 00 0E 64  .,...adres? ...d
F3C0:	6C 69 6E 61  3A 20 0F 00  E4 2B D3 84  E4 75 48 40  lina: ..d+S.duH@
F3D0:	00 04 47 D0  40 08 88 82  08 24 10 41  11 10 02 0B  ..GP@....$.A....
F3E0:	E2 20 38 47  D3 C5 36 29  8A F8 A5 C5  31 3A 94 A0  b 8GSE6).x%E1:. 
F3F0:	01 09 57 13  E4 21 2A E2  00 00 00 00  00 00 00 00  ..W.d!*b........
F400:	00 47 54 84  27 DD 57 14  C5 2E 29 8A  FC A5 00 00  .GT.']W.E.).|%..
F410:	C6 11 00 00  00 06 30 00  4F D2 00 00  12 FC 80 00  F.....0.OR...|..
F420:	00 FF FF FF  FF FF FF FF  FF FF 00 00  00 00 00 00  ................
F430:	00 00 77 FF  DD FF 77 FF  DD FF 80 00  08 00 80 00  ..w.].w.].......
F440:	08 00 77 DD  77 DD 77 DD  77 DD 88 00  22 00 88 00  ..w]w]w]w].."...
F450:	22 00 AA 55  AA 55 AA 55  AA 55 88 22  88 22 88 22  ".*U*U*U*U."."."
F460:	88 22 55 FF  55 FF 55 FF  55 FF AA 00  AA 00 AA 00  ."U.U.U.U.*.*.*.
F470:	AA 00 AA AA  AA AA AA AA  AA AA FF 00  FF 00 FF 00  *.********......
F480:	FF 00 BB 77  EE DD BB 77  EE DD 44 88  11 22 44 88  ..;wn];wn]D.."D.
F490:	11 22 88 88  88 88 88 88  88 88 00 00  FF 00 00 00  ."..............
F4A0:	FF 00 B1 30  03 1B D8 C0  0C 8D 20 40  80 01 02 04  ..10..X@.. @....
F4B0:	08 10 80 04  40 08 01 20  02 10 AA 00  80 00 88 00  ....@.. ..*.....
F4C0:	80 00 88 88  88 FF 88 88  88 FF 08 08  08 FF 08 08  ................
F4D0:	08 08 80 80  80 FF 08 08  08 FF 20 40  80 C1 22 1C  .......... @.A".
F4E0:	08 10 00 00  00 80 00 00  00 00 AA 00  88 14 22 41  ..........*..."A
F4F0:	88 00 20 40  80 00 08 04  02 00 40 A0  00 00 04 0A  .. @......@ ....
F500:	00 00 10 28  44 93 44 28  10 10 08 1C  24 42 C1 60  ...(D.D(....$BA`
F510:	10 08 E2 44  2E 1F 8E 44  E8 F1 80 80  41 3E 08 08  ..bD...Dhq..A>..
F520:	14 E3 AA 50  20 20 AA 05  02 02 10 20  54 AA FF 02  .c*P  *.... T*..
F530:	04 08 50 28  44 92 29 52  25 88 77 98  F8 F8 77 89  ..P(D.)R%.w.xxw.
F540:	8F 8F 16 16  F7 00 F7 F7  16 16 10 28  54 AA 54 28  ....w.ww...(T*T(
F550:	10 00 22 11  88 44 22 11  88 44 DD EE  77 BB DD EE  .."..D"..D]nw;]n
F560:	77 BB 66 99  99 66 66 99  99 66 77 DD  AA DD 77 DD  w;f..ff..fw]*]w]
F570:	AA DD 88 22  55 22 88 22  55 22 DD 44  77 11 DD 44  *]."U"."U"]Dw.]D
F580:	77 11 CC 33  CC 33 CC 33  CC 33 22 55  88 88 88 55  w.L3L3L3L3"U...U
F590:	22 22 FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF  ""..............

; system restart
F600:	mov	#0200,sp
F604:	mov	#0200,@#E81C	;system ROM enabled
F60A:	mov	#0A00,@#E81A	;RAM address range 0000-7FFF, E800-EBFF
				;ROM address range 8000-DFFF, EC00-FDFF
F610:	bit	#0100,@#EA1A	;RTC register D, valid data?
F616:	beq	F630		;branch if not
F618:	mov	@#EA1E,r0	;RTC user RAM, address 0F
F61C:	asr	r0
F61E:	swab	r0
F620:	clrb	r0
F622:	mov	@#EA1C,r1	;RTC user RAM, address 0E
F626:	asr	r1
F628:	bisb	r1,r0
F62A:	clr	-(sp)
F62C:	mov	r0,-(sp)
F62E:	rti
;
F630:	mov	#EC60,@#EA1C	;30 shl 1 -> RTC user RAM, address 0E
F636:	mov	#01EC,@#EA1E	;F6 shl 1 -> RTC user RAM, address 0F
F63C:	jsr	pc,CA6C		;RAM initialisation
F640:	jsr	pc,F866		;LCD controller initialisation
F644:	mov	#F7FA,@#C8	;keyboard controller interrupt vector
F64A:	clr	@#CA
F64E:	mov	#0036,@#E812
F654:	mov	#EA,@#E814
F65A:	jsr	pc,A4D4
F65E:	mov	#10,0C50
F664:	mov	#1C,0D46
F66A:	mov	#F9A0,r0	;string "ELEKTRONIKA"
F66E:	jsr	pc,F972		;print a string pointed to by r0
F672:	clr	0D46
F676:	clr	0C50
F67A:	bis	#20,0D5C
F680:	mov	#F9C5,r0	;string "="
F684:	jsr	pc,F972		;print a string pointed to by r0
F688:	bic	#20,0D5C
F68E:	mov	#8,0C50
F694:	clr	0D46
F698:	mov	#F9C9,r0
F69C:	jsr	pc,F972		;print a string pointed to by r0
F6A0:	mov	#18,0C50
F6A6:	clr	0D46
F6AA:	mov	#F9C9,r0
F6AE:	jsr	pc,F972		;print a string pointed to by r0
F6B2:	mov	#20,0C50
F6B8:	clr	0D46
F6BC:	mov	#F9C5,r0
F6C0:	jsr	pc,F972		;print a string pointed to by r0
F6C4:	mov	#3,r3
F6C8:	clr	r2
F6CA:	mov	F76C(r2),0D46
F6D0:	mov	F766(r2),0C50
F6D6:	mov	F96C(r2),r0
F6DA:	jsr	pc,F972		;print a string pointed to by r0
F6DE:	tst	(r2)+
F6E0:	sob	r3,F6CA
F6E2:	mov	#4,r1
F6E6:	mov	F76C(r1),0D46
F6EC:	mov	F766(r1),0C50
F6F2:	jsr	pc,F77E
F6F6:	asr	r1
F6F8:	jsr	pc,F7EE		;wait for a key
F6FC:	cmpb	r0,#BB		;cursor right?
F700:	beq	F71E
F702:	cmpb	r0,#5B		;cursor left?
F706:	beq	F748
F708:	cmpb	r0,#FB		;key VK (enter) ?
F70C:	beq	F754
F70E:	cmpb	r0,#53		;key T ?
F712:	bne	F718
F714:	jmp	@#E054		;tests
F718:	jsr	pc,F81E		;make a beep when unsupported key pressed
F71C:	br	F6F8

; cursor right (on the welcome screen)
F71E:	mov	r1,r0
F720:	inc	r0
F722:	cmp	r1,#2
F726:	blt	F72A
F728:	clr	r0
F72A:	asl	r1
F72C:	jsr	pc,F77E
F730:	mov	r0,r1
F732:	asl	r1
F734:	mov	F766(r1),0C50
F73A:	mov	F76C(r1),0D46
F740:	jsr	pc,F77E
F744:	asr	r1
F746:	br	F6F8

; cursor left (on the welcome screen)
F748:	mov	r1,r0
F74A:	dec	r0
F74C:	bpl	F72A
F74E:	add	#3,r0
F752:	br	F72A

; enter (on the welcome screen)
F754:	clr	r0
F756:	asr	r1
F758:	adc	r0
F75A:	asl	r1
F75C:	reset
F75E:	jmp	@F762(r1)

F762:	.word	F874		;boot from the SMP
F764:	.word	F95C		;start the BASIC system
F766:	.word	0038, 0038, 0038
F76C:	.word	002E, 004C, 0004, 0019, 0019
F774:	.word	0025, 0009, 0009, 0009, 1066

F77E:	mov	r1,-(sp)
F780:	mov	0D46,-(sp)
F784:	dec	0D46
F788:	mov	r0,-(sp)
F78A:	movb	#2,0C56
F790:	mov	F772(r1),r3
F794:	beq	F7C6
F796:	mov	F778(r1),r2
F79A:	beq	F7C6
F79C:	mov	#FF00,r1
F7A0:	mov	r3,r4
F7A2:	bic	#FFF8,r4
F7A6:	ash	#FFFD,r3
F7AA:	beq	F7B8
F7AC:	jsr	pc,F7D4
F7B0:	add	#8,0D46
F7B6:	sob	r3,F7AC
F7B8:	mov	#8,r0
F7BC:	sub	r4,r0
F7BE:	ash	r0,r1
F7C0:	beq	F7C6
F7C2:	jsr	pc,F7D4
F7C6:	mov	(sp)+,r0
F7C8:	mov	(sp)+,0D46
F7CC:	mov	(sp)+,r1
F7CE:	clrb	0C56
F7D2:	rts	pc
F7D4:	mov	r2,r5
F7D6:	mov	0C50,-(sp)
F7DA:	dec	0C50
F7DE:	jsr	pc,A31E		;plot a dot
F7E2:	inc	0C50
F7E6:	sob	r5,F7DE
F7E8:	mov	(sp)+,0C50
F7EC:	rts	pc

; wait for a key, return the row and column of a pressed key in r0
F7EE:	mtps	#0
F7F2:	wait
F7F4:	mov	@#2C,r0
F7F8:	rts	pc

; keyboard interrupt service routine
F7FA:	mov	#F2,@#E814
F800:	clr	@#E816		;start of the transfer
F804:	tstb	@#E814
F808:	bpl	F804
F80A:	mov	@#E816,@#2C	;key scan code, end of the transfer
F810:	tstb	@#E814
F814:	bpl	F810
F816:	mov	#EA,@#E814
F81C:	rti

; make a warning beep
F81E:	mov	#40,r0		;sound duration, 64 * 8 / 660Hz = 0.8 sec.
F822:	mov	#F7FA,@#C8	;keyboard controller interrupt vector
F828:	clr	@#CA
F82C:	mov	#FB,@#E814
F832:	mov	#04BC,@#E812	;660Hz
F838:	clr	@#E816		;start of the transfer
F83C:	tstb	@#E814
F840:	bpl	F83C
F842:	clr	@#E810		;dummy data to emit 8 clock cycles
F846:	tstb	@#E814
F84A:	bpl	F846
F84C:	sob	r0,F842
F84E:	tst	@#E816		;end of the transfer
F852:	tstb	@#E814
F856:	bpl	F852
F858:	mov	#EA,@#E814
F85E:	mov	#0036,@#E812
F864:	rts	pc

; LCD controller initialisation
F866:	mov	0D02,@#E800	;address of the display RAM
F86C:	mov	#88C6,@#E802
F872:	rts	pc

; boot from the SMP, r0 selects between the SMP0/1
F874:	mov	#0009,@#E812	;transfer rate
F87A:	mov	#E814,r1	;control/status register
F87E:	mov	#00F8,r5	;writing to the SMP
F882:	add	r0,r5
F884:	mov	#F966,r2	;procedure 'wait for the transfer completed'
F888:	mov	r5,(r1)
F88A:	clr	@#E816		;Read Status
F88E:	jsr	pc,(r2)
F890:	bic	#8,r5		;reading from the SMP
F894:	mov	r5,(r1)
F896:	mov	@#E816,r3	;read from the SMP, end of the transfer
F89A:	jsr	pc,(r2)
; test whether the password protection is active
F89C:	tstb	r3
F89E:	bpl	F8EE		;branch if inactive password protection
; test the attempt counter
F8A0:	aslb	r3
F8A2:	bpl	F8A8		;less than 3 attempts counted, try to unlock
F8A4:	aslb	r3
F8A6:	bmi	F938		;three attempts counted, don't even try
;
; the password protection is active,
; an attempt to unlock the memory module
F8A8:	bis	#8,r5		;writing to the SMP
F8AC:	mov	r5,(r1)
F8AE:	mov	#A8,@#E816	;Write Address
F8B4:	jsr	pc,(r2)
F8B6:	clr	@#E810
F8BA:	jsr	pc,(r2)
F8BC:	clr	@#E810		;high address byte
F8C0:	jsr	pc,(r2)
F8C2:	clr	@#E810		;low address byte
F8C6:	jsr	pc,(r2)
F8C8:	tst	@#E816		;end of the transfer
F8CC:	jsr	pc,(r2)
;
F8CE:	mov	#98,@#E816	;Unlock
F8D4:	jsr	pc,(r2)
F8D6:	mov	#F998,r4	;password A0 00 A0 00 A0 00 A0 00
F8DA:	mov	#8,r3
F8DE:	movb	(r4)+,@#E810
F8E2:	jsr	pc,(r2)
F8E4:	sob	r3,F8DE
F8E6:	tst	@#E816		;end of the transfer
F8EA:	jsr	pc,(r2)
F8EC:	br	F87A		;back to the begin of the boot routine
;
; the password protection is inactive,
; continue with boot sector loading
F8EE:	bis	#08,r5		;writing to the SMP
F8F2:	mov	r5,(r1)
F8F4:	mov	#A8,@#E816	;Write Address
F8FA:	jsr	pc,(r2)
F8FC:	clr	@#E810
F900:	jsr	pc,(r2)
F902:	clr	@#E810		;high address byte
F906:	jsr	pc,(r2)
F908:	clr	@#E810		;low address byte
F90C:	jsr	pc,(r2)
F90E:	tst	@#E816		;end of the transfer
F912:	jsr	pc,(r2)
; read the SMP boot sector to the RAM 0000..01FF
F914:	mov	#0200,r4	;number of bytes
F918:	clr	r3		;destination address
F91A:	mov	#D8,@#E816	;Read Postincrement
F920:	jsr	pc,(r2)
F922:	bic	#08,r5		;reading from the SMP
F926:	mov	r5,(r1)
F928:	jsr	pc,(r2)
F92A:	movb	@#E810,(r3)+	;read data byte from the SMP to the RAM
F92E:	jsr	pc,(r2)
F930:	sob	r4,F92A		;next data byte
F932:	tst	@#E816		;end of the transfer
F936:	jsr	pc,(r2)
;
F938:	cmpb	#A0,@#0000	;test for instruction NOP at address 0000
F93E:	bne	F954
F940:	mov	#1000,@#E81A	;RAM address range 0000-3FFF, E800-EBFF
				;ROM address range 4000-DFFF, EC00-FDFF
F946:	tst	@#E81E
F94A:	bmi	F952
F94C:	mov	#2000,@#E880
F952:	clr	pc		;start the program from address 0000
;
F954:	jsr	pc,F81E		;make a beep when wrong bootloader code
F958:	jmp	F600		;system restart

F95C:	mov	#1000,@#E81A	;RAM address range 0000-3FFF, E800-EBFF
				;ROM address range 4000-DFFF, EC00-FDFF
F962:	jmp	@#9FCE		;start the BASIC system

F966:	tstb	(r1)
F968:	bpl	F966
F96A:	rts	pc

F96C:	.word	F9AE, F9B5, F9BC

; print a zero terminated string pointed to by r0
F972:	movb	(r0)+,0C5A
F976:	movb	(r0)+,0C58
F97A:	mov	0C44,0C48
F980:	mov	#1,0C56
F986:	mov	r2,-(sp)
F988:	clr	r2
F98A:	movb	(r0)+,r2
F98C:	beq	F994
F98E:	jsr	pc,A06E
F992:	br	F988
F994:	mov	(sp)+,r2
F996:	rts	pc

F998:	A0 00 A0 00 A0 00 A0 00

F9A0:	01 01 7C 6C  65 6B 74 72  6F 6E 69 6B  61 00	..|lektronika.
F9AE:	01 01 73 6D 70 30  00	..smp0.
F9B5:	01 01 73  6D 70 31 00	..smp1.
F9BC:	01 01 62 65 6A 73 69 6B 00	..bejsik.
F9C5:	18 01 3D 00
F9C9:	18 01 7F 00
F9CD:	.even

; font data, 35 bits for each character (width = 5 pixels, height = 7 pixels)

; character codes 0x20-0x3F
F9CE:	                                             00 00
F9D0:	00 00 04 21  08 40 11 4A  00 00 00 29  5F 57 D4 A8
F9E0:	BA 31 8B A3  8C 88 88 98  D1 4A 22 B2  69 84 40 00
F9F0:	00 11 10 84  10 48 20 84  22 20 04 AB  AA 40 00 84
FA00:	F9 08 00 00  0C 61 10 00  03 E0 00 00  00 00 0C 60
FA10:	02 22 22 00  74 67 5C C5  C4 61 08 42  39 D1 08 88
FA20:	8F FC 44 10  62 E1 19 52  F8 85 F8 78  21 8B 8C 88
FA30:	7A 31 77 C2  22 21 08 74  62 E8 C5 CE  8C 5E 11 30
FA40:	0C 60 18 C0  01 8C 03 08  81 11 10 41  04 00 7C 1F
FA50:	00 10 41 04  44 43 A2 11  10 04 00 00

; Latin characters, codes 0x40-0x7F
FA5C:	                                       74 6F 5B C1
FA60:	E4 54 63 F8  C7 D1 8F A3  1F 3A 30 84  22 EE 4A 31
FA70:	8C B9 F8 43  D0 87 FF 08  7A 10 83 A3  0B C6 2F 8C
FA80:	63 F8 C6 2E  21 08 42 38  E2 10 85 26  46 54 C5 25
FA90:	18 42 10 84  3F 1D D6 B1  8C 63 1C D6  71 8B A3 18
FAA0:	C6 2E F4 63  E8 42 0E 8C  63 59 37 D1  8F A9 28 BA
FAB0:	30 70 62 EF  90 84 21 09  18 C6 31 8B  A3 18 C6 2A
FAC0:	24 63 1A D6  AA 8C 54 45  46 31 8C 54  42 13 E1 11
FAD0:	11 0F B9 08  42 10 E0 41  04 10 40 E1  08 42 13 80
FAE0:	00 7C 20 00  00 00 00 1F  22 18 00 00  00 07 82 F8
FAF0:	BE 10 F4 63  1F 00 0F 84  20 F0 85 F1  8C 5E 00 3A
FB00:	3F 83 C6 42  7C 84 20 00  F8 BC 2E 84  3D 18 C6 24
FB10:	03 08 42 38  80 61 08 4C  42 12 A6 29  26 10 84 21
FB20:	1C 00 6A B5  AD 40 0F 46  31 88 00 E8  C6 2E 00 3D
FB30:	1F 42 00 03  E2 F0 84 00  B6 21 08 00  0F 83 83 E2
FB40:	13 E4 21 06  00 46 31 8B  C0 08 C6 2A  20 01 18 D6
FB50:	AA 00 22 A2  2A 20 04 62  F0 B8 00 F8  88 8F 8C 84
FB60:	41 08 32 10  84 21 09 82  10 44 26 3E  00 00 00 07
FB70:	FF FF FF FF  00 00

; Cyrillic characters, codes 0x40-0x7F
FB76:	                   00 25  5E D6 40 07  82 F8 BC 2E
FB80:	87 A3 17 00  12 94 BE 10  01 CA 57 E2  00 3A 3F 83
FB90:	C0 07 56 AE  20 01 E8 42  10 00 22 A2  2A 20 04 67
FBA0:	5C C4 00 AC  EB 98 80 12  A6 29 20 00  E5 2D 52 00
FBB0:	47 75 8C 40  08 C7 F1 88  00 E8 C6 2E  00 3F 18 C6
FBC0:	20 03 E2 F2  E4 00 F4 7D  08 00 0F 84  20 F0 03 E4
FBD0:	21 08 00 46  2F 0B 80 0A  B9 D5 A8 01  E8 FA 3E 00
FBE0:	21 0F 47 C0  04 63 D9 F4  00 74 4D 17  00 15 AD 6B
FBF0:	F0 03 C1 38  7C 00 56 B5  F8 40 08 C5  E1 08 01 84
FC00:	39 2E 95 6B  DA D6 44 54  63 F8 C7 F0  F4 63 1F 4A
FC10:	52 94 BE 17  29 4A 57 E3  F8 43 F0 87  DD 5A D6 AE
FC20:	27 E1 08 42  10 8C 54 45  46 31 8C EB  98 C6 B5 9D
FC30:	73 18 C6 54  C5 25 17 94  A5 2D 53 1D  D6 B1 8C 63
FC40:	18 FE 31 8B  A3 18 C6 2E  FC 63 18 C6  2F 8C 5E 54
FC50:	C7 D1 8F A1  08 3A 30 84  22 EF 90 84  21 09 18 C5
FC60:	E1 8B AB 57  3A B5 AF A3  1F 46 3E 84  21 E8 C7 D1
FC70:	8C 7B 39 F5  D1 09 83 17  56 B5 AD 6B  F7 44 2F 0C
FC80:	5D 5A D6 B5  F8 63 18 BC  21 0F FF FF  FF FF
